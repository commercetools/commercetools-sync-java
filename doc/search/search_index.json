{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"commercetools sync \u00b6 Java library which allows to import/synchronise (import changes) the data from any arbitrary source to commercetools project. Supported resources: Categories , Products , InventoryEntries , ProductTypes , Types , CartDiscounts , States , TaxCategories , CustomObjects , Customers , ShoppingLists Usage \u00b6 Create you own event or cronjob based application and use the library to transform any external data (JSON, CSV, XML, REST API, DB, ...) into commercetools-jvm-sdk resource draft objects (e.g. CategoryDraft ) and import those into the commercetools project. Notes: It is often more efficient if you can setup your external data source to provide you only the changes (deltas) instead of the full data set on every import iteration. There is dockerized ready-to-use CLI application commercetools-project-sync which based on this library can synchronize entire data catalogue between the 2 commercetools projects. During a synchronisation, resources are either created or updated, but not deleted. \u26a1 See the Quick Start Guide for more information on building a product importer! Prerequisites \u00b6 Library requires the min JDK version >= 8 . The library tested with each major JDK version (i.e: 8, 9, 10, 11, 12, 13...) as well as some specific updates of LTS versions (i.e: 8.0.192, 11.0.3). A target commercetools project for syncing your source data to. Installation \u00b6 There are multiple ways to add the commercetools sync dependency to your project, based on your dependency manager. Here are the most popular ones: Maven \u00b6 <dependency> <groupId> com.commercetools </groupId> <artifactId> commercetools-sync-java </artifactId> <version> 10.0.5 </version> </dependency> Gradle \u00b6 implementation 'com.commercetools:commercetools-sync-java:10.0.5' SBT \u00b6 libraryDependencies += \"com.commercetools\" % \"commercetools-sync-java\" % \"10.0.5\" Ivy \u00b6 <dependency org= \"com.commercetools\" name= \"commercetools-sync-java\" rev= \"10.0.5\" />","title":"Overview"},{"location":"#commercetools-sync","text":"Java library which allows to import/synchronise (import changes) the data from any arbitrary source to commercetools project. Supported resources: Categories , Products , InventoryEntries , ProductTypes , Types , CartDiscounts , States , TaxCategories , CustomObjects , Customers , ShoppingLists","title":"commercetools sync"},{"location":"#usage","text":"Create you own event or cronjob based application and use the library to transform any external data (JSON, CSV, XML, REST API, DB, ...) into commercetools-jvm-sdk resource draft objects (e.g. CategoryDraft ) and import those into the commercetools project. Notes: It is often more efficient if you can setup your external data source to provide you only the changes (deltas) instead of the full data set on every import iteration. There is dockerized ready-to-use CLI application commercetools-project-sync which based on this library can synchronize entire data catalogue between the 2 commercetools projects. During a synchronisation, resources are either created or updated, but not deleted. \u26a1 See the Quick Start Guide for more information on building a product importer!","title":"Usage"},{"location":"#prerequisites","text":"Library requires the min JDK version >= 8 . The library tested with each major JDK version (i.e: 8, 9, 10, 11, 12, 13...) as well as some specific updates of LTS versions (i.e: 8.0.192, 11.0.3). A target commercetools project for syncing your source data to.","title":"Prerequisites"},{"location":"#installation","text":"There are multiple ways to add the commercetools sync dependency to your project, based on your dependency manager. Here are the most popular ones:","title":"Installation"},{"location":"#maven","text":"<dependency> <groupId> com.commercetools </groupId> <artifactId> commercetools-sync-java </artifactId> <version> 10.0.5 </version> </dependency>","title":"Maven"},{"location":"#gradle","text":"implementation 'com.commercetools:commercetools-sync-java:10.0.5'","title":"Gradle"},{"location":"#sbt","text":"libraryDependencies += \"com.commercetools\" % \"commercetools-sync-java\" % \"10.0.5\"","title":"SBT"},{"location":"#ivy","text":"<dependency org= \"com.commercetools\" name= \"commercetools-sync-java\" rev= \"10.0.5\" />","title":"Ivy"},{"location":"BENCHMARKS/","text":"Benchmarks \u00b6 Setup \u00b6 Benchmarks are run by JUnit as a separate source set just like main, test and integration-test. The benchmarks can be found here . Every time a commit is made in any branch, the benchmarks are run and the run shows whether the benchmarks exceed the pre-defined threshold, so that we know if the corresponding commit influences the performance. Benchmark results are written as JSON to benchmarks.json only when a new release is made. The JSON file is saved in the gh-pages branch of the repo. The average results in benchmarks.json are used to display the results in the form of this graph . Results \u00b6 Results as json can be found here . Results as a chart can be found here .","title":"Benchmarks"},{"location":"BENCHMARKS/#benchmarks","text":"","title":"Benchmarks"},{"location":"BENCHMARKS/#setup","text":"Benchmarks are run by JUnit as a separate source set just like main, test and integration-test. The benchmarks can be found here . Every time a commit is made in any branch, the benchmarks are run and the run shows whether the benchmarks exceed the pre-defined threshold, so that we know if the corresponding commit influences the performance. Benchmark results are written as JSON to benchmarks.json only when a new release is made. The JSON file is saved in the gh-pages branch of the repo. The average results in benchmarks.json are used to display the results in the form of this graph .","title":"Setup"},{"location":"BENCHMARKS/#results","text":"Results as json can be found here . Results as a chart can be found here .","title":"Results"},{"location":"BUILD/","text":"Table of Contents Release workflow Step 1: Pull request Step 2: Release library in Github Final Step Checklist Release workflow \u00b6 The main goal of the build process is to publish the artifacts to public repository Maven Central . Step 1: Pull request \u00b6 Create a new PR for the new release: - Increment the release version to the new library version, please follow the semantic versioning for finding the new version. - Make sure all the dependencies are up-to-date everywhere in the documentation files and the project files where needed. - Make sure to add a section for the release in the release notes . - Ask for review for this PR and then \"squash and merge\" to master. For example PR, see: https://github.com/commercetools/commercetools-sync-java/pull/412 Step 2: Release library in Github \u00b6 To release the library, you need to \"create a new release\" with Github, describe the new release as below and publish it. For example, define the link to the release notes pointing to a released version: #### 1.8.2 - [ Release notes ]( https://github.com/commercetools/commercetools-sync-java/blob/master/docs/RELEASE_NOTES.md#182----april-30-2020 ) - [ Javadoc ]( https://commercetools.github.io/commercetools-sync-java/v/1.8.2/ ) Additionally define important changes, breaking changes or important new features into the description. The creation of a github release triggers a github action , which will deploy the library first to Sonatype staging repo and then to Maven Central . Final Step \u00b6 After the release build status is success ensure that the new version is publicly available at Maven Central . Checklist \u00b6 Publish completed without an issue. The new version is available in the ( https://repo1.maven.org/maven2/com/commercetools/commercetools-sync-java )","title":"BUILD"},{"location":"BUILD/#release-workflow","text":"The main goal of the build process is to publish the artifacts to public repository Maven Central .","title":"Release workflow"},{"location":"BUILD/#step-1-pull-request","text":"Create a new PR for the new release: - Increment the release version to the new library version, please follow the semantic versioning for finding the new version. - Make sure all the dependencies are up-to-date everywhere in the documentation files and the project files where needed. - Make sure to add a section for the release in the release notes . - Ask for review for this PR and then \"squash and merge\" to master. For example PR, see: https://github.com/commercetools/commercetools-sync-java/pull/412","title":"Step 1: Pull request"},{"location":"BUILD/#step-2-release-library-in-github","text":"To release the library, you need to \"create a new release\" with Github, describe the new release as below and publish it. For example, define the link to the release notes pointing to a released version: #### 1.8.2 - [ Release notes ]( https://github.com/commercetools/commercetools-sync-java/blob/master/docs/RELEASE_NOTES.md#182----april-30-2020 ) - [ Javadoc ]( https://commercetools.github.io/commercetools-sync-java/v/1.8.2/ ) Additionally define important changes, breaking changes or important new features into the description. The creation of a github release triggers a github action , which will deploy the library first to Sonatype staging repo and then to Maven Central .","title":"Step 2: Release library in Github"},{"location":"BUILD/#final-step","text":"After the release build status is success ensure that the new version is publicly available at Maven Central .","title":"Final Step"},{"location":"BUILD/#checklist","text":"Publish completed without an issue. The new version is available in the ( https://repo1.maven.org/maven2/com/commercetools/commercetools-sync-java )","title":"Checklist"},{"location":"CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at support@commercetools.com . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/\u00bc","title":"Contributor Covenant Code of Conduct"},{"location":"CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"CODE_OF_CONDUCT/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at support@commercetools.com . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/\u00bc","title":"Attribution"},{"location":"CONTRIBUTING/","text":"Contributing to commercetools-sync-java \u00b6 These are the contribution guidelines for the commercetools-sync-java. Thanks for taking the time to contribute :+1::tada: All contributions are welcome! Contribution process for all committers Typos Features or Bug Fixes Development Build Run unit tests Package JARs Package JARs and run tests Full build with tests, but without install to maven local repo (Recommended) Install to local maven repo Publish JavaDoc Build and publish to Maven Central Integration Tests Running Using the google java style and code formatter IntelliJ, Android Studio, and other JetBrains IDEs Eclipse Spotless commands Run Spotless Style Check Fix Spotless style violations Ignoring mass reformatting commits with git blame Contribution process for all committers \u00b6 Typos \u00b6 If you have push access to the repository you can fix them directly otherwise just make a pull request. Features or Bug Fixes \u00b6 Every PR should address an issue on the repository. If the issue doesn't exist, please create it first and link PR with the issue. After your PR is approved by all reviewers and the build is green: Use Squash and merge option on a pull request on GitHub, with that the pull request's commits should be squashed into a single commit. > Instead of seeing all of a contributor's individual commit messages, the commits should be combined into one commit message with a clear commit description. Delete the branch when the PR is closed. Close the issue only if the change was released. Development \u00b6 Build \u00b6 Run unit tests \u00b6 ./gradlew test Package JARs \u00b6 ./gradlew clean jar Package JARs and run tests \u00b6 ./gradlew clean check Full build with tests, but without install to maven local repo (Recommended) \u00b6 ./gradlew clean build Install to local maven repo \u00b6 ./gradlew clean install Publish JavaDoc \u00b6 ./gradlew clean javadoc gitPublishPush -Dbuild.version ={ version } Build and publish to Maven Central \u00b6 ./gradlew clean setLibraryVersion -Dbuild.version ={ version } publishToSonatype closeAndReleaseSonatypeStagingRepository For more detailed information on the build and the release process, see Build and Release documentation. Integration Tests \u00b6 The integration tests of the library require to have two CTP projects (a source project and a target project) where the data will be tested to be synced from the source to the target project. Running the tests does the following: Clean all the data on both projects. Create test data in either/both projects depending on the test. Execute the tests. Clean all the data in both projects, leaving them empty. Running \u00b6 To run the integration tests, CTP credentials are required. The credential can be obtained once you create a CTP project. For details, please refer to the following link: https://docs.commercetools.com/merchant-center/projects.html#creating-a-project Use credentials Java properties file /src/integration-test/resources/it.properties : source.projectKey = aaaaa source.clientId = bbbbbbb source.clientSecret = ccc target.projectKey = ddddd target.clientId = eeeeeee target.clientSecret = fff Use it.properties.skeleton as a template to setup the credentials. Note : the it.properties file must be ignored by VCS. Set the following environment variables: export SOURCE_PROJECT_KEY = xxxxxxxxxxxxx export SOURCE_CLIENT_ID = xxxxxxxxxxxxxxx export SOURCE_CLIENT_SECRET = xxxxxxxxxxx export TARGET_PROJECT_KEY = xxxxxxxxxxxxx export TARGET_CLIENT_ID = xxxxxxxxxxxxxxx export TARGET_CLIENT_SECRET = xxxxxxxxxxx Note : it.properties file has precedence over environment variables. If the file exists - the environment variables are ignored. If the existing it.properties file is empty or one of the properties is missing - exception will be thrown on the execution of the tests If one of the two options above is set - run the integration tests: ./gradlew integrationTest Using the google java style and code formatter \u00b6 We are using google-java-format to format Java source code to comply with Google Java Style . IntelliJ, Android Studio, and other JetBrains IDEs \u00b6 A google-java-format IntelliJ plugin is available from the plugin repository. To install it, go to your IDE's settings and select the Plugins category. Click the Marketplace tab, search for the google-java-format plugin, and click the Install button. The plugin will be disabled by default. To enable it in the current project, go to File\u2192Settings...\u2192google-java-format Settings (or IntelliJIDEA\u2192Preferences...\u2192Other Settings\u2192google-java-format Settings on macOS) and check the Enable google-java-format checkbox. (A notification will be presented when you first open a project offering to do this for you.) To enable it by default in new projects, use File\u2192Other Settings\u2192Default Settings... . When enabled, it will replace the normal Reformat Code action, which can be triggered by the Code menu or with the Ctrl-Alt (by default) keyboard shortcut. Eclipse \u00b6 google-java-format Eclipse plugin can be downloaded from the releases page. Drop it into the Eclipse drop-ins folder to activate the plugin. The plugin adds a google-java-format formatter implementation that can be configured in Window > Preferences > Java > Code Style > Formatter > Formatter Implementation . Spotless commands \u00b6 Run Spotless Style Check \u00b6 ./gradlew spotlessCheck Fix Spotless style violations \u00b6 ./gradlew spotlessApply Ignoring mass reformatting commits with git blame \u00b6 To exclude the formatting commits git blame supports writing the commit hashes into a file and then referencing the file with --ignore-revs-file . To be able to archive that git blame ./file.java --ignore-revs-file .git-blame-ignore-revs command to ignore this revision to find a better git history. Also git config blame.ignoreRevsFile .git-blame-ignore-revs could be configured to ignore this revision always. We create .git-blame-ignore-revs that could be found in the repository.","title":"Contributing to commercetools-sync-java"},{"location":"CONTRIBUTING/#contributing-to-commercetools-sync-java","text":"These are the contribution guidelines for the commercetools-sync-java. Thanks for taking the time to contribute :+1::tada: All contributions are welcome! Contribution process for all committers Typos Features or Bug Fixes Development Build Run unit tests Package JARs Package JARs and run tests Full build with tests, but without install to maven local repo (Recommended) Install to local maven repo Publish JavaDoc Build and publish to Maven Central Integration Tests Running Using the google java style and code formatter IntelliJ, Android Studio, and other JetBrains IDEs Eclipse Spotless commands Run Spotless Style Check Fix Spotless style violations Ignoring mass reformatting commits with git blame","title":"Contributing to commercetools-sync-java"},{"location":"CONTRIBUTING/#contribution-process-for-all-committers","text":"","title":"Contribution process for all committers"},{"location":"CONTRIBUTING/#typos","text":"If you have push access to the repository you can fix them directly otherwise just make a pull request.","title":"Typos"},{"location":"CONTRIBUTING/#features-or-bug-fixes","text":"Every PR should address an issue on the repository. If the issue doesn't exist, please create it first and link PR with the issue. After your PR is approved by all reviewers and the build is green: Use Squash and merge option on a pull request on GitHub, with that the pull request's commits should be squashed into a single commit. > Instead of seeing all of a contributor's individual commit messages, the commits should be combined into one commit message with a clear commit description. Delete the branch when the PR is closed. Close the issue only if the change was released.","title":"Features or Bug Fixes"},{"location":"CONTRIBUTING/#development","text":"","title":"Development"},{"location":"CONTRIBUTING/#build","text":"","title":"Build"},{"location":"CONTRIBUTING/#run-unit-tests","text":"./gradlew test","title":"Run unit tests"},{"location":"CONTRIBUTING/#package-jars","text":"./gradlew clean jar","title":"Package JARs"},{"location":"CONTRIBUTING/#package-jars-and-run-tests","text":"./gradlew clean check","title":"Package JARs and run tests"},{"location":"CONTRIBUTING/#full-build-with-tests-but-without-install-to-maven-local-repo-recommended","text":"./gradlew clean build","title":"Full build with tests, but without install to maven local repo (Recommended)"},{"location":"CONTRIBUTING/#install-to-local-maven-repo","text":"./gradlew clean install","title":"Install to local maven repo"},{"location":"CONTRIBUTING/#publish-javadoc","text":"./gradlew clean javadoc gitPublishPush -Dbuild.version ={ version }","title":"Publish JavaDoc"},{"location":"CONTRIBUTING/#build-and-publish-to-maven-central","text":"./gradlew clean setLibraryVersion -Dbuild.version ={ version } publishToSonatype closeAndReleaseSonatypeStagingRepository For more detailed information on the build and the release process, see Build and Release documentation.","title":"Build and publish to Maven Central"},{"location":"CONTRIBUTING/#integration-tests","text":"The integration tests of the library require to have two CTP projects (a source project and a target project) where the data will be tested to be synced from the source to the target project. Running the tests does the following: Clean all the data on both projects. Create test data in either/both projects depending on the test. Execute the tests. Clean all the data in both projects, leaving them empty.","title":"Integration Tests"},{"location":"CONTRIBUTING/#running","text":"To run the integration tests, CTP credentials are required. The credential can be obtained once you create a CTP project. For details, please refer to the following link: https://docs.commercetools.com/merchant-center/projects.html#creating-a-project Use credentials Java properties file /src/integration-test/resources/it.properties : source.projectKey = aaaaa source.clientId = bbbbbbb source.clientSecret = ccc target.projectKey = ddddd target.clientId = eeeeeee target.clientSecret = fff Use it.properties.skeleton as a template to setup the credentials. Note : the it.properties file must be ignored by VCS. Set the following environment variables: export SOURCE_PROJECT_KEY = xxxxxxxxxxxxx export SOURCE_CLIENT_ID = xxxxxxxxxxxxxxx export SOURCE_CLIENT_SECRET = xxxxxxxxxxx export TARGET_PROJECT_KEY = xxxxxxxxxxxxx export TARGET_CLIENT_ID = xxxxxxxxxxxxxxx export TARGET_CLIENT_SECRET = xxxxxxxxxxx Note : it.properties file has precedence over environment variables. If the file exists - the environment variables are ignored. If the existing it.properties file is empty or one of the properties is missing - exception will be thrown on the execution of the tests If one of the two options above is set - run the integration tests: ./gradlew integrationTest","title":"Running"},{"location":"CONTRIBUTING/#using-the-google-java-style-and-code-formatter","text":"We are using google-java-format to format Java source code to comply with Google Java Style .","title":"Using the google java style and code formatter"},{"location":"CONTRIBUTING/#intellij-android-studio-and-other-jetbrains-ides","text":"A google-java-format IntelliJ plugin is available from the plugin repository. To install it, go to your IDE's settings and select the Plugins category. Click the Marketplace tab, search for the google-java-format plugin, and click the Install button. The plugin will be disabled by default. To enable it in the current project, go to File\u2192Settings...\u2192google-java-format Settings (or IntelliJIDEA\u2192Preferences...\u2192Other Settings\u2192google-java-format Settings on macOS) and check the Enable google-java-format checkbox. (A notification will be presented when you first open a project offering to do this for you.) To enable it by default in new projects, use File\u2192Other Settings\u2192Default Settings... . When enabled, it will replace the normal Reformat Code action, which can be triggered by the Code menu or with the Ctrl-Alt (by default) keyboard shortcut.","title":"IntelliJ, Android Studio, and other JetBrains IDEs"},{"location":"CONTRIBUTING/#eclipse","text":"google-java-format Eclipse plugin can be downloaded from the releases page. Drop it into the Eclipse drop-ins folder to activate the plugin. The plugin adds a google-java-format formatter implementation that can be configured in Window > Preferences > Java > Code Style > Formatter > Formatter Implementation .","title":"Eclipse"},{"location":"CONTRIBUTING/#spotless-commands","text":"","title":"Spotless commands"},{"location":"CONTRIBUTING/#run-spotless-style-check","text":"./gradlew spotlessCheck","title":"Run Spotless Style Check"},{"location":"CONTRIBUTING/#fix-spotless-style-violations","text":"./gradlew spotlessApply","title":"Fix Spotless style violations"},{"location":"CONTRIBUTING/#ignoring-mass-reformatting-commits-with-git-blame","text":"To exclude the formatting commits git blame supports writing the commit hashes into a file and then referencing the file with --ignore-revs-file . To be able to archive that git blame ./file.java --ignore-revs-file .git-blame-ignore-revs command to ignore this revision to find a better git history. Also git config blame.ignoreRevsFile .git-blame-ignore-revs could be configured to ignore this revision always. We create .git-blame-ignore-revs that could be found in the repository.","title":"Ignoring mass reformatting commits with git blame"},{"location":"DOCUMENTATION_PAGES/","text":"Building the Documentation Pages \u00b6 The documentation pages are published here: https://commercetools.github.io/commercetools-sync-java mkdocs documentation . mkdocs-material documentation . Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Gradle tasks \u00b6 mkdocsInit - Create new mkdocs site (like this). mkdocsBuild - Build the documentation site. mkdocsServe - Start the live-reloading docs server. mkdocsPublish - Publish generated site version to github pages. Mkdocs native Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Building the Documentation Pages"},{"location":"DOCUMENTATION_PAGES/#building-the-documentation-pages","text":"The documentation pages are published here: https://commercetools.github.io/commercetools-sync-java mkdocs documentation . mkdocs-material documentation .","title":"Building the Documentation Pages"},{"location":"DOCUMENTATION_PAGES/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"DOCUMENTATION_PAGES/#gradle-tasks","text":"mkdocsInit - Create new mkdocs site (like this). mkdocsBuild - Build the documentation site. mkdocsServe - Start the live-reloading docs server. mkdocsPublish - Publish generated site version to github pages.","title":"Gradle tasks"},{"location":"DOCUMENTATION_PAGES/#mkdocs-native-commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Mkdocs native Commands"},{"location":"MIGRATION_GUIDE/","text":"Table of Contents generated with DocToc Migration Guide Migrate syncers of supported resources Categories , Products InventoryEntries ProductTypes Types CartDiscounts States TaxCategories CustomObjects Customers ShoppingLists Migration Guide \u00b6 The commercetools sync library uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . Common Changes \u00b6 Some utility methods aren't available in this version. Please make sure to replace these. Here's a list of changes: Removed utility methods: // CollectionUtils public static < T > Set < T > emptyIfNull ( @Nullable final Set < T > set ) // ShoppingListReferenceResolutionUtils public static ShoppingListQuery buildShoppingListQuery () { return ShoppingListQuery . of (). plusExpansionPaths ( ExpansionPath . of ( \"lineItems[*].variant\" )); } Changed scope of utility method: // CompletableFutureUtils private static < T , S , U extends Collection < CompletableFuture < S >>> U mapValuesToFutures ( @Nonnull final Stream < T > values , @Nonnull final Function < T , CompletionStage < S >> mapper , @Nonnull final Collector < CompletableFuture < S > , ? , U > collector ) Removed helper class: ChannelCustomActionBuilder // Included these methods public UpdateAction < Channel > buildRemoveCustomTypeAction ( @Nullable final Integer variantId , @Nullable final String objectId ); public UpdateAction < Channel > buildSetCustomTypeAction ( @Nullable final Integer variantId , @Nullable final String objectId , @Nonnull final String customTypeId , @Nullable final Map < String , JsonNode > customFieldsJsonMap ); public UpdateAction < Channel > buildSetCustomFieldAction ( @Nullable final Integer variantId , @Nullable final String objectId , @Nullable final String customFieldName , @Nullable final JsonNode customFieldValue ); Migrate syncers of supported resources \u00b6 Categories , Products InventoryEntries ProductTypes Types CartDiscounts States TaxCategories CustomObjects Customers ShoppingLists","title":"MIGRATION GUIDE"},{"location":"MIGRATION_GUIDE/#migration-guide","text":"The commercetools sync library uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client .","title":"Migration Guide"},{"location":"MIGRATION_GUIDE/#common-changes","text":"Some utility methods aren't available in this version. Please make sure to replace these. Here's a list of changes: Removed utility methods: // CollectionUtils public static < T > Set < T > emptyIfNull ( @Nullable final Set < T > set ) // ShoppingListReferenceResolutionUtils public static ShoppingListQuery buildShoppingListQuery () { return ShoppingListQuery . of (). plusExpansionPaths ( ExpansionPath . of ( \"lineItems[*].variant\" )); } Changed scope of utility method: // CompletableFutureUtils private static < T , S , U extends Collection < CompletableFuture < S >>> U mapValuesToFutures ( @Nonnull final Stream < T > values , @Nonnull final Function < T , CompletionStage < S >> mapper , @Nonnull final Collector < CompletableFuture < S > , ? , U > collector ) Removed helper class: ChannelCustomActionBuilder // Included these methods public UpdateAction < Channel > buildRemoveCustomTypeAction ( @Nullable final Integer variantId , @Nullable final String objectId ); public UpdateAction < Channel > buildSetCustomTypeAction ( @Nullable final Integer variantId , @Nullable final String objectId , @Nonnull final String customTypeId , @Nullable final Map < String , JsonNode > customFieldsJsonMap ); public UpdateAction < Channel > buildSetCustomFieldAction ( @Nullable final Integer variantId , @Nullable final String objectId , @Nullable final String customFieldName , @Nullable final JsonNode customFieldValue );","title":"Common Changes"},{"location":"MIGRATION_GUIDE/#migrate-syncers-of-supported-resources","text":"Categories , Products InventoryEntries ProductTypes Types CartDiscounts States TaxCategories CustomObjects Customers ShoppingLists","title":"Migrate syncers of supported resources"},{"location":"RELEASE_NOTES/","text":"Release Notes \u00b6 10.0.5 - Feb 8, 2024 \u00b6 Commits | Javadoc | Jar - \ud83d\udc1e Bug Fixes (1) - Fix images not being returned by variant resolution utils ( https://github.com/commercetools/commercetools-project-sync/issues/555 ) 10.0.4 - Jan 9, 2024 \u00b6 Commits | Javadoc | Jar - \ud83d\udc1e Bug Fixes (1) - Fix getting a wrong JSON Object mapper ( https://github.com/commercetools/commercetools-sync-java/issues/1138 ) 10.0.3 - Dec 21, 2023 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Fix NullPointerException for products having a category but no category order hints ( https://github.com/commercetools/commercetools-sync-java/pull/1134 ) 10.0.2 - Dec 05, 2023 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (4) Product Sync - Sync now supports syncing of products with attributes referencing themselves. #478 State Sync - Fix NPE thrown by StateDraftBuilder.build() when required fields are missing. The StateTransformUtils.toStateDrafts utility returns an empty draft when key is null or empty. Inventory Sync - Fix NPE thrown by InventoryEntryDraftBuilder.build() when required fields are missing. The InventoryTransformUtils.toInventoryEntryDrafts utility returns an empty draft when sku is null or empty. ProductType Sync - Fix ReferenceResolution of product-type attributes to avoid sync errors. 10.0.1 - Nov 14, 2023 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug fixes (1) Make commercetools-sdk-java-v2 available as a transitive dependency 10.0.0 - Nov 6, 2023 \u00b6 Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) commercetools-sync-java is now fully migrated to commercetools-sdk-java-v2 . See Migration Guide on how to use this library version. 9.2.3 - Mar 21, 2023 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes Fix the problem when switching master variants #918 9.2.1 - Feb 10, 2023 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes Fix rich type reference issue in product type #893 \ud83d\udee0\ufe0f Dependency Updates Migrated com.commercetools.sdk.jvm.core to 2.12.0 9.2.0 - Dec 06, 2022 \u00b6 Commits | Javadoc | Jar - \u2728 Enhancements (2) - Display Github tag instead of Github commit hash in Benchmarks chart #867 - Run Bechmarks test in every commit #868 To help developers to review the performance change before creating new release, benchmarks test now executes not only during making new release, but also pushing new commit in branches. The test result of commit is displayed in the build in Github Action. It shows whether benchmarks of current commit over the pre-defined threshold, while the benchmarks chart keeps displaying the test result of each library version. \ud83d\udc1e Bug Fixes Fix NPE in ProductSync benchmarks test for SDK-v2 #874 \ud83d\udee0\ufe0f Dependency Updates Migrated com.commercetools.sdk from 9.4.0 to 9.5.0 Migrated com.github.ben-manes.caffeine 3.1.1 to 3.1.2 Migrated com.github.ben-manes.versions 0.43.0 -> 0.44.0 Migrated ru.vyarus.mkdocs 2.4.0 -> 3.0.0 9.1.0 - Nov 02, 2022 \u00b6 Commits | Javadoc | Jar - \u2728 Enhancement (1) - Java SDK-v2 Compatible layer adaption #859 Commercetools has already developed [next generation Java SDK (Java-SDK-v2)](https://github.com/commercetools/commercetools-sdk-java-v2) for communication between client-side and the platform. As it provides a compatible layer which ease the migration work, we now provide alternative methods in [ClientConfigurationUtils](https://github.com/commercetools/commercetools-sync-java/blob/master/src/main/java/com/commercetools/sync/commons/utils/ClientConfigurationUtils.java) for client creation purpose. Meanwhile the original methods keep unchanged and support client creation with [existing JAVA SDK](https://github.com/commercetools/commercetools-jvm-sdk). For details how to create client from Java-SDK-v2, please refer to [Important Usage Tips](https://github.com/commercetools/commercetools-sync-java/blob/master/docs/usage/IMPORTANT_USAGE_TIPS.md) \ud83d\udee0\ufe0f Dependency Updates Added com.commercetools.sdk 9.4.0 Migrated com.diffplug.spotless plugin from 6.9.1 to 6.11.0 . Migrated com.github.ben-manes.versions 0.42.0 -> 0.43.0 Migrated com.github.spotbugs 5.0.12 -> 5.0.13 Migrated commercetools-jvm-sdk -> 2.9.0 Migrated org.apache.commons:common-text 1.9 -> 1.10 Migrated org.mockito:mockito-junit-jupiter 4.7.0 -> 4.8.1 9.0.3 - Sep 22, 2022 \u00b6 Commits | Javadoc | Jar - \ud83d\udc1e Bug Fixes - Fix broken link in the github.io documentation #853 9.0.2 - Sep 21, 2022 \u00b6 Commits | Javadoc | Jar - \ud83d\udc1e Bug Fixes - Add correct resources to the error callbacks #850 9.0.1 - Aug 13, 2022 \u00b6 Commits | Javadoc | Jar - \ud83d\udc1e Bug Fixes - Fix broken links in the github.io documentation #843 - \ud83d\udee0\ufe0f Dependency Updates - org.ajoberstar.git-publish 4.1.0 -> 4.1.1 - org.mockito:mockito-junit-jupiter 4.6.1 -> 4.7.0 - com.diffplug.spotless 6.9.0 -> 6.9.1 9.0.0 - Aug 8, 2022 \u00b6 Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) Minimum Java 11 or above is required #840 \u2728 Build Tools Migrated org.ajoberstar.grgit plugin from 4.1.1 to 5.0.0 . Migrated org.ajoberstar.git-publish plugin from 3.0.1 to 4.1.0 . \ud83d\udee0\ufe0f Dependency Updates commercetools-jvm-sdk 2.6.0 -> 2.9.0 caffeineVersion 2.9.3 -> 3.1.1 8.1.1 - Mar 21, 2022 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Product Sync - Fixed the AddToCategory , RemoveFromCategory action, which creates unnecessary update action when there is no difference and it leads to error. #816 \u2728 Enhancement (1) Resolve warnings and deprecated usages. #808 \u2728 Build Tools Migrated from gradle v7.3.1 to v7.3.3 . Migrated github actions setup-java plugin from v2 to v3 \ud83d\udee0\ufe0f Dependency Updates commercetools-jvm-sdk 2.5.0 -> 2.6.0 com.github.spotbugs 5.0.2 -> 5.0.5 com.diffplug.spotless 6.0.4 -> 6.2.0 mockito-junit-jupiter 4.1.0 -> 4.3.1 org.assertj.assertj-core 3.21.0 -> 3.22.0 8.1.0 - Dec 14, 2021 \u00b6 Commits | Javadoc | Jar \u2728 Build Tools Migrated from gradle v6.8.2 to v7.3.1 . Migrated github actions setup-java plugin from v1 to v2 Migrated github actions codecov-action plugin from v1 to v2 \ud83d\udee0\ufe0f Dependency Updates commercetools-jvm-sdk 1.64.0 -> 2.5.0 com.adarshr.test-logger 3.0.0 -> 3.1.0 ru.vyarus.mkdocs 2.1.2 -> 2.2.0 org.ajoberstar.grgit 4.1.0 -> 4.1.1 com.github.spotbugs 4.7.1 -> 5.0.2 com.diffplug.spotless 5.14.2 -> 6.0.4 mockito-junit-jupiter 3.11.2 -> 4.1.0 org.junit.jupiter:junit-jupiter-api 5.7.2 -> 5.8.2 org.junit.jupiter:junit-jupiter-engine 5.7.2 -> 5.8.2 org.junit.jupiter:junit-jupiter-params 5.7.2 -> 5.8.2 org.assertj.assertj-core 3.20.2 -> 3.21.0 com.github.ben-manes.caffeine 2.9.2 -> 2.9.3 (new) org.apache.commons:common-text 1.9 8.0.0 - Oct 1, 2021 \u00b6 Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) Removed support of changing the attribute definition type #787 since removal and addition of the attribute with the same name in a single request is not possible by commercetools API anymore. For more information please check . \u2728 Enhancement (1) Use the new concurrency keyword on github actions to limit the concurrency of the workflow runs. #772 7.0.2 - Sep 21, 2021 \u00b6 Commits | Javadoc | Jar \u2728 Enhancement (1) Dependency management - Migrate Dependabot to Renovate. #767 \u2728 Documentation (1) - Update docs and Release notes about the usage of JVM-SDK dependencies. #766 7.0.1 - Sep 15, 2021 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) State Sync - State to sync correctly from source to target when no transitions configured. #763 7.0.0 - Aug 24, 2021 \u00b6 Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) Dependency management: To avoid commercetools JVM SDK libraries version mismatch between projects. It is better not to add commercetools JVM SDK dependencies explicitly into your project and use them from commercetools-Sync-Java dependencies instead. Check README.md for more details. \u2728 Documentation (1) - Usage documentation on main readme improved, obsolete links is removed. #758 6.0.0 - Jul 19, 2021 \u00b6 Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) Inventory Sync : InventoryService.fetchInventoryEntriesBySkus(Set<String> skus) is renamed to InventoryService.fetchInventoryEntriesByIdentifiers(Set<InventoryEntryIdentifier> inventoryEntryIdentifiers) . #757 \ud83d\udc1e Bug Fixes (1) Inventory Sync - Fixed the DuplicateField bug in the InventorySync related to fetching and syncing inventories with multiple channels. #757 5.1.3 - Jul 8, 2021 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) TaxCategory Sync - TaxCategories to sync properly when we have many TaxRates with different states. \u2728 Enhancements (1) Product Sync - After a fix from JVM-SDK(1.64.0), ProductProjection search uses built in predicate to filter resources by the key to avoid issues like #269 . \ud83d\udee0\ufe0f Dependency Updates (5) commercetools-jvm-sdk 1.63.0 -> 1.64.0 assertjVersion 3.19.0 -> 3.20.2 caffeineVersion 2.9.1 -> 2.9.2 mockitoJunitJupiterVersion 3.10.0 -> 3.11.2 com.diffplug.spotless 5.12.5 -> 5.14.0 5.1.2 - May 31, 2021 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Product Sync - The user is now aware of unresolvable references as the transform service will not skip the products. \ud83d\udee0\ufe0f Dependency Updates (3) com.github.ben-manes.versions 0.38.0 -> 0.39.0 caffeineVersion 2.8.5 -> 2.9.1 netty-codec-http 4.1.64.Final -> 4.1.65.Final 5.1.1 - May 18, 2021 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (2) Product Sync - Special characters can be defined for ProductDraft key. #269 Product Sync - After a fix from JVM-SDK(1.63.0), Added integration tests to make sure PriceTiers are synched successfully. #271 \ud83d\udee0\ufe0f Dependency Updates (7) commercetools-jvm-sdk 1.62.0 -> 1.63.0 io.codearte.nexus-staging 0.30.0 -> io.github.gradle-nexus.publish-plugin 1.11.0 (Adapt new gradle plugin for artifact publishing) com.github.spotbugs 4.7.0 -> 4.7.1 com.diffplug.spotless 5.12.1 -> 5.12.5 org.mockito:mockito-junit-jupiter 3.9.0 -> 3.10.0 org.junit.jupiter 5.7.0 -> 5.7.2 netty-codec-http 4.1.63.Final -> 4.1.64.Final Build Tools (1) - Change build script and cd.yml for new gradle publish plugin. 5.1.0 - Apr 20, 2021 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Syncing product types with an attribute of type Set of (Set of Set of..) of NestedType attribute is supported. #720 5.0.0 - Apr 12, 2021 \u00b6 Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (2) For mapping a resource (Product, Category, CartDiscount, ShoppingList, State, InventoryEntry, ProductType, Customer) to resourceDraft the new util method should be called. Example for Product Sync : For mapping from Product to ProductDraft the util method ProductTransformUtils.toProductDrafts should be called along with sphereClient , cache implementation( ReferenceIdToKeyCache ) and productTypes parameters. Product Sync : The productProjections endpoint is used instead of products endpoint to improve the performance of the product Sync . Changes: The callbacks of the product Sync will now work with productProjections instead of products The update action ( buildCustomUpdateActions , buildAssetsUpdateActions , buildAssetActions ) doesn't require the \"old Resource\" as parameter anymore. All update actions of products now working with ProductProjections instead of Products The method syncFrenchDataOnly has a new signature public static List<UpdateAction<Product>> syncFrenchDataOnly(@Nonnull final List<UpdateAction<Product>> updateActions, @Nonnull final ProductDraft newProductDraft, @Nonnull final ProductProjection oldProduct) The method keepOtherVariants has a new signature List<UpdateAction<Product>> keepOtherVariants( @Nonnull final List<UpdateAction<Product>> updateActions) The method mapToProductDrafts has a new signature public static List<ProductDraft> mapToProductDrafts(Nonnull final List<ProductProjection> products) The method getDraftBuilderFromStagedProduct has a new signature public static ProductDraftBuildergetDraft BuilderFromStagedProduct(@Nonnull final ProductProjection product) The method buildProductQuery has a new signature public static ProductProjectionQuery buildProductQuery() The method buildCategoryActions has a new signature public static List<UpdateAction<Product>> buildCategoryActions(@Nonnull final ProductProjection oldProduct, @Nonnull final ProductDraft newProduct) The class BaseSyncOptions has a new generics <A> , which indicate the resource type to update The class BaseSyncOptionsBuilder has a new generics <A> , which indicate the resource type to update \u2728 Enhancements (2) To improve performance of the library, We are not expanding any references in the query for the resources, Instead library fetches key-id pairs and stores in a cache to reuse them. Example for ProductSync: The util class method ProductTransformUtils.toProductDrafts will fetch key-id pairs and stores in a cache. This cache has been used to build the productDraft by resolving references. For detailed documentation refer - syncing-from-a-commercetools-project Product Sync Use the new addVariant which supports the adding assets of the new variant. #714 Support synchronization of state and customer references in product variant attributes. #715 \ud83d\udee0\ufe0f Dependency Updates (1) commercetools-jvm-sdk 1.60.0 -> 1.62.0 4.0.1 - Mar 19, 2021 \u00b6 Commits | Javadoc | Jar \u2728 Enhancements (1) To avoid 414 request-URI too large error, the services are using chunking on the input list(keys or sku's) to chunk the input considering the length of the request URI and execute the query for these chunks. \u2728 Build Tools (1) Migrated from gradle v5.6.2 to v6.8.2 . \ud83d\udee0\ufe0f Dependency Updates (1) Updated the following transitive dependencies to avoid vulnerability issues of previous versions: com.fasterxml.jackson.dataformat:jackson-dataformat-cbor -> Fixed vulnerability issue for DoS attacks io.netty:netty-codec-http -> Fixed vulnerability issue for Information Disclosure org.apache.httpcomponents:httpclient -> Fixed vulnerability issue for Improper Input Validation commons-codec:commons-codec -> Fixed vulnerability issue for Information Exposure 4.0.0 - Feb 26, 2021 \u00b6 Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) Product Sync : PriceDraft.getCustomerGroup() is changed from Reference<CustomerGroup> to ResourceIdentifier<CustomerGroup> , so as a library user you don't need to provide a key field in the id field of the Reference. (Now API and JVM SDK support ResourceIdentifiers and it supports id or key as a field). #676 \u2728 Enhancements (1) Refactored CategorySync to make it consistent with other Sync types (e.g ProductSync). #681 \ud83d\udee0\ufe0f Dependency Updates (2) commercetools-jvm-sdk 1.57.0 -> 1.60.0 commercetools-java-client -> commercetools-java-client-ahc-2_5 -> Upgraded the default http client to avoid \"Runtime Access Warnings\" because of out of date netty dependencies on jvm-sdk. Note: commercetools-java-client-ahc-2_5 dependency uses async-http-client version 2.5.4 \u2728 Build Tools (1) Migrating from JCenter / Bintray to The Maven Central Repository. Additionally, automate the staging process from OSSRH from maven central . #667 3.2.0 - Feb 3, 2021 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Now the categories, which have an unresolvable parent category, are persisted in custom objects, so they can be resolved in different executions / instances of the category sync. #658 \ud83d\udc1e Bug Fixes (1) To avoid Error 413 (Request Entity Too Large) issues, a fix added to unresolved reference custom object fetching. #666 \ud83d\udee0\ufe0f Dependency Updates (1) commercetools-jvm-sdk 1.56.0 -> 1.57.0 \u2728 Build Tools (1) Migrate to github actions from travis-ci #664 3.1.0 - Jan 13, 2021 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Added clean up implementation for the outdated pending reference resolution custom objects. #650 \u2728 Enhancements (1) Added a graphQL pagination utility. #627 \u2728 Documentation (1) Documentation added for the cleaning up of the unresolved references, check the cleanup guide for more details. 3.0.2 - Dec 16, 2020 \u00b6 Commits | Javadoc | Jar \u2728 Documentation (2) Documentation for the cacheSize sync option is added. Prerequisites section of the documentations are clarified and added more code snippets as usage examples. \ud83d\udee0\ufe0f Dependency Updates (1) commercetools-jvm-sdk 1.55.0 -> 1.56.0 3.0.1 - Nov 24, 2020 \u00b6 Commits | Javadoc | Jar \u2728 Enhancements (1) To improve performance of the library, the services are using graphQL API to fetch resource ids only; also the keyToId caches evict entries which haven't been used for the longest amount of time beyond a maximum size. The cache size is configurable in the sync options. #582 \ud83d\udee0\ufe0f Dependency Updates (2) commercetools-jvm-sdk 1.54.0 -> 1.55.0 (new) com.github.ben-manes.caffeine 2.8.5 3.0.0 - Nov 18, 2020 \u00b6 Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) Product Sync : ProductDraft.getState() is changed from Reference<State> to ResourceIdentifier<State> , so as a library user you don't need to provide a key field in the id field of the Reference. (Now API and JVM SDK support ResourceIdentifiers and it supports id or key as a field). #589 \ud83d\udc1e Bug Fixes (1) Commons - Fixed a bug in the duration calculation of decorated retry sphere client RetrySphereClientDecorator created by ClientConfigurationUtils . #610 \ud83c\udf89 New Features (4) ShoppingList Sync - Added support for syncing shopping lists between ctp projects. #594 ShoppingList Sync - Introduced ShoppingListSyncUtils which calculates all needed update actions after comparing a ShoppingList and a ShoppingListDraft . #594 ShoppingList Sync - Introduced ShoppingListUpdateActionUtils which contains utils for calculating necessary update actions after comparing individual fields of a ShoppingList and a ShoppingListDraft . #594 ShoppingList Sync - Introduced ShoppingListReferenceResolutionUtils which resolves Type references from a ShoppingList to a ShoppingListDraft. #594 \ud83d\udee0\ufe0f Dependency Updates (1) commercetools-jvm-sdk 1.53.0 -> 1.54.0 mockito-junit-jupiter 3.5.13 -> 3.6.0 org.assertj.assertj-core 3.17.2 -> 3.18.1 2.3.0 - Oct 15, 2020 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (4) Customer Sync - Added support for syncing customers between ctp projects. #579 Customer Sync - Introduced CustomerSyncUtils which calculates all needed update actions after comparing a Customer and a CustomerDraft . #579 Customer Sync - Introduced CustomerUpdateActionUtils which contains utils for calculating needed update actions after comparing individual fields of a Customer and a CustomerDraft . #579 Customer Sync - Introduced CustomerReferenceResolutionUtils which resolves CustomerGroup and Type references from a Customer to a CustomerDraft. #579 2.2.1 - Sep 29, 2020 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Product Sync - Fixed a bug in the ProductSync related handling of unresolved product references provided in different batches. #580 2.2.0 - Sep 25, 2020 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (2) Product Sync - Added support for resolving key-value-document (custom object) references on attributes of type Reference , Set of Reference , NestedType or Set of NestedType . #564 Introduced new concept for the validation of the drafts in batches for each Sync instance, exposed with BaseBatchValidator implementations (i.e. ProductBatchValidator, CategoryBatchValidator). #233 \u2728 Enhancements (2) Category Sync - Passed category keys in batch to cacheKeysToIds method of CategoryService to avoid fetching all categories for every batch. #235 Populated keyToId caches in services before reference resolution to improve the performance of the library with collecting referenced keys in batches of drafts. #235 \ud83d\udee0\ufe0f Dependency Updates (1) mockito-junit-jupiter 3.5.11 -> 3.5.13 2.1.0 - Sep 21, 2020 \u00b6 Commits | Javadoc | Jar - \ud83c\udf89 New Features (2) - CustomObject Sync - Added support for syncing custom objects between ctp projects. #565 For more info how to use it please refer to CustomObject usage doc . - CustomObject Sync - Exposed CustomObjectSyncUtils#hasIdenticalValue which determines whether update process is required after comparing a CustomObject and a CustomObjectDraft . #565 \ud83d\udee0\ufe0f Dependency Updates (3) org.ajoberstar.git-publish 2.1.3 -> 3.0.0 org.ajoberstar.grgit 4.0.2 -> 4.1.0 mockito-junit-jupiter 3.5.10 -> 3.5.11 2.0.0 - Sept 14, 2020 \u00b6 Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (2) Sync options: The signatures of the errorCallback and warningCallback changed and their parameter lists are extended. From now on the resource draft of the source project, the resource of the target project and optionally the failed update actions passed to the callbacks. Refer sync options for more details. #107 Reference resolution utilities: Commons - Renamed replaceCustomTypeIdWithKeys to mapToCustomFieldsDraft . #138 Commons - Renamed replaceAssetsReferencesIdsWithKeys to mapToAssetDrafts . #138 Category Sync - Renamed replaceCategoriesReferenceIdsWithKeys to mapToCategoryDrafts . #138 CartDiscount Sync - Renamed replaceCartDiscountsReferenceIdsWithKeys to mapToCartDiscountDrafts . #138 Inventory Sync - Renamed replaceInventoriesReferenceIdsWithKeys to mapToInventoryEntryDrafts . #138 Product Sync - Renamed replaceProductsReferenceIdsWithKeys to mapToProductDrafts . #138 State Sync - Renamed replaceStateReferenceIdsWithKeys to mapToStateDrafts . #138 ProductType Sync - Renamed replaceProductTypesReferenceIdsWithKeys to mapToProductTypeDrafts . #138 \u2728 Enhancements (1) The library will fail fast for the non-existing references that found during the reference resolution. #219 \ud83d\udee0\ufe0f Dependency Updates (4) commercetools-jvm-sdk 1.52.0 -> 1.53.0 org.assertj.assertj-core 3.16.0 -> 3.17.2 junit.jupiterApiVersion 5.6.2 -> 5.7.0 mockito-junit-jupiter 3.4.4 -> 3.5.10 com.github.ben-manes.versions 0.29.0 -> 0.33.0 1.9.1 - Aug 5, 2020 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Product Sync - Fixed a bug in the ProductSync related to publish/unpublish of the product update actions, when a new product draft has publish flag set to true and the existing product is published already then no publish action will be created which was not correct #530 1.9.0 - July 27, 2020 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (6) TaxCategory Sync - Added support for syncing tax categories. #417 For more info how to use it please refer to TaxCategory usage doc . TaxCategory Sync - Exposed TaxCategorySyncUtils#buildActions which calculates all needed update actions after comparing a TaxCategory and a TaxCategoryDraft . #417 TaxCategory Sync - Exposed TaxCategoryUpdateActionUtils which contains utils for calculating needed update actions after comparing individual fields of a TaxCategory and a TaxCategoryDraft . #417 State Sync - Added support for syncing states. #409 For more info how to use it please refer to States usage doc . State Sync - Exposed StateSyncUtils#buildActions which calculates all needed update actions after comparing a State and a StateDraft . #409 State Sync - Exposed StateUpdateActionUtils which contains utils for calculating needed update actions after comparing individual fields of a State and a StateDraft . #409 Thanks, @jarzynp for the contributions! \ud83d\udee0\ufe0f Dependency Updates (6) com.adarshr.test-logger 2.0.0 -> 2.1.0 org.assertj.assertj-core 3.15.0 -> 3.16.0 junit.jupiterApiVersion 5.6.1 -> 5.6.2 commercetools-jvm-sdk 1.51.0 -> 1.52.0 mockito-junit-jupiter 3.3.3 -> 3.4.4 com.github.ben-manes.versions 0.28.0 -> 0.29.0 1.8.2 - April 30, 2020 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (2) Commons - Fixed a bug in the Sync implementations causing the sync fail with throwing ClassCastException . #466 Product Sync - Fixed a bug in the ProductSync related to the ordering of variant update actions, which was not correct when there is SetAttributeInAllVariants action in update actions. Thanks, @ahmed-ali225, for the contributions! #513 1.8.1 - April 22, 2020 \u00b6 Commits | Javadoc | Jar \u2728 Enhancements (1) Commons - Remove final keyword on interface/abstract method params. #165 \ud83d\udc1e Bug Fixes (3) CartDiscount Sync - Fixed a bug in the CartDiscountSync which generates a changeValue action when there is no change, causing the sync to fail for that cart discount. Thanks, @michaelbannister, for the contributions! #494 Product Sync - Fixed a bug in the ProductSync when ensurePriceChannels is enabled in ProductSyncOptions should not create a missing channel used on product variant price draft. #499 Product/Category Sync - Validate that asset keys are always defined on the supplied drafts and the existing target resources (products/categories). #366 \ud83d\udee0\ufe0f Dependency Updates (5) junit.jupiterApiVersion 5.5.2 -> 5.6.1 commercetools-jvm-sdk 1.48.0 -> 1.51.0 org.assertj.assertj-core 3.14.0 -> 3.15.0 mockito-junit-jupiter 3.2.4 -> 3.3.3 com.github.ben-manes.versions 0.27.0 -> 0.28.0 ru.vyarus.mkdocs 2.0.0 -> 2.0.1 org.ajoberstar.grgit 4.0.1 -> 4.0.2 1.8.0 - Jan 17, 2020 \u00b6 Commits | Javadoc | Jar \u2728 Enhancements (1) Inventory Sync - Only cache the needed keys of Channel references instead of caching all keys of such resources. #198 Note : This might have performance implications on the inventory sync, since now every non cached key-id entry will be individually fetched. However, issue #235 should address this. 1.7.0 - Jan 7, 2020 \u00b6 Commits | Javadoc | Jar \u2728 Enhancements (2) Product Sync - Only cache the needed keys of Category , ProductType and Type references instead of caching all keys of such resources. #418 Note : This might have performance implications on the product sync, since now every non cached key-id entry will be individually fetched. However, issue #235 should address this. Commons - Refactor duplicate implementations in concrete services and generalise it in the BaseService . Thanks, @jarzynp, for the contributions! #418 \ud83d\udc1e Bug Fixes (1) Product Sync - Fixed a bug in the Product Sync where keys with special characters failed to be saved for CustomObject s, as the characters weren't allowed on the commmercetools platform. #474 Note : \ud83d\udea7 This is a breaking change. Previously stored custom objects representing product drafts with unresolved references, won't be synced with this version, since the key is now treated differently. Make sure to sync such drafts again with this version of the library. \ud83d\udee0\ufe0f Dependency Updates (5) org.ajoberstar.grgit 3.1.1 -> 4.0.1 org.ajoberstar.git-publish 2.1.1 -> 2.1.3 mockito-junit-jupiter 3.1.0 -> 3.2.4 commercetools-jvm-sdk 1.47.0 -> 1.48.0 org.assertj.assertj-core 3.13.2 -> 3.14.0 1.6.1 - Oct 17, 2019 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (3) Commons - Fixed a bug in the CtpQueryUtils which was overwriting the query input query for every page after the first page is fetched, eventually fetching more than needed. #463 Product Sync - Fixed a potential bug in reference resolution of attribute references in case a null reference is passed in an attribute draft of type Set of Reference . #441 ProductType Sync - Fixed a bug in the productType sync where the statistics failed counter was being counted on failed fetches of missing references. #426 \ud83d\udee0\ufe0f Dependency Updates (4) mockito-junit-jupiter 3.0.0 -> 3.1.0 com.adarshr.test-logger 1.7.1 -> 2.0.0 com.github.ben-manes.versions 0.25.0 -> 0.27.0 commercetools-jvm-sdk 1.46.0 -> 1.47.0 1.6.0 - Oct 10, 2019 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Product Sync - Introduced support for syncing products with other product references as attributes in any order. #447 \ud83d\udee0\ufe0f Dependency Updates (1) com.adarshr.test-logger 1.7.0 -> 1.7.1 #456 1.5.0 - Sept 13, 2019 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (4) Product Sync - Added support for resolving Product references on attributes of type Reference , Set of Reference , NestedType or Set of NestedType . #438 Product Sync - Added support for resolving Category references on attributes of type Reference , Set of Reference , NestedType or Set of NestedType . #440 Product Sync - Added support for resolving ProductType references on attributes of type Reference , Set of Reference , NestedType or Set of NestedType . #440 Commons - Exposed ResourceIdentifierUtils#isReferenceOfType utility which checks if a JSON representation of a CTP Reference object is of a certain typeId or not. #443 \ud83d\udea7 Breaking Changes (1) Product Sync - Unexposed the methods VariantReferenceResolver#resolveAttributeReferences and VariantReferenceResolver#resolveAttributeReference to be private as they are only meant for internal use of the library. #440 \ud83d\udee0\ufe0f Dependency Updates (5) Gradle 5.6.1 -> 5.6.2 org.junit.jupiter:junit-jupiter-api 5.5.1 -> 5.5.2 org.junit.jupiter:junit-jupiter-engine 5.5.1 -> 5.5.2 org.junit.jupiter:junit-jupiter-params 5.5.1 -> 5.5.2 com.github.ben-manes.versions 0.22.0 -> 0.25.0 1.4.1 - Sept 2, 2019 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Commons - Fixed a bug in the custom fields update actions builders which generated duplicated unnecessary update actions for null custom field values. This affected any sync module where the resource contained custom fields (i.e. Product Sync, Category Sync, CartDiscount Sync and Inventory Sync). It also affected any update actions building utility in which the resource/sub-resource contained custom fields. #428 \ud83d\udee0\ufe0f Enhancements (1) Commons - Bumped commercetools-jvm-sdk to version 1.46.0 which includes a fix for a serialization bug in the SetCustomField action which was ignoring empty array values. #430 1.4.0 - Aug 8, 2019 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (5) ProductType Sync - Introduced support for syncing product types with NestedType (or set of NestedType) attributes in any order. #372 ProductType Sync - Introduced the new ProductTypeReferenceReplacementUtils#replaceProductTypesReferenceIdsWithKeys which is a util that replaces the reference ids with keys in a list of productTypes. #372 ProductType Sync - Introduced the new ProductTypeReferenceReplacementUtils#buildProductTypeQuery utils to create a product type query with all needed reference expansions to fetch productTypes from a source CTP project for the sync. #372 ProductType Sync - Introduced the new ProductTypeReferenceResolver which resolves productType references on ProductTypeDrafts. #372 ProductType Sync - Introduced the new methods ProductTypeSyncStatistics#getNumberOfProductTypesWithMissingNestedProductTypes and ProductTypeSyncStatistics#getProductTypeKeysWithMissingParents which represents the nested product types which are still not resolved. #372 \ud83d\udee0\ufe0f Enhancements (8) Commons - Bumped commercetools-jvm-sdk to version 1.45.0 . Commons - Bumped gradle to version gradle-5.5.1 Commons - Bumped org.junit.jupiter:junit-jupiter-api to 5.5.1. Commons - Bumped org.junit.jupiter:junit-jupiter-engine to 5.5.1. Commons - Bumped org.junit.jupiter:junit-jupiter-params to 5.5.1. Commons - Bumped mockito-junit-jupiter dependency to 3.0.0. Commons - Bumped assertj to 3.13.2. Commons - Bumped com.github.ben-manes.versions to 0.22.0. 1.3.0 - Jul 3, 2019 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (6) CartDiscount Sync - Added support for syncing cart discounts. #379 For more info how to use it please refer to CartDiscount usage doc . CartDiscount Sync - Introduced the new CartDiscountSyncUtils#buildActions which calculates all needed update actions after comparing a CartDiscount and a CartDiscountDraft . #379 CartDiscount Sync - Introduced the new CartDiscountUpdateActionUtils which contains utils for calculating needed update actions after comparing individual fields of a CartDiscount and a CartDiscountDraft . #379 CartDiscount Sync - Introduced the new CartDiscountReferenceResolver which resolves custom type references on CartDiscountDrafts. #379 CartDiscount Sync - Introduced the new CartDiscountReferenceReplacementUtils#replaceCartDiscountsReferenceIdsWithKeys which is a util that replaces the custom type ids with keys in a list of cartDiscounts. #379 CartDiscount Sync - Introduced the new CartDiscountReferenceReplacementUtils#buildCartDiscountQuery util to create a cart discount query with all needed reference expansions to fetch cart discounts from a source CTP project for the sync. #379 . \ud83d\udc1e Bug Fixes (1) Commons - Fixed a bug in the BaseSyncStatistics which caused a wrong calculation of the latestBatchProcessingTimeInMinutes . #378 \ud83d\udee0\ufe0f Enhancements (6) CartDiscount Sync - Added benchmarks for the cartDiscount sync to be able to compare the performance of the sync with the future releases. #379 Commons - Bumped commercetools-jvm-sdk to version 1.44.0 . Commons - Bumped gradle to version gradle-5.5 Commons - Bumped org.junit.jupiter:junit-jupiter-api to 5.5.0. Commons - Bumped org.junit.jupiter:junit-jupiter-engine to 5.5.0. Commons - Bumped org.junit.jupiter:junit-jupiter-params to 5.5.0. 1.2.0 - Jun 14, 2019 \u00b6 Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (2) ProductType Sync - Removed the unneeded AttributeDefinitionCustomBuilder which was an exposed but internal helper. #377 . Commons - SyncUtils#replaceReferenceIdWithKey is now renamed to SyncUtils#getReferenceWithKeyReplaced . #394 \ud83c\udf89 New Features (2) Commons - Added the new CommonTypeUpdateActionUtils#buildUpdateActionForReferences which is used for comapring references/resourceIdentifiers and buiding an update action if needed. #394 Commons - Added the new SyncUtils#getResourceIdentifierWithKeyReplaced util. #394 \ud83d\udc1e Bug Fixes (1) Commons - Fixed a bug where references and resource identifiers were not being compared correctly. #394 \ud83d\udee0\ufe0f Enhancements (13) Commons - Bumped commercetools-jvm-sdk to version 1.43.0 . Commons - Bumped mockito to 2.27.0. Commons - Bumped assertj to 3.12.2. Commons - Bumped org.junit.jupiter:junit-jupiter-api to 5.4.2. Commons - Bumped org.junit.jupiter:junit-jupiter-engine to 5.4.2. Commons - Bumped org.junit.jupiter:junit-jupiter-params to 5.4.2. Commons - Bumped org.ajoberstar.git-publish to 2.1.1. Commons - Bumped org.ajoberstar.grgit to 3.1.1. Commons - Bumped com.github.ben-manes.versions to 0.21.0. Commons - Bumped gradle checkstyle plugin to 8.2. Commons - Bumped mockito dependency to 2.28.2. Commons - Bumped JaCoCo dependency to 0.8.4. Commons - Bumped gradle to version gradle-5.4.1 Commons - Bumped com.adarshr.test-logger to 1.7.0. 1.1.1 - Jan 16, 2019 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Product Sync - Fixed a bug in the product sync which would fail on syncing attributes of type Set that has an empty set as a value. 1.1.0 - Dec 19, 2018 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (4) Product Sync - Added support for syncing assets of newly added variants. #357 . Product Sync - ProductSyncUtils#buildActions and ProductUpdateActionUtils#buildVariantsUpdateActions now build AddAsset actions for every new asset on every new variant on the new ProductDraft . #357 . ProductType Sync - Added support for syncing changes to an AttributeDefinition with a SetType of a subtype LocalizableEnumType or EnumType #313 Type Sync - Added support for syncing changes to a FieldDefinition with a SetType of a subtype LocalizableEnumType or EnumType #313 \ud83d\udc1e Bug Fixes (3) ProductType Sync - Fixed a bug in the productType sync which would try to unset isSearchable , inputHint and attributeConstraint values to null instead of their default values. #354 ProductType Sync - ProductTypeSyncUtils#buildActions , ProductTypeUpdateActionUtils#buildAttributesUpdateActions now treat the values of the optional fields isSearchable , inputHint and attributeConstraint as ( true , SingleLine and None respectivley) if they are null or not passed. #354 Commons - Fixed a bug in the beforeUpdateCallback which caused the callback to be called even on an empty list of update actions. #359 \ud83d\udee0\ufe0f Enhancements (1) Commons - Benchmarks are now run once on every merge to master with a lower number of resources for faster benchmarking. #246 \ud83d\udccb Documentation (2) Commons - Added link to documentation pages in README of the github repo. Commons - Fixed link of beforeUpdateCallback for keeping other variants example in the Sync Options doc page. #360 1.0.0 - Dec 10, 2018 \u00b6 Commits | Javadoc | Jar The Beta is Over \ud83c\udf89 \u00b6 We're happy to announce that the commercetools-sync-java is finally out of beta! Big thanks to all the users who were using it when it was still in beta. Your feedback was definitely valuable for us to reach the current state of the library. 1.0.0 is here for you to use with all new features, enhancements and bug fixes including: The library now supports importing/syncing types into a CTP project from an external feed or another CTP project. Read more . The library now handles concurrency modification exceptions for the productType sync. All new documentation pages including a quick start guide . Many more improvements and bug fixes. Full Release Notes \u00b6 \ud83c\udf89 New Features (4) Type Sync - Added support for syncing types. #300 For more info how to use it please refer to Type usage doc . Type Sync - Exposed TypeSyncUtils#buildActions which calculates all needed update actions after comparing a Type and a TypeDraft . #300 Type Sync - Exposed TypeUpdateActionUtils which contains utils for calculating needed update actions after comparing individual fields of a Type and a TypeDraft . #300 Commons - Added OptionalUtils#filterEmptyOptionals which are utility methods that filter out the empty optionals in a supplied list (with a varargs variation) returning a list of the contents of the non-empty optionals. #255 \ud83d\udee0\ufe0f Enhancements (17) ProductType Sync - Added concurrency modification exception handling. #325 Commons - ProductSyncUtils#buildActions , CategorySyncUtils#buildActions , InventorySyncUtils#buildActions and ProductTypeSyncUtils#buildActions now don't apply the beforeUpdateCallback implicitly. If you want, you can apply it explicitly on the result of the ..#buildActions method. #302 Product Sync - Reference keys are not validated if they are in UUID format anymore. #166 Category Sync - Reference keys are not validated if they are in UUID format anymore. #166 Inventory Sync - Reference keys are not validated if they are in UUID format anymore. #166 ProductType Sync - Added benchmarks for the productType sync to be able to compare the performance of the sync with the future releases. #301 Commons - Bumped commercetools-jvm-sdk to version 1.37.0 . Commons - Bumped mockito to 2.23.4. Commons - Bumped com.adarshr.test-logger to 1.6.0. Commons - Bumped org.junit.jupiter:junit-jupiter-api to 5.3.2. Commons - Bumped org.junit.jupiter:junit-jupiter-engine to 5.3.2. Commons - Bumped org.junit.jupiter:junit-jupiter-params to 5.3.2. Commons - Bumped org.ajoberstar.git-publish to 2.0.0. Commons - Bumped org.ajoberstar.grgit to 3.0.0. Commons - Bumped gradle to version gradle-5.0 Type Sync - Added benchmarks for the type sync to be able to compare the performance of the sync with the future releases. #300 \ud83d\udea7 Breaking Changes (9) Product Sync - allowUuid option is now removed. #166 Category Sync - allowUuid option is now removed. #166 Inventory Sync - allowUuid option is now removed. #166 ProductType Sync - allowUuid option is now removed. #166 ProductType Sync - Renamed ProductTypeUpdateAttributeDefinitionActionUtils to AttributeDefinitionsUpdateActionUtils . It is also now meant to be only used internally by the library. Its behaviour is not guaranteed if used externally. #302 ProductType Sync - AttributeDefinitionUpdateActionUtils is now meant to be only used internally by the library. Its behaviour is not guaranteed if used externally. #302 ProductType Sync - EnumsUpdateActionUtils is now EnumValuesUpdateActionUtils and is meant to be only used internally by the library. Its behaviour is not guaranteed if used externally. #300 ProductType Sync - Utils that were in ProductTypeUpdateLocalizedEnumActionUtils and LocalizedEnumsUpdateActionUtils. are moved to LocalizedEnumValueUpdateActionUtils . #300 ProductType Sync - Utils that were in ProductTypeUpdatePlainEnumActionUtils and PlainEnumUpdateActionsUtils. are moved to PlainEnumValueUpdateActionUtils . #300 \ud83d\udc1e Bug Fixes (3) Product Sync - Fixed a bug that caused the statistics not to be updated correctly on fetch failure. #331 Category Sync - Fixed a bug that caused the statistics not to be updated correctly on fetch failure. #331 ProductType Sync - Fixed a bug that caused the sync process to continue after failed fetch. #331 \ud83d\udccb Documentation (4) Commons - Added the documentation github pages. https://commercetools.github.io/commercetools-sync-java Commons - Added a Quick Start Guide for a convenient entry into the library. Commons - Moved documentation of sync options to a separate doc . Commons - Added a the earliest compatible version of the commercetools-jvm-sdk]( https://github.com/commercetools/commercetools-jvm-sdk ) as a prerequisite for using the library. v1.0.0-M14 - Oct 5, 2018 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Product Sync - Fixed a bug where the removed attributes in the source product variant draft were not being removed from the target variant. #238 \ud83d\udee0 Enhancements (8) Product Sync - Products create and update requests are now issued in parallel. This should lead to a performance improvement. #238 Commons - Bumped com.adarshr.test-logger to 1.5.0. Commons - Bumped mockito to 2.22.0. Commons - Bumped org.junit.jupiter:junit-jupiter-api to 5.3.1. Commons - Bumped org.junit.jupiter:junit-jupiter-engine to 5.3.1. Commons - Bumped org.junit.jupiter:junit-jupiter-params to 5.3.1. Commons - UnorderedCollectionSyncUtils#buildRemoveUpdateActions ensures no null elements in the resulting list and ignores null` keys now. #238 Commons - Bumped gradle to version gradle-4.10.2 . \ud83d\udea7 Breaking Changes (2) Product Sync - AttributeMetaData#isRequired is now removed. #308 Product Sync - ProductVariantAttributeUpdateActionUtils#buildProductVariantAttributeUpdateAction now takes a map of all meta data instead of the specific metadata entry. #308 v1.0.0-M13 - Sept 5, 2018 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (15) ProductType Sync - Support for syncing productTypes. #286 For more info how to use it please refer to ProductType usage doc . Product Sync - Support for syncing product prices. #101 Product Sync - ProductSyncUtils#buildActions now also calculates variants' all price update actions needed. #101 Product Sync - ProductUpdateActionUtils#buildVariantsUpdateActions now also calculates variants' all price update actions needed. #101 Product Sync - Introduced new update action build utility for building all needed update actions between two variants' prices ProductVariantUpdateActionUtils#buildProductVariantPricesUpdateActions . #101 ProductSync - PriceReferenceResolver now resolves prices' CustomerGroup references on prices. #101 InventoryEntry Sync - InventoryReferenceReplacementUtils#replaceInventoriesReferenceIdsWithKeys now supports replacing channel reference ids with keys. #101 ProductType Sync - Exposed ProductTypeSyncUtils#buildActions which calculates all needed update actions after comparing a ProductType and a ProductTypeDraft . #286 ProductType Sync - Exposed ProductTypeUpdateActionUtils which contains utils for calculating needed update actions after comparing individual fields of a ProductType and a ProductTypeDraft . #286 ProductType Sync - Exposed ProductTypeUpdateAttributeDefinitionActionUtils which contains utils for calculating needed update actions after comparing a list of AttributeDefinition s and a list of AttributeDefinitionDraft s. #286 ProductType Sync - Exposed ProductTypeUpdateLocalizedEnumActionUtils which contains utils for calculating needed update actions after comparing two lists of LocalizedEnumValue s. #286 ProductType Sync - Exposed ProductTypeUpdatePlainEnumActionUtils which contains utils for calculating needed update actions after comparing two lists of EnumValue s. #286 ProductType Sync - Exposed AttributeDefinitionUpdateActionUtils which contains utils for calculating needed update actions after comparing an AttributeDefinition and an AttributeDefinitionDraft . #286 ProductType Sync - Exposed LocalizedEnumUpdateActionsUtils which contains utils for calculating needed update actions after comparing two LocalizedEnumValue s. #286 ProductType Sync - Exposed PlainEnumUpdateActionsUtils which contains utils for calculating needed update actions after comparing two EnumValue s. #286 \ud83d\udee0\ufe0f Enhancements (7) Commons - Bumped gradle to version gradle-4.10 . Commons - Bumped com.jfrog.bintray to 1.8.4. Commons - Bumped assertj to 3.11.1. Commons - Bumped mockito to 2.21.0. Commons - Bumped org.ajoberstar.grgit to 2.3.0. Commons - Bumped com.adarshr.test-logger to 1.4.0. Commons - Switched to Junit5 using both junit-jupiter-engine and junit-vintage-engine for backward compatibility. \ud83d\udee0\ufe0f Breaking Changes (3) Product Sync - Removed redundant ProductUpdateActionUtils#buildRemoveVariantUpdateActions . #3 Commons - Moved SyncUtils#replaceCustomTypeIdWithKeys to CustomTypeReferenceReplacementUtils#replaceCustomTypeIdWithKeys . #101 . Commons - Moved SyncUtils#replaceAssetsReferencesIdsWithKeys to AssetReferenceReplacementUtils#replaceAssetsReferencesIdsWithKeys . #101 . v1.0.0-M12 - Jun 05, 2018 \u00b6 Commits | Javadoc | Jar \ud83d\udee0\ufe0f Enhancements (13) Product Sync - Support for syncing price custom fields. #277 Product Sync - VariantReferenceResolver now resolves prices' custom type references on all variants. #277 Product Sync - ProductReferenceReplacementUtils#buildProductQuery now expands custom types on prices. #277 Product Sync - VariantReferenceReplacementUtils#replacePricesReferencesIdsWithKeys now supports replacing price custom reference ids with keys. #277 Commons - Bumped commercetools-jvm-sdk to version 1.32.0 . Commons - Bumped gradle to version gradle-4.8 . Commons - Bumped com.jfrog.bintray to 1.8.0. Commons - Bumped org.ajoberstar.git-publish to 1.0.0. Commons - Bumped com.adarshr.test-logger to 1.2.0. Commons - Bumped org.ajoberstar.grgit to 2.2.1. Commons - Bumped gradle checkstyle plugin to 8.10.1. Commons - Bumped mockito dependency to 2.18.3. Commons - Bumped JaCoCo dependency to 0.8.1. v1.0.0-M11 - Mar 08, 2018 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (19) Category Sync - Support of categories' asset syncing. #3 Product Sync - Support of product variants' asset syncing. #3 Category Sync - CategorySyncUtils#buildActions now also calculates all asset update actions needed. #3 Product Sync - ProductSyncUtils#buildActions now also calculates variants' all asset update actions needed. #3 Product Sync - ProductUpdateActionUtils#buildVariantsUpdateActions now also calculates variants' all asset update actions needed. #3 Product Sync - Introduced the new ActionGroup: ASSETS which can be used in blacklisting/whitelisting assets syncing during the product sync. #3 Category Sync - Introduced new update action build utility for building all needed update actions between two categories' assets ProductVariantUpdateActionUtils#buildProductVariantAssetsUpdateActions . #3 Product Sync - Introduced new update action build utility for building all needed update actions between two variants' assets ProductVariantUpdateActionUtils#buildProductVariantAssetsUpdateActions . #3 Category Sync - Introduced new update action granular build utils for category asset fields in CategoryAssetUpdateActionUtils . #3 Product Sync - Introduced new update action granular build utils for product variant assets fields in ProductVariantAssetUpdateActionUtils . #3 Commons - Introduced AssetReferenceResolver which is a helper that can resolve all the references of an AssetDraft. #3 Commons - VariantReferenceResolver and CategoryReferenceResolver now also resolve all the containing AssetDrafts references. #3 Commons - Support for custom update actions calculation for secondary resources (e.g. prices, product assets and category assets). #3 Product Sync - ProductReferenceReplacementUtils#replaceProductsReferenceIdsWithKeys and VariantReferenceReplacementUtils#replaceVariantsReferenceIdsWithKeys now support replacing asset custom reference ids with keys. #3 Category Sync - CategoryReferenceReplacementUtils#replaceCategoriesReferenceIdsWithKeys now supports replacing asset custom reference ids with keys. #3 Commons - Introduced new SyncUtils#replaceAssetsReferenceIdsWithKeys which is a util that replaces the custom type ids with keys in a list of assets. #3 Product Sync - ProductReferenceReplacementUtils#buildProductQuery now expands custom types on assets. #3 Category Sync - CategoryReferenceReplacementUtils#buildCategoryQuery now expands custom types on assets. #3 Commons - Introduced new ResourceIdentifierUtils#toResourceIdentifierIfNotNull . #262 Changes (5) Commons - CustomUpdateActionUtils#buildCustomUpdateActions is now CustomUpdateActionUtils#buildPrimaryResourceCustomUpdateActions . It now takes a new third parameter customActionBuilder which represents the concrete builder of custom update actions. For a list of concrete builder options check the implementors of the GenericCustomActionBuilder interface. #3 Commons - CustomUpdateActionUtils#buildCustomUpdateActions can now be used to build custom update actions for secondary resources (e.g. assets and prices). #3 Commons - New Custom Type Id is now validated against being empty/null. #3 Product Sync - ProductSyncUtils#buildCoreActions is now removed. ProductSyncUtils#buildActions should be used instead. #3 Category Sync - CategorySyncUtils#buildCoreActions is now removed. CategorySyncUtils#buildActions should be used instead. #3 \ud83d\udee0\ufe0f Enhancements (1) Build Tools - Bumped commercetools-jvm-sdk to version 1.30.0 . #262 \ud83d\udc1e Bug Fixes (1) Build Tools - Fixed bug where jar and Codecov were triggered on benchmark stages of the build when they should only be triggered on the full build. #249 v1.0.0-M10 - Feb 13, 2018 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Commons - Added benchmarking setup for the library on every release. #155 Changes (3) Commons - Statistics counters are now of type AtomicInteger instead of int to support concurrency. #242 Category Sync - categoryKeysWithMissingParents in the CategorySyncStatistics is now of type ConcurrentHashMap<String, Set<String> instead of Map<String, List<String> . #242 Category Sync - CategorySyncStatistics now exposes the methods removeChildCategoryKeyFromMissingParentsMap , getMissingParentKey and putMissingParentCategoryChildKey to support manipulating categoryKeysWithMissingParents map. #242 v1.0.0-M9 - Jan 22, 2018 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Commons - Added getSyncOptions to the ProductSync , CategorySync and InventorySync . #230 Changes (1) Product Sync - Added validation for product drafts' SKUs as a required field on the input product drafts since SKUs will be used for product matching in the future. #230 \ud83d\udee0\ufe0f Enhancements (1) Product Sync - Changed the product sync to cache product ids per batch as opposed to caching the entire products ids before syncing products. #230 \ud83d\udc1e Bug Fixes (1) Commons - Fixed library version in User-Agent headers of JVM SDK clients using the library. Now it is not fetched from the JAR manifest but injected by gradle-scripts/set-release-version.gradle. #227 v1.0.0-M8 - Dec 29, 2017 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Category Sync - Exposed new method CategorySyncStatistics#getNumberOfCategoriesWithMissingParents which gets the total number of categories with missing parents from the statistics instance. #186 Changes (2) Product Sync - Changed product sync statistics report message wording. #186 Product Sync - Exposed new methods ProductReferenceResolver#resolveStateReference , ProductReferenceResolver#resolveTaxCategoryReference , ProductReferenceResolver#resolveCategoryReferences and ProductReferenceResolver#resolveProductTypeReference . #218 \ud83d\udee0 Enhancements (1) Build Tools - Bumped Gradle to version 4.4. #205 v1.0.0-M7 - Dec 15, 2017 \u00b6 Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Commons - Changed offset-based pagination of querying all elements to a limit-based with sorted ids approach to mitigate problems of previous approach. #210 v1.0.0-M6 - Dec 5, 2017 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (3) Category Sync - Introduced beforeCreateCallback option which is callback applied on a category draft before a request to create it on CTP is issued. #183 Product Sync - Introduced beforeCreateCallback option which is callback applied on a product draft before a request to create it on CTP is issued. #183 Inventory Sync - Introduced beforeCreateCallback option which is callback applied on a inventoryEntry draft before a request to create it on CTP is issued. #183 \u2728 Major Enhancements (2) Category Sync - Introduced batching on update action requests to allow for requesting updates of more than 500 actions. #21 Product Sync - Introduced batching on update action requests to allow for requesting updates of more than 500 actions. #21 \ud83d\udc1e Bug Fixes (1) Commons - Fixed library version in User-Agent headers of JVM SDK clients using the library. #191 \ud83d\udccb Documentation (1) Commons - Added Code of Conduct doc. \ud83d\udea7 Migration guide (6) Product Sync - Removed removeOtherVariants option which is already done by the sync by default. Removal of variants can be prevented through the beforeUpdateCallback. Please check here an example of how this can be done. #26 Commons - Removed removeOtherSetEntries , removeOtherCollectionEntries and removeOtherProperties options which are already done by the sync by default. The aforementioned options (and even more use cases) can now be covered with help of the beforeCreateCallback and beforeUpdateCallback. Please check here an example of how removal of variants can be disabled. #26 Commons - Removed website and emergency contact e-mail appened in User-Agent headers of JVM SDK clients using the library. #191 Category Sync - beforeUpdateCallback now treats a null return as an empty list of update actions. #183 Product Sync - beforeUpdateCallback now treats a null return as an empty list of update actions. #183 Inventory Sync - beforeUpdateCallback now treats a null return as an empty list of update actions. #183 v1.0.0-M5 - Nov 16, 2017 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (3) Inventory Sync - Introduced beforeUpdateCallback which is applied after generation of update actions and before actual InventoryEntry update. #169 Build Tools - Added Add Release Notes entry checkbox in PR template on Github repo. #161 Commons - Appended library name and version to User-Agent headers of JVM SDK clients using the library. #142 \ud83d\udee0\ufe0f Enhancements (3) Commons - setUpdateActionsCallback has been renamed to beforeUpdateCallback and now takes a TriFunction instead of Function, which adds more information about the generated list of update actions, namely, the old resource being updated and the new resource draft. #169 Build Tools - Explicitly specified gradle tasks execution order in execution-order.gradle. #161 Build Tools - Set PMD to run before Integration tests. #161 Commons - Appended library name and version to User-Agent headers of JVM SDK clients using the library. #142 \ud83d\udccb Documentation (1) Build Tools - Added Snyk vulnerabilities badge to repo README. #188 \ud83d\udea7 Migration guide (8) Commons - Renamed setUpdateActionsCallback to beforeUpdateCallback . #169 Commons - Renamed setAllowUuid to allowUuid . #169 Commons - Renamed setWarningCallBack to warningCallback . #169 Commons - Renamed setErrorCallBack to errorCallback . #169 Commons - Renamed setBatchSize to batchSize . #169 Commons - Removed setRemoveOtherLocales option. #169 Commons - Renamed setRemoveOtherSetEntries , setRemoveOtherCollectionEntries and setRemoveOtherProperties to removeOtherSetEntries , removeOtherCollectionEntries and removeOtherProperties . #169 Product Sync - Renamed setSyncFilter to syncFilter . #169 v1.0.0-M4 - Nov 7, 2017 \u00b6 Commits | Javadoc | Jar \ud83d\udd25 Hotfix (1) Product Sync - Fixed an issue with replaceAttributesReferencesIdsWithKeys which nullifies localized text attributes due to JSON parsing not throwing exception on parsing it to reference set. #179 v1.0.0-M3 - Nov 3, 2017 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (7) ProductSync - Introduced Product TaxCategory reference resolution and syncing. #120 . ProductSync - Introduced Product State reference resolution and syncing. #120 . ProductSync - Exposed ProductReferenceReplacementUtils#buildProductQuery util to create a product query with all needed reference expansions to fetch products from a source CTP project for the sync. #120 . ProductSync - Exposed VariantReferenceReplacementUtils#replaceVariantsReferenceIdsWithKeys which provides utils to replace reference ids with keys on variants (price and attriute references) coming from a source CTP project to make it ready for reference resolution. #160 . ProductSync - Exposed VariantReferenceResolver which is a helper that resolves the price and attribute references on a ProductVariantDraft. (Note: This is used now by the already existing ProductReferenceResolver) #160 . CategorySync - Exposed CategoryReferenceReplacementUtils#buildCategoryQuery util to create a category query with all needed reference expansions to fetch categories from a source CTP project for the sync. #120 . Commons - Exposed replaceCustomTypeIdWithKeys and replaceReferenceIdWithKey . #120 . \ud83d\udc1e Bug Fixes (1) Category Sync - Fixes an issue where retrying on concurrent modification exception wasn't re-fetching the latest Category and rebuilding build update actions. #94 \ud83d\udccb Documentation (6) Product Sync - Documented the reason behind having the latest batch processing time. #119 Category Sync - Documented the reason behind having the latest batch processing time. #119 Category Sync - Fixed the statistics summary string used in the documentation. #119 Inventory Sync - Documented the reason behind having the latest batch processing time. #119 Product Sync - Fixed some typos. #172 Commons - Provided inline example of how to use logging in callbacks. #172 \ud83d\udea7 Migration guide (9) Product Sync - Moved replaceProductsReferenceIdsWithKeys from SyncUtils to ProductReferenceReplacementUtils . #120 Product Sync - Removed replaceProductDraftsCategoryReferenceIdsWithKeys which is not needed anymore. #120 Product Sync - Removed replaceProductDraftCategoryReferenceIdsWithKeys which is not needed anymore. #120 Product Sync - Removed replaceCategoryOrderHintCategoryIdsWithKeys which is not needed anymore. #120 Product Sync - Moved getDraftBuilderFromStagedProduct from SyncUtils to ProductReferenceReplacementUtils . #120 Category Sync - Moved replaceCategoriesReferenceIdsWithKeys from SyncUtils to CategoryReferenceReplacementUtils . #120 Inventory Sync - Moved replaceInventoriesReferenceIdsWithKeys from SyncUtils to InventoryReferenceReplacementUtils . #120 Commons - Removed slf4j-simple dependency. #172 Commons - Used implementation instead of compile configuration for dependencies. #172 v1.0.0-M2 - Oct 12, 2017 \u00b6 Commits | Javadoc | Jar - \ud83c\udf89 New Features (3) - Product Sync - Supported syncing entire product variant images, putting order into consideration. #114 - Product Sync - Exposed ProductVariantUpdateActionUtils#buildProductVariantImagesUpdateActions and ProductVariantUpdateActionUtils#buildMoveImageToPositionUpdateActions action build util. #114 - Product Sync - Supported Blacklisting/Whitelisting update action groups on sync. #122 \ud83d\udc1e Bug Fixes (4) Build Tools - Fixed issue were JavaDoc jar was not built. #117 Build Tools - Fixed issue were JavaDoc was not published on github. #118 Product Sync - Fixed a potential bug where an exisitng master variant key could be blank. #122 Product Sync - Fixed a potential bug where a product draft could be provided with no master variant set. #122 \ud83d\udee0 Enhancements (2)\ufe0f Build Tools - Integration tests project credentials can now be set on a properties file not only as environment variables and give error messages if not set. #105 Product Sync - Validated the SKU before making a ChangeMasterVariant request by SKU. #122 \ud83d\udccb Documentation (5) Build Tools - Added bintray badge to repo. #126 Product Sync - Added usage documentation. #121 Commons - Separated contributing README into own README not in the main one. #121 Commons - Added release notes doc. #125 Build Tools - Added JavaDoc badge to repo. #145 v1.0.0-M2-beta - Sep 28, 2017 \u00b6 Commits | Jar Beta Features (11) Product Sync - Introduced syncing products name, categories, categoryOrderHints, description, slug, metaTitle, metaDescription, metaKeywords, masterVariant and searchKeywords. #57 Product Sync - Exposed update action build utils for products name, categories, categoryOrderHints, description, slug, metaTitle, metaDescription, metaKeywords, masterVariant and searchKeywords. #57 Product Sync - Introduced reference resolution support for product categories, productType and prices. #95 #96 Product Sync - Introduced syncing products publish state. #97 Product Sync - Exposed update action build utils for products publish state. #97 Product Sync - Introduced syncing products variant attributes. #98 Product Sync - Exposed update action build utils for products variant attributes. #98 Product Sync - Introduced syncing products variant prices without update action calculation. #99 Product Sync - Introduced syncing products variant images. #100 Product Sync - Exposed update action build utils for products variant images. #100 Product Sync - Introduced syncing products against staged projection. #93 v1.0.0-M1 - Sep 06, 2017 \u00b6 Commits | Javadoc | Jar \ud83c\udf89 New Features (16) Category Sync - Introduced syncing category name, description, orderHint, metaDescription, metaTitle, customFields and parent category. #2 Category Sync - Exposed update action build utils for category name, description, orderHint, metaDescription, metaTitle, customFields and parent category. #2 Category Sync - Introduced sync options builders. #5 Category Sync - Introduced support of syncing categories in any order. #28 Category Sync - Added concurrency modification exception repeater. #30 Category Sync - Used category keys for matching. #45 Category Sync - Introduced reference resolution support. #47 Category Sync - Introduced Batch processing support. #73 Category Sync - Added info about missing parent categories in statistics. #73 Commons - Introduced sync statistics support. #6 Commons - Sync ITs should now use client that repeats on 5xx errors. #31 Commons - Sync only accepts drafts. #46 Build Tools - Travis setup as CI tool. #1 Build Tools - Setup Bintray release and publising process. #24 Build Tools - Setup CheckStyle, PMD, FindBugs, Jacoco and CodeCov. #25 Build Tools - Setup repo PR and issue templates. #29 Beta Features (5) Inventory Sync - Introduced syncing inventory supplyChannel, quantityOnStock, restockableInDays, expectedDelivery and customFields. #17 Inventory Sync - Exposed update action build utils for inventory supplyChannel, quantityOnStock, restockableInDays, expectedDelivery and customFields. #17 Inventory Sync - Introduced sync options builder support. #15 Inventory Sync - Introduced reference resolution support. #47 Inventory Sync - Introduced batch processing support. #73","title":"Release notes"},{"location":"RELEASE_NOTES/#release-notes","text":"","title":"Release Notes"},{"location":"RELEASE_NOTES/#1005-feb-8-2024","text":"Commits | Javadoc | Jar - \ud83d\udc1e Bug Fixes (1) - Fix images not being returned by variant resolution utils ( https://github.com/commercetools/commercetools-project-sync/issues/555 )","title":"10.0.5 - Feb 8, 2024"},{"location":"RELEASE_NOTES/#1004-jan-9-2024","text":"Commits | Javadoc | Jar - \ud83d\udc1e Bug Fixes (1) - Fix getting a wrong JSON Object mapper ( https://github.com/commercetools/commercetools-sync-java/issues/1138 )","title":"10.0.4 - Jan 9, 2024"},{"location":"RELEASE_NOTES/#1003-dec-21-2023","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Fix NullPointerException for products having a category but no category order hints ( https://github.com/commercetools/commercetools-sync-java/pull/1134 )","title":"10.0.3 - Dec 21, 2023"},{"location":"RELEASE_NOTES/#1002-dec-05-2023","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (4) Product Sync - Sync now supports syncing of products with attributes referencing themselves. #478 State Sync - Fix NPE thrown by StateDraftBuilder.build() when required fields are missing. The StateTransformUtils.toStateDrafts utility returns an empty draft when key is null or empty. Inventory Sync - Fix NPE thrown by InventoryEntryDraftBuilder.build() when required fields are missing. The InventoryTransformUtils.toInventoryEntryDrafts utility returns an empty draft when sku is null or empty. ProductType Sync - Fix ReferenceResolution of product-type attributes to avoid sync errors.","title":"10.0.2 - Dec 05, 2023"},{"location":"RELEASE_NOTES/#1001-nov-14-2023","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug fixes (1) Make commercetools-sdk-java-v2 available as a transitive dependency","title":"10.0.1 - Nov 14, 2023"},{"location":"RELEASE_NOTES/#1000-nov-6-2023","text":"Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) commercetools-sync-java is now fully migrated to commercetools-sdk-java-v2 . See Migration Guide on how to use this library version.","title":"10.0.0 - Nov 6, 2023"},{"location":"RELEASE_NOTES/#923-mar-21-2023","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes Fix the problem when switching master variants #918","title":"9.2.3 - Mar 21, 2023"},{"location":"RELEASE_NOTES/#921-feb-10-2023","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes Fix rich type reference issue in product type #893 \ud83d\udee0\ufe0f Dependency Updates Migrated com.commercetools.sdk.jvm.core to 2.12.0","title":"9.2.1 - Feb 10, 2023"},{"location":"RELEASE_NOTES/#920-dec-06-2022","text":"Commits | Javadoc | Jar - \u2728 Enhancements (2) - Display Github tag instead of Github commit hash in Benchmarks chart #867 - Run Bechmarks test in every commit #868 To help developers to review the performance change before creating new release, benchmarks test now executes not only during making new release, but also pushing new commit in branches. The test result of commit is displayed in the build in Github Action. It shows whether benchmarks of current commit over the pre-defined threshold, while the benchmarks chart keeps displaying the test result of each library version. \ud83d\udc1e Bug Fixes Fix NPE in ProductSync benchmarks test for SDK-v2 #874 \ud83d\udee0\ufe0f Dependency Updates Migrated com.commercetools.sdk from 9.4.0 to 9.5.0 Migrated com.github.ben-manes.caffeine 3.1.1 to 3.1.2 Migrated com.github.ben-manes.versions 0.43.0 -> 0.44.0 Migrated ru.vyarus.mkdocs 2.4.0 -> 3.0.0","title":"9.2.0 - Dec 06, 2022"},{"location":"RELEASE_NOTES/#910-nov-02-2022","text":"Commits | Javadoc | Jar - \u2728 Enhancement (1) - Java SDK-v2 Compatible layer adaption #859 Commercetools has already developed [next generation Java SDK (Java-SDK-v2)](https://github.com/commercetools/commercetools-sdk-java-v2) for communication between client-side and the platform. As it provides a compatible layer which ease the migration work, we now provide alternative methods in [ClientConfigurationUtils](https://github.com/commercetools/commercetools-sync-java/blob/master/src/main/java/com/commercetools/sync/commons/utils/ClientConfigurationUtils.java) for client creation purpose. Meanwhile the original methods keep unchanged and support client creation with [existing JAVA SDK](https://github.com/commercetools/commercetools-jvm-sdk). For details how to create client from Java-SDK-v2, please refer to [Important Usage Tips](https://github.com/commercetools/commercetools-sync-java/blob/master/docs/usage/IMPORTANT_USAGE_TIPS.md) \ud83d\udee0\ufe0f Dependency Updates Added com.commercetools.sdk 9.4.0 Migrated com.diffplug.spotless plugin from 6.9.1 to 6.11.0 . Migrated com.github.ben-manes.versions 0.42.0 -> 0.43.0 Migrated com.github.spotbugs 5.0.12 -> 5.0.13 Migrated commercetools-jvm-sdk -> 2.9.0 Migrated org.apache.commons:common-text 1.9 -> 1.10 Migrated org.mockito:mockito-junit-jupiter 4.7.0 -> 4.8.1","title":"9.1.0 - Nov 02, 2022"},{"location":"RELEASE_NOTES/#903-sep-22-2022","text":"Commits | Javadoc | Jar - \ud83d\udc1e Bug Fixes - Fix broken link in the github.io documentation #853","title":"9.0.3 - Sep 22, 2022"},{"location":"RELEASE_NOTES/#902-sep-21-2022","text":"Commits | Javadoc | Jar - \ud83d\udc1e Bug Fixes - Add correct resources to the error callbacks #850","title":"9.0.2 - Sep 21, 2022"},{"location":"RELEASE_NOTES/#901-aug-13-2022","text":"Commits | Javadoc | Jar - \ud83d\udc1e Bug Fixes - Fix broken links in the github.io documentation #843 - \ud83d\udee0\ufe0f Dependency Updates - org.ajoberstar.git-publish 4.1.0 -> 4.1.1 - org.mockito:mockito-junit-jupiter 4.6.1 -> 4.7.0 - com.diffplug.spotless 6.9.0 -> 6.9.1","title":"9.0.1 - Aug 13, 2022"},{"location":"RELEASE_NOTES/#900-aug-8-2022","text":"Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) Minimum Java 11 or above is required #840 \u2728 Build Tools Migrated org.ajoberstar.grgit plugin from 4.1.1 to 5.0.0 . Migrated org.ajoberstar.git-publish plugin from 3.0.1 to 4.1.0 . \ud83d\udee0\ufe0f Dependency Updates commercetools-jvm-sdk 2.6.0 -> 2.9.0 caffeineVersion 2.9.3 -> 3.1.1","title":"9.0.0 - Aug 8, 2022"},{"location":"RELEASE_NOTES/#811-mar-21-2022","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Product Sync - Fixed the AddToCategory , RemoveFromCategory action, which creates unnecessary update action when there is no difference and it leads to error. #816 \u2728 Enhancement (1) Resolve warnings and deprecated usages. #808 \u2728 Build Tools Migrated from gradle v7.3.1 to v7.3.3 . Migrated github actions setup-java plugin from v2 to v3 \ud83d\udee0\ufe0f Dependency Updates commercetools-jvm-sdk 2.5.0 -> 2.6.0 com.github.spotbugs 5.0.2 -> 5.0.5 com.diffplug.spotless 6.0.4 -> 6.2.0 mockito-junit-jupiter 4.1.0 -> 4.3.1 org.assertj.assertj-core 3.21.0 -> 3.22.0","title":"8.1.1 - Mar 21, 2022"},{"location":"RELEASE_NOTES/#810-dec-14-2021","text":"Commits | Javadoc | Jar \u2728 Build Tools Migrated from gradle v6.8.2 to v7.3.1 . Migrated github actions setup-java plugin from v1 to v2 Migrated github actions codecov-action plugin from v1 to v2 \ud83d\udee0\ufe0f Dependency Updates commercetools-jvm-sdk 1.64.0 -> 2.5.0 com.adarshr.test-logger 3.0.0 -> 3.1.0 ru.vyarus.mkdocs 2.1.2 -> 2.2.0 org.ajoberstar.grgit 4.1.0 -> 4.1.1 com.github.spotbugs 4.7.1 -> 5.0.2 com.diffplug.spotless 5.14.2 -> 6.0.4 mockito-junit-jupiter 3.11.2 -> 4.1.0 org.junit.jupiter:junit-jupiter-api 5.7.2 -> 5.8.2 org.junit.jupiter:junit-jupiter-engine 5.7.2 -> 5.8.2 org.junit.jupiter:junit-jupiter-params 5.7.2 -> 5.8.2 org.assertj.assertj-core 3.20.2 -> 3.21.0 com.github.ben-manes.caffeine 2.9.2 -> 2.9.3 (new) org.apache.commons:common-text 1.9","title":"8.1.0 - Dec 14, 2021"},{"location":"RELEASE_NOTES/#800-oct-1-2021","text":"Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) Removed support of changing the attribute definition type #787 since removal and addition of the attribute with the same name in a single request is not possible by commercetools API anymore. For more information please check . \u2728 Enhancement (1) Use the new concurrency keyword on github actions to limit the concurrency of the workflow runs. #772","title":"8.0.0 - Oct 1, 2021"},{"location":"RELEASE_NOTES/#702-sep-21-2021","text":"Commits | Javadoc | Jar \u2728 Enhancement (1) Dependency management - Migrate Dependabot to Renovate. #767 \u2728 Documentation (1) - Update docs and Release notes about the usage of JVM-SDK dependencies. #766","title":"7.0.2 - Sep 21, 2021"},{"location":"RELEASE_NOTES/#701-sep-15-2021","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) State Sync - State to sync correctly from source to target when no transitions configured. #763","title":"7.0.1 - Sep 15, 2021"},{"location":"RELEASE_NOTES/#700-aug-24-2021","text":"Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) Dependency management: To avoid commercetools JVM SDK libraries version mismatch between projects. It is better not to add commercetools JVM SDK dependencies explicitly into your project and use them from commercetools-Sync-Java dependencies instead. Check README.md for more details. \u2728 Documentation (1) - Usage documentation on main readme improved, obsolete links is removed. #758","title":"7.0.0 - Aug 24, 2021"},{"location":"RELEASE_NOTES/#600-jul-19-2021","text":"Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) Inventory Sync : InventoryService.fetchInventoryEntriesBySkus(Set<String> skus) is renamed to InventoryService.fetchInventoryEntriesByIdentifiers(Set<InventoryEntryIdentifier> inventoryEntryIdentifiers) . #757 \ud83d\udc1e Bug Fixes (1) Inventory Sync - Fixed the DuplicateField bug in the InventorySync related to fetching and syncing inventories with multiple channels. #757","title":"6.0.0 - Jul 19, 2021"},{"location":"RELEASE_NOTES/#513-jul-8-2021","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) TaxCategory Sync - TaxCategories to sync properly when we have many TaxRates with different states. \u2728 Enhancements (1) Product Sync - After a fix from JVM-SDK(1.64.0), ProductProjection search uses built in predicate to filter resources by the key to avoid issues like #269 . \ud83d\udee0\ufe0f Dependency Updates (5) commercetools-jvm-sdk 1.63.0 -> 1.64.0 assertjVersion 3.19.0 -> 3.20.2 caffeineVersion 2.9.1 -> 2.9.2 mockitoJunitJupiterVersion 3.10.0 -> 3.11.2 com.diffplug.spotless 5.12.5 -> 5.14.0","title":"5.1.3 - Jul 8, 2021"},{"location":"RELEASE_NOTES/#512-may-31-2021","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Product Sync - The user is now aware of unresolvable references as the transform service will not skip the products. \ud83d\udee0\ufe0f Dependency Updates (3) com.github.ben-manes.versions 0.38.0 -> 0.39.0 caffeineVersion 2.8.5 -> 2.9.1 netty-codec-http 4.1.64.Final -> 4.1.65.Final","title":"5.1.2 - May 31, 2021"},{"location":"RELEASE_NOTES/#511-may-18-2021","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (2) Product Sync - Special characters can be defined for ProductDraft key. #269 Product Sync - After a fix from JVM-SDK(1.63.0), Added integration tests to make sure PriceTiers are synched successfully. #271 \ud83d\udee0\ufe0f Dependency Updates (7) commercetools-jvm-sdk 1.62.0 -> 1.63.0 io.codearte.nexus-staging 0.30.0 -> io.github.gradle-nexus.publish-plugin 1.11.0 (Adapt new gradle plugin for artifact publishing) com.github.spotbugs 4.7.0 -> 4.7.1 com.diffplug.spotless 5.12.1 -> 5.12.5 org.mockito:mockito-junit-jupiter 3.9.0 -> 3.10.0 org.junit.jupiter 5.7.0 -> 5.7.2 netty-codec-http 4.1.63.Final -> 4.1.64.Final Build Tools (1) - Change build script and cd.yml for new gradle publish plugin.","title":"5.1.1 - May 18, 2021"},{"location":"RELEASE_NOTES/#510-apr-20-2021","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Syncing product types with an attribute of type Set of (Set of Set of..) of NestedType attribute is supported. #720","title":"5.1.0 - Apr 20, 2021"},{"location":"RELEASE_NOTES/#500-apr-12-2021","text":"Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (2) For mapping a resource (Product, Category, CartDiscount, ShoppingList, State, InventoryEntry, ProductType, Customer) to resourceDraft the new util method should be called. Example for Product Sync : For mapping from Product to ProductDraft the util method ProductTransformUtils.toProductDrafts should be called along with sphereClient , cache implementation( ReferenceIdToKeyCache ) and productTypes parameters. Product Sync : The productProjections endpoint is used instead of products endpoint to improve the performance of the product Sync . Changes: The callbacks of the product Sync will now work with productProjections instead of products The update action ( buildCustomUpdateActions , buildAssetsUpdateActions , buildAssetActions ) doesn't require the \"old Resource\" as parameter anymore. All update actions of products now working with ProductProjections instead of Products The method syncFrenchDataOnly has a new signature public static List<UpdateAction<Product>> syncFrenchDataOnly(@Nonnull final List<UpdateAction<Product>> updateActions, @Nonnull final ProductDraft newProductDraft, @Nonnull final ProductProjection oldProduct) The method keepOtherVariants has a new signature List<UpdateAction<Product>> keepOtherVariants( @Nonnull final List<UpdateAction<Product>> updateActions) The method mapToProductDrafts has a new signature public static List<ProductDraft> mapToProductDrafts(Nonnull final List<ProductProjection> products) The method getDraftBuilderFromStagedProduct has a new signature public static ProductDraftBuildergetDraft BuilderFromStagedProduct(@Nonnull final ProductProjection product) The method buildProductQuery has a new signature public static ProductProjectionQuery buildProductQuery() The method buildCategoryActions has a new signature public static List<UpdateAction<Product>> buildCategoryActions(@Nonnull final ProductProjection oldProduct, @Nonnull final ProductDraft newProduct) The class BaseSyncOptions has a new generics <A> , which indicate the resource type to update The class BaseSyncOptionsBuilder has a new generics <A> , which indicate the resource type to update \u2728 Enhancements (2) To improve performance of the library, We are not expanding any references in the query for the resources, Instead library fetches key-id pairs and stores in a cache to reuse them. Example for ProductSync: The util class method ProductTransformUtils.toProductDrafts will fetch key-id pairs and stores in a cache. This cache has been used to build the productDraft by resolving references. For detailed documentation refer - syncing-from-a-commercetools-project Product Sync Use the new addVariant which supports the adding assets of the new variant. #714 Support synchronization of state and customer references in product variant attributes. #715 \ud83d\udee0\ufe0f Dependency Updates (1) commercetools-jvm-sdk 1.60.0 -> 1.62.0","title":"5.0.0 - Apr 12, 2021"},{"location":"RELEASE_NOTES/#401-mar-19-2021","text":"Commits | Javadoc | Jar \u2728 Enhancements (1) To avoid 414 request-URI too large error, the services are using chunking on the input list(keys or sku's) to chunk the input considering the length of the request URI and execute the query for these chunks. \u2728 Build Tools (1) Migrated from gradle v5.6.2 to v6.8.2 . \ud83d\udee0\ufe0f Dependency Updates (1) Updated the following transitive dependencies to avoid vulnerability issues of previous versions: com.fasterxml.jackson.dataformat:jackson-dataformat-cbor -> Fixed vulnerability issue for DoS attacks io.netty:netty-codec-http -> Fixed vulnerability issue for Information Disclosure org.apache.httpcomponents:httpclient -> Fixed vulnerability issue for Improper Input Validation commons-codec:commons-codec -> Fixed vulnerability issue for Information Exposure","title":"4.0.1 - Mar 19, 2021"},{"location":"RELEASE_NOTES/#400-feb-26-2021","text":"Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) Product Sync : PriceDraft.getCustomerGroup() is changed from Reference<CustomerGroup> to ResourceIdentifier<CustomerGroup> , so as a library user you don't need to provide a key field in the id field of the Reference. (Now API and JVM SDK support ResourceIdentifiers and it supports id or key as a field). #676 \u2728 Enhancements (1) Refactored CategorySync to make it consistent with other Sync types (e.g ProductSync). #681 \ud83d\udee0\ufe0f Dependency Updates (2) commercetools-jvm-sdk 1.57.0 -> 1.60.0 commercetools-java-client -> commercetools-java-client-ahc-2_5 -> Upgraded the default http client to avoid \"Runtime Access Warnings\" because of out of date netty dependencies on jvm-sdk. Note: commercetools-java-client-ahc-2_5 dependency uses async-http-client version 2.5.4 \u2728 Build Tools (1) Migrating from JCenter / Bintray to The Maven Central Repository. Additionally, automate the staging process from OSSRH from maven central . #667","title":"4.0.0 - Feb 26, 2021"},{"location":"RELEASE_NOTES/#320-feb-3-2021","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Now the categories, which have an unresolvable parent category, are persisted in custom objects, so they can be resolved in different executions / instances of the category sync. #658 \ud83d\udc1e Bug Fixes (1) To avoid Error 413 (Request Entity Too Large) issues, a fix added to unresolved reference custom object fetching. #666 \ud83d\udee0\ufe0f Dependency Updates (1) commercetools-jvm-sdk 1.56.0 -> 1.57.0 \u2728 Build Tools (1) Migrate to github actions from travis-ci #664","title":"3.2.0 - Feb 3, 2021"},{"location":"RELEASE_NOTES/#310-jan-13-2021","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Added clean up implementation for the outdated pending reference resolution custom objects. #650 \u2728 Enhancements (1) Added a graphQL pagination utility. #627 \u2728 Documentation (1) Documentation added for the cleaning up of the unresolved references, check the cleanup guide for more details.","title":"3.1.0 - Jan 13, 2021"},{"location":"RELEASE_NOTES/#302-dec-16-2020","text":"Commits | Javadoc | Jar \u2728 Documentation (2) Documentation for the cacheSize sync option is added. Prerequisites section of the documentations are clarified and added more code snippets as usage examples. \ud83d\udee0\ufe0f Dependency Updates (1) commercetools-jvm-sdk 1.55.0 -> 1.56.0","title":"3.0.2 - Dec 16, 2020"},{"location":"RELEASE_NOTES/#301-nov-24-2020","text":"Commits | Javadoc | Jar \u2728 Enhancements (1) To improve performance of the library, the services are using graphQL API to fetch resource ids only; also the keyToId caches evict entries which haven't been used for the longest amount of time beyond a maximum size. The cache size is configurable in the sync options. #582 \ud83d\udee0\ufe0f Dependency Updates (2) commercetools-jvm-sdk 1.54.0 -> 1.55.0 (new) com.github.ben-manes.caffeine 2.8.5","title":"3.0.1 - Nov 24, 2020"},{"location":"RELEASE_NOTES/#300-nov-18-2020","text":"Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (1) Product Sync : ProductDraft.getState() is changed from Reference<State> to ResourceIdentifier<State> , so as a library user you don't need to provide a key field in the id field of the Reference. (Now API and JVM SDK support ResourceIdentifiers and it supports id or key as a field). #589 \ud83d\udc1e Bug Fixes (1) Commons - Fixed a bug in the duration calculation of decorated retry sphere client RetrySphereClientDecorator created by ClientConfigurationUtils . #610 \ud83c\udf89 New Features (4) ShoppingList Sync - Added support for syncing shopping lists between ctp projects. #594 ShoppingList Sync - Introduced ShoppingListSyncUtils which calculates all needed update actions after comparing a ShoppingList and a ShoppingListDraft . #594 ShoppingList Sync - Introduced ShoppingListUpdateActionUtils which contains utils for calculating necessary update actions after comparing individual fields of a ShoppingList and a ShoppingListDraft . #594 ShoppingList Sync - Introduced ShoppingListReferenceResolutionUtils which resolves Type references from a ShoppingList to a ShoppingListDraft. #594 \ud83d\udee0\ufe0f Dependency Updates (1) commercetools-jvm-sdk 1.53.0 -> 1.54.0 mockito-junit-jupiter 3.5.13 -> 3.6.0 org.assertj.assertj-core 3.17.2 -> 3.18.1","title":"3.0.0 - Nov 18, 2020"},{"location":"RELEASE_NOTES/#230-oct-15-2020","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (4) Customer Sync - Added support for syncing customers between ctp projects. #579 Customer Sync - Introduced CustomerSyncUtils which calculates all needed update actions after comparing a Customer and a CustomerDraft . #579 Customer Sync - Introduced CustomerUpdateActionUtils which contains utils for calculating needed update actions after comparing individual fields of a Customer and a CustomerDraft . #579 Customer Sync - Introduced CustomerReferenceResolutionUtils which resolves CustomerGroup and Type references from a Customer to a CustomerDraft. #579","title":"2.3.0 - Oct 15, 2020"},{"location":"RELEASE_NOTES/#221-sep-29-2020","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Product Sync - Fixed a bug in the ProductSync related handling of unresolved product references provided in different batches. #580","title":"2.2.1 - Sep 29, 2020"},{"location":"RELEASE_NOTES/#220-sep-25-2020","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (2) Product Sync - Added support for resolving key-value-document (custom object) references on attributes of type Reference , Set of Reference , NestedType or Set of NestedType . #564 Introduced new concept for the validation of the drafts in batches for each Sync instance, exposed with BaseBatchValidator implementations (i.e. ProductBatchValidator, CategoryBatchValidator). #233 \u2728 Enhancements (2) Category Sync - Passed category keys in batch to cacheKeysToIds method of CategoryService to avoid fetching all categories for every batch. #235 Populated keyToId caches in services before reference resolution to improve the performance of the library with collecting referenced keys in batches of drafts. #235 \ud83d\udee0\ufe0f Dependency Updates (1) mockito-junit-jupiter 3.5.11 -> 3.5.13","title":"2.2.0 - Sep 25, 2020"},{"location":"RELEASE_NOTES/#210-sep-21-2020","text":"Commits | Javadoc | Jar - \ud83c\udf89 New Features (2) - CustomObject Sync - Added support for syncing custom objects between ctp projects. #565 For more info how to use it please refer to CustomObject usage doc . - CustomObject Sync - Exposed CustomObjectSyncUtils#hasIdenticalValue which determines whether update process is required after comparing a CustomObject and a CustomObjectDraft . #565 \ud83d\udee0\ufe0f Dependency Updates (3) org.ajoberstar.git-publish 2.1.3 -> 3.0.0 org.ajoberstar.grgit 4.0.2 -> 4.1.0 mockito-junit-jupiter 3.5.10 -> 3.5.11","title":"2.1.0 - Sep 21, 2020"},{"location":"RELEASE_NOTES/#200-sept-14-2020","text":"Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (2) Sync options: The signatures of the errorCallback and warningCallback changed and their parameter lists are extended. From now on the resource draft of the source project, the resource of the target project and optionally the failed update actions passed to the callbacks. Refer sync options for more details. #107 Reference resolution utilities: Commons - Renamed replaceCustomTypeIdWithKeys to mapToCustomFieldsDraft . #138 Commons - Renamed replaceAssetsReferencesIdsWithKeys to mapToAssetDrafts . #138 Category Sync - Renamed replaceCategoriesReferenceIdsWithKeys to mapToCategoryDrafts . #138 CartDiscount Sync - Renamed replaceCartDiscountsReferenceIdsWithKeys to mapToCartDiscountDrafts . #138 Inventory Sync - Renamed replaceInventoriesReferenceIdsWithKeys to mapToInventoryEntryDrafts . #138 Product Sync - Renamed replaceProductsReferenceIdsWithKeys to mapToProductDrafts . #138 State Sync - Renamed replaceStateReferenceIdsWithKeys to mapToStateDrafts . #138 ProductType Sync - Renamed replaceProductTypesReferenceIdsWithKeys to mapToProductTypeDrafts . #138 \u2728 Enhancements (1) The library will fail fast for the non-existing references that found during the reference resolution. #219 \ud83d\udee0\ufe0f Dependency Updates (4) commercetools-jvm-sdk 1.52.0 -> 1.53.0 org.assertj.assertj-core 3.16.0 -> 3.17.2 junit.jupiterApiVersion 5.6.2 -> 5.7.0 mockito-junit-jupiter 3.4.4 -> 3.5.10 com.github.ben-manes.versions 0.29.0 -> 0.33.0","title":"2.0.0 - Sept 14, 2020"},{"location":"RELEASE_NOTES/#191-aug-5-2020","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Product Sync - Fixed a bug in the ProductSync related to publish/unpublish of the product update actions, when a new product draft has publish flag set to true and the existing product is published already then no publish action will be created which was not correct #530","title":"1.9.1 -  Aug 5, 2020"},{"location":"RELEASE_NOTES/#190-july-27-2020","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (6) TaxCategory Sync - Added support for syncing tax categories. #417 For more info how to use it please refer to TaxCategory usage doc . TaxCategory Sync - Exposed TaxCategorySyncUtils#buildActions which calculates all needed update actions after comparing a TaxCategory and a TaxCategoryDraft . #417 TaxCategory Sync - Exposed TaxCategoryUpdateActionUtils which contains utils for calculating needed update actions after comparing individual fields of a TaxCategory and a TaxCategoryDraft . #417 State Sync - Added support for syncing states. #409 For more info how to use it please refer to States usage doc . State Sync - Exposed StateSyncUtils#buildActions which calculates all needed update actions after comparing a State and a StateDraft . #409 State Sync - Exposed StateUpdateActionUtils which contains utils for calculating needed update actions after comparing individual fields of a State and a StateDraft . #409 Thanks, @jarzynp for the contributions! \ud83d\udee0\ufe0f Dependency Updates (6) com.adarshr.test-logger 2.0.0 -> 2.1.0 org.assertj.assertj-core 3.15.0 -> 3.16.0 junit.jupiterApiVersion 5.6.1 -> 5.6.2 commercetools-jvm-sdk 1.51.0 -> 1.52.0 mockito-junit-jupiter 3.3.3 -> 3.4.4 com.github.ben-manes.versions 0.28.0 -> 0.29.0","title":"1.9.0 -  July 27, 2020"},{"location":"RELEASE_NOTES/#182-april-30-2020","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (2) Commons - Fixed a bug in the Sync implementations causing the sync fail with throwing ClassCastException . #466 Product Sync - Fixed a bug in the ProductSync related to the ordering of variant update actions, which was not correct when there is SetAttributeInAllVariants action in update actions. Thanks, @ahmed-ali225, for the contributions! #513","title":"1.8.2 -  April 30, 2020"},{"location":"RELEASE_NOTES/#181-april-22-2020","text":"Commits | Javadoc | Jar \u2728 Enhancements (1) Commons - Remove final keyword on interface/abstract method params. #165 \ud83d\udc1e Bug Fixes (3) CartDiscount Sync - Fixed a bug in the CartDiscountSync which generates a changeValue action when there is no change, causing the sync to fail for that cart discount. Thanks, @michaelbannister, for the contributions! #494 Product Sync - Fixed a bug in the ProductSync when ensurePriceChannels is enabled in ProductSyncOptions should not create a missing channel used on product variant price draft. #499 Product/Category Sync - Validate that asset keys are always defined on the supplied drafts and the existing target resources (products/categories). #366 \ud83d\udee0\ufe0f Dependency Updates (5) junit.jupiterApiVersion 5.5.2 -> 5.6.1 commercetools-jvm-sdk 1.48.0 -> 1.51.0 org.assertj.assertj-core 3.14.0 -> 3.15.0 mockito-junit-jupiter 3.2.4 -> 3.3.3 com.github.ben-manes.versions 0.27.0 -> 0.28.0 ru.vyarus.mkdocs 2.0.0 -> 2.0.1 org.ajoberstar.grgit 4.0.1 -> 4.0.2","title":"1.8.1 -  April 22, 2020"},{"location":"RELEASE_NOTES/#180-jan-17-2020","text":"Commits | Javadoc | Jar \u2728 Enhancements (1) Inventory Sync - Only cache the needed keys of Channel references instead of caching all keys of such resources. #198 Note : This might have performance implications on the inventory sync, since now every non cached key-id entry will be individually fetched. However, issue #235 should address this.","title":"1.8.0 -  Jan 17, 2020"},{"location":"RELEASE_NOTES/#170-jan-7-2020","text":"Commits | Javadoc | Jar \u2728 Enhancements (2) Product Sync - Only cache the needed keys of Category , ProductType and Type references instead of caching all keys of such resources. #418 Note : This might have performance implications on the product sync, since now every non cached key-id entry will be individually fetched. However, issue #235 should address this. Commons - Refactor duplicate implementations in concrete services and generalise it in the BaseService . Thanks, @jarzynp, for the contributions! #418 \ud83d\udc1e Bug Fixes (1) Product Sync - Fixed a bug in the Product Sync where keys with special characters failed to be saved for CustomObject s, as the characters weren't allowed on the commmercetools platform. #474 Note : \ud83d\udea7 This is a breaking change. Previously stored custom objects representing product drafts with unresolved references, won't be synced with this version, since the key is now treated differently. Make sure to sync such drafts again with this version of the library. \ud83d\udee0\ufe0f Dependency Updates (5) org.ajoberstar.grgit 3.1.1 -> 4.0.1 org.ajoberstar.git-publish 2.1.1 -> 2.1.3 mockito-junit-jupiter 3.1.0 -> 3.2.4 commercetools-jvm-sdk 1.47.0 -> 1.48.0 org.assertj.assertj-core 3.13.2 -> 3.14.0","title":"1.7.0 -  Jan 7, 2020"},{"location":"RELEASE_NOTES/#161-oct-17-2019","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (3) Commons - Fixed a bug in the CtpQueryUtils which was overwriting the query input query for every page after the first page is fetched, eventually fetching more than needed. #463 Product Sync - Fixed a potential bug in reference resolution of attribute references in case a null reference is passed in an attribute draft of type Set of Reference . #441 ProductType Sync - Fixed a bug in the productType sync where the statistics failed counter was being counted on failed fetches of missing references. #426 \ud83d\udee0\ufe0f Dependency Updates (4) mockito-junit-jupiter 3.0.0 -> 3.1.0 com.adarshr.test-logger 1.7.1 -> 2.0.0 com.github.ben-manes.versions 0.25.0 -> 0.27.0 commercetools-jvm-sdk 1.46.0 -> 1.47.0","title":"1.6.1 -  Oct 17, 2019"},{"location":"RELEASE_NOTES/#160-oct-10-2019","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Product Sync - Introduced support for syncing products with other product references as attributes in any order. #447 \ud83d\udee0\ufe0f Dependency Updates (1) com.adarshr.test-logger 1.7.0 -> 1.7.1 #456","title":"1.6.0 -  Oct 10, 2019"},{"location":"RELEASE_NOTES/#150-sept-13-2019","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (4) Product Sync - Added support for resolving Product references on attributes of type Reference , Set of Reference , NestedType or Set of NestedType . #438 Product Sync - Added support for resolving Category references on attributes of type Reference , Set of Reference , NestedType or Set of NestedType . #440 Product Sync - Added support for resolving ProductType references on attributes of type Reference , Set of Reference , NestedType or Set of NestedType . #440 Commons - Exposed ResourceIdentifierUtils#isReferenceOfType utility which checks if a JSON representation of a CTP Reference object is of a certain typeId or not. #443 \ud83d\udea7 Breaking Changes (1) Product Sync - Unexposed the methods VariantReferenceResolver#resolveAttributeReferences and VariantReferenceResolver#resolveAttributeReference to be private as they are only meant for internal use of the library. #440 \ud83d\udee0\ufe0f Dependency Updates (5) Gradle 5.6.1 -> 5.6.2 org.junit.jupiter:junit-jupiter-api 5.5.1 -> 5.5.2 org.junit.jupiter:junit-jupiter-engine 5.5.1 -> 5.5.2 org.junit.jupiter:junit-jupiter-params 5.5.1 -> 5.5.2 com.github.ben-manes.versions 0.22.0 -> 0.25.0","title":"1.5.0 -  Sept 13, 2019"},{"location":"RELEASE_NOTES/#141-sept-2-2019","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Commons - Fixed a bug in the custom fields update actions builders which generated duplicated unnecessary update actions for null custom field values. This affected any sync module where the resource contained custom fields (i.e. Product Sync, Category Sync, CartDiscount Sync and Inventory Sync). It also affected any update actions building utility in which the resource/sub-resource contained custom fields. #428 \ud83d\udee0\ufe0f Enhancements (1) Commons - Bumped commercetools-jvm-sdk to version 1.46.0 which includes a fix for a serialization bug in the SetCustomField action which was ignoring empty array values. #430","title":"1.4.1 -  Sept 2, 2019"},{"location":"RELEASE_NOTES/#140-aug-8-2019","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (5) ProductType Sync - Introduced support for syncing product types with NestedType (or set of NestedType) attributes in any order. #372 ProductType Sync - Introduced the new ProductTypeReferenceReplacementUtils#replaceProductTypesReferenceIdsWithKeys which is a util that replaces the reference ids with keys in a list of productTypes. #372 ProductType Sync - Introduced the new ProductTypeReferenceReplacementUtils#buildProductTypeQuery utils to create a product type query with all needed reference expansions to fetch productTypes from a source CTP project for the sync. #372 ProductType Sync - Introduced the new ProductTypeReferenceResolver which resolves productType references on ProductTypeDrafts. #372 ProductType Sync - Introduced the new methods ProductTypeSyncStatistics#getNumberOfProductTypesWithMissingNestedProductTypes and ProductTypeSyncStatistics#getProductTypeKeysWithMissingParents which represents the nested product types which are still not resolved. #372 \ud83d\udee0\ufe0f Enhancements (8) Commons - Bumped commercetools-jvm-sdk to version 1.45.0 . Commons - Bumped gradle to version gradle-5.5.1 Commons - Bumped org.junit.jupiter:junit-jupiter-api to 5.5.1. Commons - Bumped org.junit.jupiter:junit-jupiter-engine to 5.5.1. Commons - Bumped org.junit.jupiter:junit-jupiter-params to 5.5.1. Commons - Bumped mockito-junit-jupiter dependency to 3.0.0. Commons - Bumped assertj to 3.13.2. Commons - Bumped com.github.ben-manes.versions to 0.22.0.","title":"1.4.0 -  Aug 8, 2019"},{"location":"RELEASE_NOTES/#130-jul-3-2019","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (6) CartDiscount Sync - Added support for syncing cart discounts. #379 For more info how to use it please refer to CartDiscount usage doc . CartDiscount Sync - Introduced the new CartDiscountSyncUtils#buildActions which calculates all needed update actions after comparing a CartDiscount and a CartDiscountDraft . #379 CartDiscount Sync - Introduced the new CartDiscountUpdateActionUtils which contains utils for calculating needed update actions after comparing individual fields of a CartDiscount and a CartDiscountDraft . #379 CartDiscount Sync - Introduced the new CartDiscountReferenceResolver which resolves custom type references on CartDiscountDrafts. #379 CartDiscount Sync - Introduced the new CartDiscountReferenceReplacementUtils#replaceCartDiscountsReferenceIdsWithKeys which is a util that replaces the custom type ids with keys in a list of cartDiscounts. #379 CartDiscount Sync - Introduced the new CartDiscountReferenceReplacementUtils#buildCartDiscountQuery util to create a cart discount query with all needed reference expansions to fetch cart discounts from a source CTP project for the sync. #379 . \ud83d\udc1e Bug Fixes (1) Commons - Fixed a bug in the BaseSyncStatistics which caused a wrong calculation of the latestBatchProcessingTimeInMinutes . #378 \ud83d\udee0\ufe0f Enhancements (6) CartDiscount Sync - Added benchmarks for the cartDiscount sync to be able to compare the performance of the sync with the future releases. #379 Commons - Bumped commercetools-jvm-sdk to version 1.44.0 . Commons - Bumped gradle to version gradle-5.5 Commons - Bumped org.junit.jupiter:junit-jupiter-api to 5.5.0. Commons - Bumped org.junit.jupiter:junit-jupiter-engine to 5.5.0. Commons - Bumped org.junit.jupiter:junit-jupiter-params to 5.5.0.","title":"1.3.0 -  Jul 3, 2019"},{"location":"RELEASE_NOTES/#120-jun-14-2019","text":"Commits | Javadoc | Jar \ud83d\udea7 Breaking Changes (2) ProductType Sync - Removed the unneeded AttributeDefinitionCustomBuilder which was an exposed but internal helper. #377 . Commons - SyncUtils#replaceReferenceIdWithKey is now renamed to SyncUtils#getReferenceWithKeyReplaced . #394 \ud83c\udf89 New Features (2) Commons - Added the new CommonTypeUpdateActionUtils#buildUpdateActionForReferences which is used for comapring references/resourceIdentifiers and buiding an update action if needed. #394 Commons - Added the new SyncUtils#getResourceIdentifierWithKeyReplaced util. #394 \ud83d\udc1e Bug Fixes (1) Commons - Fixed a bug where references and resource identifiers were not being compared correctly. #394 \ud83d\udee0\ufe0f Enhancements (13) Commons - Bumped commercetools-jvm-sdk to version 1.43.0 . Commons - Bumped mockito to 2.27.0. Commons - Bumped assertj to 3.12.2. Commons - Bumped org.junit.jupiter:junit-jupiter-api to 5.4.2. Commons - Bumped org.junit.jupiter:junit-jupiter-engine to 5.4.2. Commons - Bumped org.junit.jupiter:junit-jupiter-params to 5.4.2. Commons - Bumped org.ajoberstar.git-publish to 2.1.1. Commons - Bumped org.ajoberstar.grgit to 3.1.1. Commons - Bumped com.github.ben-manes.versions to 0.21.0. Commons - Bumped gradle checkstyle plugin to 8.2. Commons - Bumped mockito dependency to 2.28.2. Commons - Bumped JaCoCo dependency to 0.8.4. Commons - Bumped gradle to version gradle-5.4.1 Commons - Bumped com.adarshr.test-logger to 1.7.0.","title":"1.2.0 -  Jun 14, 2019"},{"location":"RELEASE_NOTES/#111-jan-16-2019","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Product Sync - Fixed a bug in the product sync which would fail on syncing attributes of type Set that has an empty set as a value.","title":"1.1.1 -  Jan 16, 2019"},{"location":"RELEASE_NOTES/#110-dec-19-2018","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (4) Product Sync - Added support for syncing assets of newly added variants. #357 . Product Sync - ProductSyncUtils#buildActions and ProductUpdateActionUtils#buildVariantsUpdateActions now build AddAsset actions for every new asset on every new variant on the new ProductDraft . #357 . ProductType Sync - Added support for syncing changes to an AttributeDefinition with a SetType of a subtype LocalizableEnumType or EnumType #313 Type Sync - Added support for syncing changes to a FieldDefinition with a SetType of a subtype LocalizableEnumType or EnumType #313 \ud83d\udc1e Bug Fixes (3) ProductType Sync - Fixed a bug in the productType sync which would try to unset isSearchable , inputHint and attributeConstraint values to null instead of their default values. #354 ProductType Sync - ProductTypeSyncUtils#buildActions , ProductTypeUpdateActionUtils#buildAttributesUpdateActions now treat the values of the optional fields isSearchable , inputHint and attributeConstraint as ( true , SingleLine and None respectivley) if they are null or not passed. #354 Commons - Fixed a bug in the beforeUpdateCallback which caused the callback to be called even on an empty list of update actions. #359 \ud83d\udee0\ufe0f Enhancements (1) Commons - Benchmarks are now run once on every merge to master with a lower number of resources for faster benchmarking. #246 \ud83d\udccb Documentation (2) Commons - Added link to documentation pages in README of the github repo. Commons - Fixed link of beforeUpdateCallback for keeping other variants example in the Sync Options doc page. #360","title":"1.1.0 -  Dec 19, 2018"},{"location":"RELEASE_NOTES/#100-dec-10-2018","text":"Commits | Javadoc | Jar","title":"1.0.0 -  Dec 10, 2018"},{"location":"RELEASE_NOTES/#the-beta-is-over","text":"We're happy to announce that the commercetools-sync-java is finally out of beta! Big thanks to all the users who were using it when it was still in beta. Your feedback was definitely valuable for us to reach the current state of the library. 1.0.0 is here for you to use with all new features, enhancements and bug fixes including: The library now supports importing/syncing types into a CTP project from an external feed or another CTP project. Read more . The library now handles concurrency modification exceptions for the productType sync. All new documentation pages including a quick start guide . Many more improvements and bug fixes.","title":"The Beta is Over \ud83c\udf89"},{"location":"RELEASE_NOTES/#full-release-notes","text":"\ud83c\udf89 New Features (4) Type Sync - Added support for syncing types. #300 For more info how to use it please refer to Type usage doc . Type Sync - Exposed TypeSyncUtils#buildActions which calculates all needed update actions after comparing a Type and a TypeDraft . #300 Type Sync - Exposed TypeUpdateActionUtils which contains utils for calculating needed update actions after comparing individual fields of a Type and a TypeDraft . #300 Commons - Added OptionalUtils#filterEmptyOptionals which are utility methods that filter out the empty optionals in a supplied list (with a varargs variation) returning a list of the contents of the non-empty optionals. #255 \ud83d\udee0\ufe0f Enhancements (17) ProductType Sync - Added concurrency modification exception handling. #325 Commons - ProductSyncUtils#buildActions , CategorySyncUtils#buildActions , InventorySyncUtils#buildActions and ProductTypeSyncUtils#buildActions now don't apply the beforeUpdateCallback implicitly. If you want, you can apply it explicitly on the result of the ..#buildActions method. #302 Product Sync - Reference keys are not validated if they are in UUID format anymore. #166 Category Sync - Reference keys are not validated if they are in UUID format anymore. #166 Inventory Sync - Reference keys are not validated if they are in UUID format anymore. #166 ProductType Sync - Added benchmarks for the productType sync to be able to compare the performance of the sync with the future releases. #301 Commons - Bumped commercetools-jvm-sdk to version 1.37.0 . Commons - Bumped mockito to 2.23.4. Commons - Bumped com.adarshr.test-logger to 1.6.0. Commons - Bumped org.junit.jupiter:junit-jupiter-api to 5.3.2. Commons - Bumped org.junit.jupiter:junit-jupiter-engine to 5.3.2. Commons - Bumped org.junit.jupiter:junit-jupiter-params to 5.3.2. Commons - Bumped org.ajoberstar.git-publish to 2.0.0. Commons - Bumped org.ajoberstar.grgit to 3.0.0. Commons - Bumped gradle to version gradle-5.0 Type Sync - Added benchmarks for the type sync to be able to compare the performance of the sync with the future releases. #300 \ud83d\udea7 Breaking Changes (9) Product Sync - allowUuid option is now removed. #166 Category Sync - allowUuid option is now removed. #166 Inventory Sync - allowUuid option is now removed. #166 ProductType Sync - allowUuid option is now removed. #166 ProductType Sync - Renamed ProductTypeUpdateAttributeDefinitionActionUtils to AttributeDefinitionsUpdateActionUtils . It is also now meant to be only used internally by the library. Its behaviour is not guaranteed if used externally. #302 ProductType Sync - AttributeDefinitionUpdateActionUtils is now meant to be only used internally by the library. Its behaviour is not guaranteed if used externally. #302 ProductType Sync - EnumsUpdateActionUtils is now EnumValuesUpdateActionUtils and is meant to be only used internally by the library. Its behaviour is not guaranteed if used externally. #300 ProductType Sync - Utils that were in ProductTypeUpdateLocalizedEnumActionUtils and LocalizedEnumsUpdateActionUtils. are moved to LocalizedEnumValueUpdateActionUtils . #300 ProductType Sync - Utils that were in ProductTypeUpdatePlainEnumActionUtils and PlainEnumUpdateActionsUtils. are moved to PlainEnumValueUpdateActionUtils . #300 \ud83d\udc1e Bug Fixes (3) Product Sync - Fixed a bug that caused the statistics not to be updated correctly on fetch failure. #331 Category Sync - Fixed a bug that caused the statistics not to be updated correctly on fetch failure. #331 ProductType Sync - Fixed a bug that caused the sync process to continue after failed fetch. #331 \ud83d\udccb Documentation (4) Commons - Added the documentation github pages. https://commercetools.github.io/commercetools-sync-java Commons - Added a Quick Start Guide for a convenient entry into the library. Commons - Moved documentation of sync options to a separate doc . Commons - Added a the earliest compatible version of the commercetools-jvm-sdk]( https://github.com/commercetools/commercetools-jvm-sdk ) as a prerequisite for using the library.","title":"Full Release Notes"},{"location":"RELEASE_NOTES/#v100-m14-oct-5-2018","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Product Sync - Fixed a bug where the removed attributes in the source product variant draft were not being removed from the target variant. #238 \ud83d\udee0 Enhancements (8) Product Sync - Products create and update requests are now issued in parallel. This should lead to a performance improvement. #238 Commons - Bumped com.adarshr.test-logger to 1.5.0. Commons - Bumped mockito to 2.22.0. Commons - Bumped org.junit.jupiter:junit-jupiter-api to 5.3.1. Commons - Bumped org.junit.jupiter:junit-jupiter-engine to 5.3.1. Commons - Bumped org.junit.jupiter:junit-jupiter-params to 5.3.1. Commons - UnorderedCollectionSyncUtils#buildRemoveUpdateActions ensures no null elements in the resulting list and ignores null` keys now. #238 Commons - Bumped gradle to version gradle-4.10.2 . \ud83d\udea7 Breaking Changes (2) Product Sync - AttributeMetaData#isRequired is now removed. #308 Product Sync - ProductVariantAttributeUpdateActionUtils#buildProductVariantAttributeUpdateAction now takes a map of all meta data instead of the specific metadata entry. #308","title":"v1.0.0-M14 -  Oct 5, 2018"},{"location":"RELEASE_NOTES/#v100-m13-sept-5-2018","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (15) ProductType Sync - Support for syncing productTypes. #286 For more info how to use it please refer to ProductType usage doc . Product Sync - Support for syncing product prices. #101 Product Sync - ProductSyncUtils#buildActions now also calculates variants' all price update actions needed. #101 Product Sync - ProductUpdateActionUtils#buildVariantsUpdateActions now also calculates variants' all price update actions needed. #101 Product Sync - Introduced new update action build utility for building all needed update actions between two variants' prices ProductVariantUpdateActionUtils#buildProductVariantPricesUpdateActions . #101 ProductSync - PriceReferenceResolver now resolves prices' CustomerGroup references on prices. #101 InventoryEntry Sync - InventoryReferenceReplacementUtils#replaceInventoriesReferenceIdsWithKeys now supports replacing channel reference ids with keys. #101 ProductType Sync - Exposed ProductTypeSyncUtils#buildActions which calculates all needed update actions after comparing a ProductType and a ProductTypeDraft . #286 ProductType Sync - Exposed ProductTypeUpdateActionUtils which contains utils for calculating needed update actions after comparing individual fields of a ProductType and a ProductTypeDraft . #286 ProductType Sync - Exposed ProductTypeUpdateAttributeDefinitionActionUtils which contains utils for calculating needed update actions after comparing a list of AttributeDefinition s and a list of AttributeDefinitionDraft s. #286 ProductType Sync - Exposed ProductTypeUpdateLocalizedEnumActionUtils which contains utils for calculating needed update actions after comparing two lists of LocalizedEnumValue s. #286 ProductType Sync - Exposed ProductTypeUpdatePlainEnumActionUtils which contains utils for calculating needed update actions after comparing two lists of EnumValue s. #286 ProductType Sync - Exposed AttributeDefinitionUpdateActionUtils which contains utils for calculating needed update actions after comparing an AttributeDefinition and an AttributeDefinitionDraft . #286 ProductType Sync - Exposed LocalizedEnumUpdateActionsUtils which contains utils for calculating needed update actions after comparing two LocalizedEnumValue s. #286 ProductType Sync - Exposed PlainEnumUpdateActionsUtils which contains utils for calculating needed update actions after comparing two EnumValue s. #286 \ud83d\udee0\ufe0f Enhancements (7) Commons - Bumped gradle to version gradle-4.10 . Commons - Bumped com.jfrog.bintray to 1.8.4. Commons - Bumped assertj to 3.11.1. Commons - Bumped mockito to 2.21.0. Commons - Bumped org.ajoberstar.grgit to 2.3.0. Commons - Bumped com.adarshr.test-logger to 1.4.0. Commons - Switched to Junit5 using both junit-jupiter-engine and junit-vintage-engine for backward compatibility. \ud83d\udee0\ufe0f Breaking Changes (3) Product Sync - Removed redundant ProductUpdateActionUtils#buildRemoveVariantUpdateActions . #3 Commons - Moved SyncUtils#replaceCustomTypeIdWithKeys to CustomTypeReferenceReplacementUtils#replaceCustomTypeIdWithKeys . #101 . Commons - Moved SyncUtils#replaceAssetsReferencesIdsWithKeys to AssetReferenceReplacementUtils#replaceAssetsReferencesIdsWithKeys . #101 .","title":"v1.0.0-M13 -  Sept 5, 2018"},{"location":"RELEASE_NOTES/#v100-m12-jun-05-2018","text":"Commits | Javadoc | Jar \ud83d\udee0\ufe0f Enhancements (13) Product Sync - Support for syncing price custom fields. #277 Product Sync - VariantReferenceResolver now resolves prices' custom type references on all variants. #277 Product Sync - ProductReferenceReplacementUtils#buildProductQuery now expands custom types on prices. #277 Product Sync - VariantReferenceReplacementUtils#replacePricesReferencesIdsWithKeys now supports replacing price custom reference ids with keys. #277 Commons - Bumped commercetools-jvm-sdk to version 1.32.0 . Commons - Bumped gradle to version gradle-4.8 . Commons - Bumped com.jfrog.bintray to 1.8.0. Commons - Bumped org.ajoberstar.git-publish to 1.0.0. Commons - Bumped com.adarshr.test-logger to 1.2.0. Commons - Bumped org.ajoberstar.grgit to 2.2.1. Commons - Bumped gradle checkstyle plugin to 8.10.1. Commons - Bumped mockito dependency to 2.18.3. Commons - Bumped JaCoCo dependency to 0.8.1.","title":"v1.0.0-M12 -  Jun 05, 2018"},{"location":"RELEASE_NOTES/#v100-m11-mar-08-2018","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (19) Category Sync - Support of categories' asset syncing. #3 Product Sync - Support of product variants' asset syncing. #3 Category Sync - CategorySyncUtils#buildActions now also calculates all asset update actions needed. #3 Product Sync - ProductSyncUtils#buildActions now also calculates variants' all asset update actions needed. #3 Product Sync - ProductUpdateActionUtils#buildVariantsUpdateActions now also calculates variants' all asset update actions needed. #3 Product Sync - Introduced the new ActionGroup: ASSETS which can be used in blacklisting/whitelisting assets syncing during the product sync. #3 Category Sync - Introduced new update action build utility for building all needed update actions between two categories' assets ProductVariantUpdateActionUtils#buildProductVariantAssetsUpdateActions . #3 Product Sync - Introduced new update action build utility for building all needed update actions between two variants' assets ProductVariantUpdateActionUtils#buildProductVariantAssetsUpdateActions . #3 Category Sync - Introduced new update action granular build utils for category asset fields in CategoryAssetUpdateActionUtils . #3 Product Sync - Introduced new update action granular build utils for product variant assets fields in ProductVariantAssetUpdateActionUtils . #3 Commons - Introduced AssetReferenceResolver which is a helper that can resolve all the references of an AssetDraft. #3 Commons - VariantReferenceResolver and CategoryReferenceResolver now also resolve all the containing AssetDrafts references. #3 Commons - Support for custom update actions calculation for secondary resources (e.g. prices, product assets and category assets). #3 Product Sync - ProductReferenceReplacementUtils#replaceProductsReferenceIdsWithKeys and VariantReferenceReplacementUtils#replaceVariantsReferenceIdsWithKeys now support replacing asset custom reference ids with keys. #3 Category Sync - CategoryReferenceReplacementUtils#replaceCategoriesReferenceIdsWithKeys now supports replacing asset custom reference ids with keys. #3 Commons - Introduced new SyncUtils#replaceAssetsReferenceIdsWithKeys which is a util that replaces the custom type ids with keys in a list of assets. #3 Product Sync - ProductReferenceReplacementUtils#buildProductQuery now expands custom types on assets. #3 Category Sync - CategoryReferenceReplacementUtils#buildCategoryQuery now expands custom types on assets. #3 Commons - Introduced new ResourceIdentifierUtils#toResourceIdentifierIfNotNull . #262 Changes (5) Commons - CustomUpdateActionUtils#buildCustomUpdateActions is now CustomUpdateActionUtils#buildPrimaryResourceCustomUpdateActions . It now takes a new third parameter customActionBuilder which represents the concrete builder of custom update actions. For a list of concrete builder options check the implementors of the GenericCustomActionBuilder interface. #3 Commons - CustomUpdateActionUtils#buildCustomUpdateActions can now be used to build custom update actions for secondary resources (e.g. assets and prices). #3 Commons - New Custom Type Id is now validated against being empty/null. #3 Product Sync - ProductSyncUtils#buildCoreActions is now removed. ProductSyncUtils#buildActions should be used instead. #3 Category Sync - CategorySyncUtils#buildCoreActions is now removed. CategorySyncUtils#buildActions should be used instead. #3 \ud83d\udee0\ufe0f Enhancements (1) Build Tools - Bumped commercetools-jvm-sdk to version 1.30.0 . #262 \ud83d\udc1e Bug Fixes (1) Build Tools - Fixed bug where jar and Codecov were triggered on benchmark stages of the build when they should only be triggered on the full build. #249","title":"v1.0.0-M11 -  Mar 08, 2018"},{"location":"RELEASE_NOTES/#v100-m10-feb-13-2018","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Commons - Added benchmarking setup for the library on every release. #155 Changes (3) Commons - Statistics counters are now of type AtomicInteger instead of int to support concurrency. #242 Category Sync - categoryKeysWithMissingParents in the CategorySyncStatistics is now of type ConcurrentHashMap<String, Set<String> instead of Map<String, List<String> . #242 Category Sync - CategorySyncStatistics now exposes the methods removeChildCategoryKeyFromMissingParentsMap , getMissingParentKey and putMissingParentCategoryChildKey to support manipulating categoryKeysWithMissingParents map. #242","title":"v1.0.0-M10 -  Feb 13, 2018"},{"location":"RELEASE_NOTES/#v100-m9-jan-22-2018","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Commons - Added getSyncOptions to the ProductSync , CategorySync and InventorySync . #230 Changes (1) Product Sync - Added validation for product drafts' SKUs as a required field on the input product drafts since SKUs will be used for product matching in the future. #230 \ud83d\udee0\ufe0f Enhancements (1) Product Sync - Changed the product sync to cache product ids per batch as opposed to caching the entire products ids before syncing products. #230 \ud83d\udc1e Bug Fixes (1) Commons - Fixed library version in User-Agent headers of JVM SDK clients using the library. Now it is not fetched from the JAR manifest but injected by gradle-scripts/set-release-version.gradle. #227","title":"v1.0.0-M9 -  Jan 22, 2018"},{"location":"RELEASE_NOTES/#v100-m8-dec-29-2017","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (1) Category Sync - Exposed new method CategorySyncStatistics#getNumberOfCategoriesWithMissingParents which gets the total number of categories with missing parents from the statistics instance. #186 Changes (2) Product Sync - Changed product sync statistics report message wording. #186 Product Sync - Exposed new methods ProductReferenceResolver#resolveStateReference , ProductReferenceResolver#resolveTaxCategoryReference , ProductReferenceResolver#resolveCategoryReferences and ProductReferenceResolver#resolveProductTypeReference . #218 \ud83d\udee0 Enhancements (1) Build Tools - Bumped Gradle to version 4.4. #205","title":"v1.0.0-M8 -  Dec 29, 2017"},{"location":"RELEASE_NOTES/#v100-m7-dec-15-2017","text":"Commits | Javadoc | Jar \ud83d\udc1e Bug Fixes (1) Commons - Changed offset-based pagination of querying all elements to a limit-based with sorted ids approach to mitigate problems of previous approach. #210","title":"v1.0.0-M7 -  Dec 15, 2017"},{"location":"RELEASE_NOTES/#v100-m6-dec-5-2017","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (3) Category Sync - Introduced beforeCreateCallback option which is callback applied on a category draft before a request to create it on CTP is issued. #183 Product Sync - Introduced beforeCreateCallback option which is callback applied on a product draft before a request to create it on CTP is issued. #183 Inventory Sync - Introduced beforeCreateCallback option which is callback applied on a inventoryEntry draft before a request to create it on CTP is issued. #183 \u2728 Major Enhancements (2) Category Sync - Introduced batching on update action requests to allow for requesting updates of more than 500 actions. #21 Product Sync - Introduced batching on update action requests to allow for requesting updates of more than 500 actions. #21 \ud83d\udc1e Bug Fixes (1) Commons - Fixed library version in User-Agent headers of JVM SDK clients using the library. #191 \ud83d\udccb Documentation (1) Commons - Added Code of Conduct doc. \ud83d\udea7 Migration guide (6) Product Sync - Removed removeOtherVariants option which is already done by the sync by default. Removal of variants can be prevented through the beforeUpdateCallback. Please check here an example of how this can be done. #26 Commons - Removed removeOtherSetEntries , removeOtherCollectionEntries and removeOtherProperties options which are already done by the sync by default. The aforementioned options (and even more use cases) can now be covered with help of the beforeCreateCallback and beforeUpdateCallback. Please check here an example of how removal of variants can be disabled. #26 Commons - Removed website and emergency contact e-mail appened in User-Agent headers of JVM SDK clients using the library. #191 Category Sync - beforeUpdateCallback now treats a null return as an empty list of update actions. #183 Product Sync - beforeUpdateCallback now treats a null return as an empty list of update actions. #183 Inventory Sync - beforeUpdateCallback now treats a null return as an empty list of update actions. #183","title":"v1.0.0-M6 -  Dec 5, 2017"},{"location":"RELEASE_NOTES/#v100-m5-nov-16-2017","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (3) Inventory Sync - Introduced beforeUpdateCallback which is applied after generation of update actions and before actual InventoryEntry update. #169 Build Tools - Added Add Release Notes entry checkbox in PR template on Github repo. #161 Commons - Appended library name and version to User-Agent headers of JVM SDK clients using the library. #142 \ud83d\udee0\ufe0f Enhancements (3) Commons - setUpdateActionsCallback has been renamed to beforeUpdateCallback and now takes a TriFunction instead of Function, which adds more information about the generated list of update actions, namely, the old resource being updated and the new resource draft. #169 Build Tools - Explicitly specified gradle tasks execution order in execution-order.gradle. #161 Build Tools - Set PMD to run before Integration tests. #161 Commons - Appended library name and version to User-Agent headers of JVM SDK clients using the library. #142 \ud83d\udccb Documentation (1) Build Tools - Added Snyk vulnerabilities badge to repo README. #188 \ud83d\udea7 Migration guide (8) Commons - Renamed setUpdateActionsCallback to beforeUpdateCallback . #169 Commons - Renamed setAllowUuid to allowUuid . #169 Commons - Renamed setWarningCallBack to warningCallback . #169 Commons - Renamed setErrorCallBack to errorCallback . #169 Commons - Renamed setBatchSize to batchSize . #169 Commons - Removed setRemoveOtherLocales option. #169 Commons - Renamed setRemoveOtherSetEntries , setRemoveOtherCollectionEntries and setRemoveOtherProperties to removeOtherSetEntries , removeOtherCollectionEntries and removeOtherProperties . #169 Product Sync - Renamed setSyncFilter to syncFilter . #169","title":"v1.0.0-M5 -  Nov 16, 2017"},{"location":"RELEASE_NOTES/#v100-m4-nov-7-2017","text":"Commits | Javadoc | Jar \ud83d\udd25 Hotfix (1) Product Sync - Fixed an issue with replaceAttributesReferencesIdsWithKeys which nullifies localized text attributes due to JSON parsing not throwing exception on parsing it to reference set. #179","title":"v1.0.0-M4 -  Nov 7, 2017"},{"location":"RELEASE_NOTES/#v100-m3-nov-3-2017","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (7) ProductSync - Introduced Product TaxCategory reference resolution and syncing. #120 . ProductSync - Introduced Product State reference resolution and syncing. #120 . ProductSync - Exposed ProductReferenceReplacementUtils#buildProductQuery util to create a product query with all needed reference expansions to fetch products from a source CTP project for the sync. #120 . ProductSync - Exposed VariantReferenceReplacementUtils#replaceVariantsReferenceIdsWithKeys which provides utils to replace reference ids with keys on variants (price and attriute references) coming from a source CTP project to make it ready for reference resolution. #160 . ProductSync - Exposed VariantReferenceResolver which is a helper that resolves the price and attribute references on a ProductVariantDraft. (Note: This is used now by the already existing ProductReferenceResolver) #160 . CategorySync - Exposed CategoryReferenceReplacementUtils#buildCategoryQuery util to create a category query with all needed reference expansions to fetch categories from a source CTP project for the sync. #120 . Commons - Exposed replaceCustomTypeIdWithKeys and replaceReferenceIdWithKey . #120 . \ud83d\udc1e Bug Fixes (1) Category Sync - Fixes an issue where retrying on concurrent modification exception wasn't re-fetching the latest Category and rebuilding build update actions. #94 \ud83d\udccb Documentation (6) Product Sync - Documented the reason behind having the latest batch processing time. #119 Category Sync - Documented the reason behind having the latest batch processing time. #119 Category Sync - Fixed the statistics summary string used in the documentation. #119 Inventory Sync - Documented the reason behind having the latest batch processing time. #119 Product Sync - Fixed some typos. #172 Commons - Provided inline example of how to use logging in callbacks. #172 \ud83d\udea7 Migration guide (9) Product Sync - Moved replaceProductsReferenceIdsWithKeys from SyncUtils to ProductReferenceReplacementUtils . #120 Product Sync - Removed replaceProductDraftsCategoryReferenceIdsWithKeys which is not needed anymore. #120 Product Sync - Removed replaceProductDraftCategoryReferenceIdsWithKeys which is not needed anymore. #120 Product Sync - Removed replaceCategoryOrderHintCategoryIdsWithKeys which is not needed anymore. #120 Product Sync - Moved getDraftBuilderFromStagedProduct from SyncUtils to ProductReferenceReplacementUtils . #120 Category Sync - Moved replaceCategoriesReferenceIdsWithKeys from SyncUtils to CategoryReferenceReplacementUtils . #120 Inventory Sync - Moved replaceInventoriesReferenceIdsWithKeys from SyncUtils to InventoryReferenceReplacementUtils . #120 Commons - Removed slf4j-simple dependency. #172 Commons - Used implementation instead of compile configuration for dependencies. #172","title":"v1.0.0-M3 -  Nov 3, 2017"},{"location":"RELEASE_NOTES/#v100-m2-oct-12-2017","text":"Commits | Javadoc | Jar - \ud83c\udf89 New Features (3) - Product Sync - Supported syncing entire product variant images, putting order into consideration. #114 - Product Sync - Exposed ProductVariantUpdateActionUtils#buildProductVariantImagesUpdateActions and ProductVariantUpdateActionUtils#buildMoveImageToPositionUpdateActions action build util. #114 - Product Sync - Supported Blacklisting/Whitelisting update action groups on sync. #122 \ud83d\udc1e Bug Fixes (4) Build Tools - Fixed issue were JavaDoc jar was not built. #117 Build Tools - Fixed issue were JavaDoc was not published on github. #118 Product Sync - Fixed a potential bug where an exisitng master variant key could be blank. #122 Product Sync - Fixed a potential bug where a product draft could be provided with no master variant set. #122 \ud83d\udee0 Enhancements (2)\ufe0f Build Tools - Integration tests project credentials can now be set on a properties file not only as environment variables and give error messages if not set. #105 Product Sync - Validated the SKU before making a ChangeMasterVariant request by SKU. #122 \ud83d\udccb Documentation (5) Build Tools - Added bintray badge to repo. #126 Product Sync - Added usage documentation. #121 Commons - Separated contributing README into own README not in the main one. #121 Commons - Added release notes doc. #125 Build Tools - Added JavaDoc badge to repo. #145","title":"v1.0.0-M2 -  Oct 12, 2017"},{"location":"RELEASE_NOTES/#v100-m2-beta-sep-28-2017","text":"Commits | Jar Beta Features (11) Product Sync - Introduced syncing products name, categories, categoryOrderHints, description, slug, metaTitle, metaDescription, metaKeywords, masterVariant and searchKeywords. #57 Product Sync - Exposed update action build utils for products name, categories, categoryOrderHints, description, slug, metaTitle, metaDescription, metaKeywords, masterVariant and searchKeywords. #57 Product Sync - Introduced reference resolution support for product categories, productType and prices. #95 #96 Product Sync - Introduced syncing products publish state. #97 Product Sync - Exposed update action build utils for products publish state. #97 Product Sync - Introduced syncing products variant attributes. #98 Product Sync - Exposed update action build utils for products variant attributes. #98 Product Sync - Introduced syncing products variant prices without update action calculation. #99 Product Sync - Introduced syncing products variant images. #100 Product Sync - Exposed update action build utils for products variant images. #100 Product Sync - Introduced syncing products against staged projection. #93","title":"v1.0.0-M2-beta -  Sep 28, 2017"},{"location":"RELEASE_NOTES/#v100-m1-sep-06-2017","text":"Commits | Javadoc | Jar \ud83c\udf89 New Features (16) Category Sync - Introduced syncing category name, description, orderHint, metaDescription, metaTitle, customFields and parent category. #2 Category Sync - Exposed update action build utils for category name, description, orderHint, metaDescription, metaTitle, customFields and parent category. #2 Category Sync - Introduced sync options builders. #5 Category Sync - Introduced support of syncing categories in any order. #28 Category Sync - Added concurrency modification exception repeater. #30 Category Sync - Used category keys for matching. #45 Category Sync - Introduced reference resolution support. #47 Category Sync - Introduced Batch processing support. #73 Category Sync - Added info about missing parent categories in statistics. #73 Commons - Introduced sync statistics support. #6 Commons - Sync ITs should now use client that repeats on 5xx errors. #31 Commons - Sync only accepts drafts. #46 Build Tools - Travis setup as CI tool. #1 Build Tools - Setup Bintray release and publising process. #24 Build Tools - Setup CheckStyle, PMD, FindBugs, Jacoco and CodeCov. #25 Build Tools - Setup repo PR and issue templates. #29 Beta Features (5) Inventory Sync - Introduced syncing inventory supplyChannel, quantityOnStock, restockableInDays, expectedDelivery and customFields. #17 Inventory Sync - Exposed update action build utils for inventory supplyChannel, quantityOnStock, restockableInDays, expectedDelivery and customFields. #17 Inventory Sync - Introduced sync options builder support. #15 Inventory Sync - Introduced reference resolution support. #47 Inventory Sync - Introduced batch processing support. #73","title":"v1.0.0-M1 -  Sep 06, 2017"},{"location":"adr/0001-record-architecture-decisions/","text":"1. Record architecture decisions \u00b6 Date: 2020-11-04 Status \u00b6 Accepted Context \u00b6 We need to record the architectural decisions made on this project. Decision \u00b6 We will use Architecture Decision Records, as described by Michael Nygard . Consequences \u00b6 See Michael Nygard's article, linked above. For a lightweight ADR toolset, see Nat Pryce's adr-tools .","title":"1. Record architecture decisions"},{"location":"adr/0001-record-architecture-decisions/#1-record-architecture-decisions","text":"Date: 2020-11-04","title":"1. Record architecture decisions"},{"location":"adr/0001-record-architecture-decisions/#status","text":"Accepted","title":"Status"},{"location":"adr/0001-record-architecture-decisions/#context","text":"We need to record the architectural decisions made on this project.","title":"Context"},{"location":"adr/0001-record-architecture-decisions/#decision","text":"We will use Architecture Decision Records, as described by Michael Nygard .","title":"Decision"},{"location":"adr/0001-record-architecture-decisions/#consequences","text":"See Michael Nygard's article, linked above. For a lightweight ADR toolset, see Nat Pryce's adr-tools .","title":"Consequences"},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/","text":"2. LineItem and TextLineItem update actions of the ShoppingLists. \u00b6 Date: 2020-11-04 Status \u00b6 Approved Context \u00b6 In a commerce application, a shopping list is a personal wishlist of a customer, (i.e. ingredients for a recipe, birthday wishes). Shopping lists hold line items of products in the platform or any other items that can be described as text line items. We have challenges to build update actions of the LineItem and TextLineItem because of the nature of the synchronization, so in this document, we will describe the reasons and constraints, mostly related to order of the items: - LineItem orders might be important, if the customer has a front end that sorts the line items with their order could mean sorting by importance. LineItems \u00b6 How to ensure line item order? \u00b6 LineItemDrafts LineItems { \"lineItems\": [ { \"sku\": \"SKU-1\", \"quantity\": 1, \"addedAt\": \"2020-11-04T09:38:35.571Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-1\" } } }, { \"sku\": \"SKU-2\", \"quantity\": 2, \"addedAt\": \"2020-11-04T09:40:12.341Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } } ] } { \"lineItems\": [ { \"id\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"variant\": { \"sku\": \"SKU-2\" }, \"quantity\": 2, \"custom\": { \"type\": { \"id\": \"4796e155-f5a4-403a-ae1a-04b10c9dfc54\", \"obj\": { \"key\": \"custom-type-for-shoppinglists\" } }, \"fields\": { \"textField\": \"text-2\" } }, \"addedAt\": \"2020-11-04T09:38:35.571Z\" } ] } Analysis Draft has line items with SKU-1 and SKU-2 . In the target project line item with SKU-2 exists, so SKU-1 is a new line item. So we need to create an AddLineItem action and a Change LineItems Order of the line items SKU-1 and SKU-2 , because when we add line item with SKU-1 the order will be SKU-2 and SKU-1 . The challenge in here is, those actions can not be added in one request because we don't know the line item id of the new line item with SKU-1 , so we need to find another way to create a new line item with the right order. Proposed solution Normally, for a difference, we might do a set intersection and then calculate action for differences, but that does not make sense because we are not aware of the order from the draft. So in this case the one request could be created but we might need to remove line item with SKU-2 and line items in the draft with the given order with the line items SKU-1 and SKU-2 . { \"version\": 1, \"actions\": [ { \"action\": \"removeLineItem\", \"lineItemId\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\" }, { \"action\": \"addLineItem\", \"sku\": \"SKU-1\", \"quantity\": 1, \"addedAt\": \"2020-11-04T09:38:35.571Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-1\" } } }, { \"action\": \"addLineItem\", \"sku\": \"SKU-2\", \"quantity\": 2, \"addedAt\": \"2020-11-04T09:40:12.341Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } } ] } Do we need to remove all line items when the order changes ? \u00b6 LineItemDrafts LineItems { \"lineItems\": [ { \"sku\": \"SKU-1\", \"quantity\": 1, \"addedAt\": \"2020-11-04T09:38:35.571Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-1\" } } }, { \"sku\": \"SKU-3\", \"quantity\": 3, \"addedAt\": \"2020-11-05T10:00:10.101Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-3\" } } }, { \"sku\": \"SKU-2\", \"quantity\": 2, \"addedAt\": \"2020-11-04T09:40:12.341Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } } ] } { \"lineItems\": [ { \"id\": \"1c38d582-2e65-43f8-85db-4d34e6cff57a\", \"variant\": { \"sku\": \"SKU-1\" }, \"quantity\": 1, \"custom\": { \"type\": { \"id\": \"4796e155-f5a4-403a-ae1a-04b10c9dfc54\", \"obj\": { \"key\": \"custom-type-for-shoppinglists\" } }, \"fields\": { \"textField\": \"text-1\" } }, \"addedAt\": \"2020-11-04T09:38:35.571Z\" }, { \"id\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"variant\": { \"sku\": \"SKU-2\" }, \"quantity\": 2, \"custom\": { \"type\": { \"id\": \"4796e155-f5a4-403a-ae1a-04b10c9dfc54\", \"obj\": { \"key\": \"custom-type-for-shoppinglists\" } }, \"fields\": { \"textField\": \"text-2\" } }, \"addedAt\": \"2020-11-04T09:40:12.341Z\" } ] } Analysis Draft has line items with SKU-1 , SKU-3 and SKU-2 also in target project line item with SKU-1 exists in the same order, SKU-3 is a new line item, and SKU-2 needs to be in last order. So we need to create an AddLineItem action and a Change LineItems Order of the line items SKU-2 and SKU-3 , because when we add line item with SKU-3 the order will be SKU-1 , SKU-2 and SKU-3 . The challenge in here is, those actions can not be added in one request because we don't know the line item id of the new line item with SKU-3 , so we need to find another way to create a new line item with the right order. Also another challenge in here is about the line item with SKU-1 , as the order and data is exactly same, we need to find a better way to avoid creating unnecessary actions. Proposed solution The solution idea about the new line item and changed order is still same like in the case-1. Do we need to remove and add line item with SKU-1 ? No, it is not needed and we could start the removing and adding from the first order change. { \"version\": 1, \"actions\": [ { \"action\": \"removeLineItem\", \"lineItemId\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\" }, { \"action\": \"addLineItem\", \"sku\": \"SKU-3\", \"quantity\": 3, \"addedAt\": \"2020-11-05T10:00:10.101Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-3\" } } }, { \"action\": \"addLineItem\", \"sku\": \"SKU-2\", \"quantity\": 2, \"addedAt\": \"2020-11-04T09:40:12.341Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } } ] } Do we need to remove and add all line items when no new line item is added or removed, just order is different ? \u00b6 LineItemDrafts LineItems { \"lineItems\": [ { \"sku\": \"SKU-2\", \"quantity\": 2, \"addedAt\": \"2020-11-05T10:00:10.101Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } }, { \"sku\": \"SKU-1\", \"quantity\": 1, \"addedAt\": \"2020-11-04T09:38:35.571Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-1\" } } } ] } { \"lineItems\": [ { \"id\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"variant\": { \"sku\": \"SKU-1\" }, \"quantity\": 1, \"custom\": { \"type\": { \"id\": \"4796e155-f5a4-403a-ae1a-04b10c9dfc54\", \"obj\": { \"key\": \"custom-type-for-shoppinglists\" } }, \"fields\": { \"textField\": \"text-1\" } }, \"addedAt\": \"2020-11-04T09:38:35.571Z\" }, { \"id\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"variant\": { \"sku\": \"SKU-2\" }, \"quantity\": 2, \"custom\": { \"type\": { \"id\": \"4796e155-f5a4-403a-ae1a-04b10c9dfc54\", \"obj\": { \"key\": \"custom-type-for-shoppinglists\" } }, \"fields\": { \"textField\": \"text-2\" } }, \"addedAt\": \"2020-11-04T09:40:12.341Z\" } ] } Analysis The Draft has line items with SKU-2 and SKU-1 also in target project line item with SKU-2 and SKU-1 exists but in a different order. So we need a Change LineItems Order of the line items with order SKU-2 and SKU-1 . The challenge here is about the line item order and no new line item is added or removed, just order is different, so we need to find a better way to avoid creating unnecessary actions like removing and adding back, is this possible ? Proposed solution The solution idea for the changing order with removing and adding back looks like an overhead. We know all line item ids, so change order action could be created. However, the challenge is finding an algorithm to compare and find the line item ids, and then prepare an order. The example above seems reasonable but how you would sync a case like: [SKU-1, SKU-2, SKU-3] to [SKU-3, SKU-1, SKU-4, SKU-2] , so with a different algorithm it might be done with change order [line-item-id-3, line-item-id-1, line-item-id-2] then removeLineItem SKU-2 , add back addLineItem SKU-4 , in total 3 actions. Even for this we need to remove and add back. It looks like there are more different cases, when we dig in. That's why we decided to keep the idea of removing and adding back to not have a more complex algorithm. TextLineItems \u00b6 How to ensure text line item order? \u00b6 TextLineItemDrafts TextLineItems { \"textLineItems\": [ { \"name\": { \"de\": \"name1-DE\", \"en\": \"name1-EN\" }, \"description\": { \"de\": \"desc1-DE\", \"en\": \"desc1-EN\" }, \"quantity\": 1, \"addedAt\": \"2020-11-04T09:38:35.571Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-1\" } } }, { \"name\": { \"de\": \"name2-DE\", \"en\": \"name2-EN\" }, \"description\": { \"de\": \"desc2-DE\", \"en\": \"desc2-EN\" }, \"quantity\": 2, \"addedAt\": \"2020-11-04T09:40:12.341Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } } ] } { \"textLineItems\": [ { \"id\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"name\": { \"de\": \"name2-DE\", \"en\": \"name2-EN\" }, \"description\": { \"de\": \"desc2-DE\", \"en\": \"desc2-EN\" }, \"quantity\": 2, \"custom\": { \"type\": { \"id\": \"4796e155-f5a4-403a-ae1a-04b10c9dfc54\", \"obj\": { \"key\": \"custom-type-for-shoppinglists\" } }, \"fields\": { \"textField\": \"text-2\" } }, \"addedAt\": \"2020-11-04T09:38:35.571Z\" } ] } Analysis Draft has text line items with name-1 and name-2 . In the target project text line item with name-2 exists, so name-1 is a new text line item. So we need to create an AddTextLineItem action and a Change TextLineItems Order of the text line items name-1 and name-2 , because when we add text line item with name-1 the order will be name-2 and name-1 . The challenge in here is, those actions cannot be added in one request because we don't know the text line item id of the new text line item with name-1 . We need to find another way to create a new text line item with the right order. Proposed solution Normally, for a difference, we do a set intersection and then calculate action for differences, but that does not make sense because we are not aware of the order from the draft. Before that, we need to analyse the AddTextLineItem action, because the platform is not checking if the data exist. An API user could add the exact same data multiple times. So it's impossible to know the order by just checking the differences between the resource and draft object. Also, the name of the text line item does not need to be unique as line item does. Each line item is identified by its product variant and custom fields. Luckily the platform supports changing all field (except addedAt ) of the text line items, so when an order change is needed we update the fields of the text line items. Which will look like: { \"version\": 1, \"actions\": [ { \"action\" : \"changeTextLineItemName\", \"textLineItemId\" : \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"name\": { \"de\": \"name1-DE\", \"en\": \"name1-EN\" } }, { \"action\" : \"changeTextLineItemQuantity\", \"textLineItemId\" : \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"quantity\" : 1 }, { \"action\" : \"setTextLineItemDescription\", \"textLineItemId\" : \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"description\": { \"de\": \"desc1-DE\", \"en\": \"desc1-EN\" } }, { \"action\" : \"setTextLineItemCustomField\", \"textLineItemId\" : \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"name\" : \"textField\", \"value\" : \"text-1\" }, { \"action\" : \"addTextLineItem\", \"name\": { \"de\": \"name2-DE\", \"en\": \"name2-EN\" }, \"description\": { \"de\": \"desc2-DE\", \"en\": \"desc2-EN\" }, \"quantity\": 2, \"addedAt\": \"2020-11-04T09:38:35.571Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } } ] } Common \u00b6 How addedAt will be compared? \u00b6 In commercetools shopping lists API, there is no update action to change the addedAt field of the LineItem and TextLineItem , also in API it has a default value described as Defaults to the current date and time. , when it's not set in the draft, so how to compare and update this field? Proposed solution: The addedAt field will be synced only if the value provided in the line item draft, otherwise, the addedAt value will be omitted. To be able to sync it we need to remove and add this line item back with the up-to-date value. After some discussions in pull requests, we decided to not change this field. Decision \u00b6 In commercetools API, the product variant to be selected in the LineItemDraft can be specified either by its product ID plus variant ID or by its SKU. For the sync library, product variant will be matched by its SKU, if the SKU not set for a LineItemDraft, the draft will not be synced and an error callback will be triggered. Check LineItemDraft Product Variant Selection for more details. When a Change LineItems Order action is needed, the line items will be removed and added back with the order provided in the ShoppingListDraft . When a Change TextLineItems Order action is needed, the text line items will be updated with using update actions with the order provided in the ShoppingListDraft . In commercetools shopping lists API, there is no update action to change the addedAt field of the LineItem and TextLineItem , hereby we will not update the addedAt value. Consequences \u00b6 To ensure the order of the line items, we need to remove and add line items. That means a bigger payload and a performance overhead. To ensure the order of text line items, we need to calculate and update more than expected. That means a bigger payload and a performance overhead. Caveat : addedAt values not synced.","title":"2. LineItem and TextLineItem update actions of the ShoppingLists."},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#2-lineitem-and-textlineitem-update-actions-of-the-shoppinglists","text":"Date: 2020-11-04","title":"2. LineItem and TextLineItem update actions of the ShoppingLists."},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#status","text":"Approved","title":"Status"},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#context","text":"In a commerce application, a shopping list is a personal wishlist of a customer, (i.e. ingredients for a recipe, birthday wishes). Shopping lists hold line items of products in the platform or any other items that can be described as text line items. We have challenges to build update actions of the LineItem and TextLineItem because of the nature of the synchronization, so in this document, we will describe the reasons and constraints, mostly related to order of the items: - LineItem orders might be important, if the customer has a front end that sorts the line items with their order could mean sorting by importance.","title":"Context"},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#lineitems","text":"","title":"LineItems"},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#how-to-ensure-line-item-order","text":"LineItemDrafts LineItems { \"lineItems\": [ { \"sku\": \"SKU-1\", \"quantity\": 1, \"addedAt\": \"2020-11-04T09:38:35.571Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-1\" } } }, { \"sku\": \"SKU-2\", \"quantity\": 2, \"addedAt\": \"2020-11-04T09:40:12.341Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } } ] } { \"lineItems\": [ { \"id\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"variant\": { \"sku\": \"SKU-2\" }, \"quantity\": 2, \"custom\": { \"type\": { \"id\": \"4796e155-f5a4-403a-ae1a-04b10c9dfc54\", \"obj\": { \"key\": \"custom-type-for-shoppinglists\" } }, \"fields\": { \"textField\": \"text-2\" } }, \"addedAt\": \"2020-11-04T09:38:35.571Z\" } ] } Analysis Draft has line items with SKU-1 and SKU-2 . In the target project line item with SKU-2 exists, so SKU-1 is a new line item. So we need to create an AddLineItem action and a Change LineItems Order of the line items SKU-1 and SKU-2 , because when we add line item with SKU-1 the order will be SKU-2 and SKU-1 . The challenge in here is, those actions can not be added in one request because we don't know the line item id of the new line item with SKU-1 , so we need to find another way to create a new line item with the right order. Proposed solution Normally, for a difference, we might do a set intersection and then calculate action for differences, but that does not make sense because we are not aware of the order from the draft. So in this case the one request could be created but we might need to remove line item with SKU-2 and line items in the draft with the given order with the line items SKU-1 and SKU-2 . { \"version\": 1, \"actions\": [ { \"action\": \"removeLineItem\", \"lineItemId\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\" }, { \"action\": \"addLineItem\", \"sku\": \"SKU-1\", \"quantity\": 1, \"addedAt\": \"2020-11-04T09:38:35.571Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-1\" } } }, { \"action\": \"addLineItem\", \"sku\": \"SKU-2\", \"quantity\": 2, \"addedAt\": \"2020-11-04T09:40:12.341Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } } ] }","title":"How to ensure line item order?"},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#do-we-need-to-remove-all-line-items-when-the-order-changes","text":"LineItemDrafts LineItems { \"lineItems\": [ { \"sku\": \"SKU-1\", \"quantity\": 1, \"addedAt\": \"2020-11-04T09:38:35.571Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-1\" } } }, { \"sku\": \"SKU-3\", \"quantity\": 3, \"addedAt\": \"2020-11-05T10:00:10.101Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-3\" } } }, { \"sku\": \"SKU-2\", \"quantity\": 2, \"addedAt\": \"2020-11-04T09:40:12.341Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } } ] } { \"lineItems\": [ { \"id\": \"1c38d582-2e65-43f8-85db-4d34e6cff57a\", \"variant\": { \"sku\": \"SKU-1\" }, \"quantity\": 1, \"custom\": { \"type\": { \"id\": \"4796e155-f5a4-403a-ae1a-04b10c9dfc54\", \"obj\": { \"key\": \"custom-type-for-shoppinglists\" } }, \"fields\": { \"textField\": \"text-1\" } }, \"addedAt\": \"2020-11-04T09:38:35.571Z\" }, { \"id\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"variant\": { \"sku\": \"SKU-2\" }, \"quantity\": 2, \"custom\": { \"type\": { \"id\": \"4796e155-f5a4-403a-ae1a-04b10c9dfc54\", \"obj\": { \"key\": \"custom-type-for-shoppinglists\" } }, \"fields\": { \"textField\": \"text-2\" } }, \"addedAt\": \"2020-11-04T09:40:12.341Z\" } ] } Analysis Draft has line items with SKU-1 , SKU-3 and SKU-2 also in target project line item with SKU-1 exists in the same order, SKU-3 is a new line item, and SKU-2 needs to be in last order. So we need to create an AddLineItem action and a Change LineItems Order of the line items SKU-2 and SKU-3 , because when we add line item with SKU-3 the order will be SKU-1 , SKU-2 and SKU-3 . The challenge in here is, those actions can not be added in one request because we don't know the line item id of the new line item with SKU-3 , so we need to find another way to create a new line item with the right order. Also another challenge in here is about the line item with SKU-1 , as the order and data is exactly same, we need to find a better way to avoid creating unnecessary actions. Proposed solution The solution idea about the new line item and changed order is still same like in the case-1. Do we need to remove and add line item with SKU-1 ? No, it is not needed and we could start the removing and adding from the first order change. { \"version\": 1, \"actions\": [ { \"action\": \"removeLineItem\", \"lineItemId\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\" }, { \"action\": \"addLineItem\", \"sku\": \"SKU-3\", \"quantity\": 3, \"addedAt\": \"2020-11-05T10:00:10.101Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-3\" } } }, { \"action\": \"addLineItem\", \"sku\": \"SKU-2\", \"quantity\": 2, \"addedAt\": \"2020-11-04T09:40:12.341Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } } ] }","title":"Do we need to remove all line items when the order changes ?"},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#do-we-need-to-remove-and-add-all-line-items-when-no-new-line-item-is-added-or-removed-just-order-is-different","text":"LineItemDrafts LineItems { \"lineItems\": [ { \"sku\": \"SKU-2\", \"quantity\": 2, \"addedAt\": \"2020-11-05T10:00:10.101Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } }, { \"sku\": \"SKU-1\", \"quantity\": 1, \"addedAt\": \"2020-11-04T09:38:35.571Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-1\" } } } ] } { \"lineItems\": [ { \"id\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"variant\": { \"sku\": \"SKU-1\" }, \"quantity\": 1, \"custom\": { \"type\": { \"id\": \"4796e155-f5a4-403a-ae1a-04b10c9dfc54\", \"obj\": { \"key\": \"custom-type-for-shoppinglists\" } }, \"fields\": { \"textField\": \"text-1\" } }, \"addedAt\": \"2020-11-04T09:38:35.571Z\" }, { \"id\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"variant\": { \"sku\": \"SKU-2\" }, \"quantity\": 2, \"custom\": { \"type\": { \"id\": \"4796e155-f5a4-403a-ae1a-04b10c9dfc54\", \"obj\": { \"key\": \"custom-type-for-shoppinglists\" } }, \"fields\": { \"textField\": \"text-2\" } }, \"addedAt\": \"2020-11-04T09:40:12.341Z\" } ] } Analysis The Draft has line items with SKU-2 and SKU-1 also in target project line item with SKU-2 and SKU-1 exists but in a different order. So we need a Change LineItems Order of the line items with order SKU-2 and SKU-1 . The challenge here is about the line item order and no new line item is added or removed, just order is different, so we need to find a better way to avoid creating unnecessary actions like removing and adding back, is this possible ? Proposed solution The solution idea for the changing order with removing and adding back looks like an overhead. We know all line item ids, so change order action could be created. However, the challenge is finding an algorithm to compare and find the line item ids, and then prepare an order. The example above seems reasonable but how you would sync a case like: [SKU-1, SKU-2, SKU-3] to [SKU-3, SKU-1, SKU-4, SKU-2] , so with a different algorithm it might be done with change order [line-item-id-3, line-item-id-1, line-item-id-2] then removeLineItem SKU-2 , add back addLineItem SKU-4 , in total 3 actions. Even for this we need to remove and add back. It looks like there are more different cases, when we dig in. That's why we decided to keep the idea of removing and adding back to not have a more complex algorithm.","title":"Do we need to remove and add all line items when no new line item is added or removed, just order is different ?"},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#textlineitems","text":"","title":"TextLineItems"},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#how-to-ensure-text-line-item-order","text":"TextLineItemDrafts TextLineItems { \"textLineItems\": [ { \"name\": { \"de\": \"name1-DE\", \"en\": \"name1-EN\" }, \"description\": { \"de\": \"desc1-DE\", \"en\": \"desc1-EN\" }, \"quantity\": 1, \"addedAt\": \"2020-11-04T09:38:35.571Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-1\" } } }, { \"name\": { \"de\": \"name2-DE\", \"en\": \"name2-EN\" }, \"description\": { \"de\": \"desc2-DE\", \"en\": \"desc2-EN\" }, \"quantity\": 2, \"addedAt\": \"2020-11-04T09:40:12.341Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } } ] } { \"textLineItems\": [ { \"id\": \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"name\": { \"de\": \"name2-DE\", \"en\": \"name2-EN\" }, \"description\": { \"de\": \"desc2-DE\", \"en\": \"desc2-EN\" }, \"quantity\": 2, \"custom\": { \"type\": { \"id\": \"4796e155-f5a4-403a-ae1a-04b10c9dfc54\", \"obj\": { \"key\": \"custom-type-for-shoppinglists\" } }, \"fields\": { \"textField\": \"text-2\" } }, \"addedAt\": \"2020-11-04T09:38:35.571Z\" } ] } Analysis Draft has text line items with name-1 and name-2 . In the target project text line item with name-2 exists, so name-1 is a new text line item. So we need to create an AddTextLineItem action and a Change TextLineItems Order of the text line items name-1 and name-2 , because when we add text line item with name-1 the order will be name-2 and name-1 . The challenge in here is, those actions cannot be added in one request because we don't know the text line item id of the new text line item with name-1 . We need to find another way to create a new text line item with the right order. Proposed solution Normally, for a difference, we do a set intersection and then calculate action for differences, but that does not make sense because we are not aware of the order from the draft. Before that, we need to analyse the AddTextLineItem action, because the platform is not checking if the data exist. An API user could add the exact same data multiple times. So it's impossible to know the order by just checking the differences between the resource and draft object. Also, the name of the text line item does not need to be unique as line item does. Each line item is identified by its product variant and custom fields. Luckily the platform supports changing all field (except addedAt ) of the text line items, so when an order change is needed we update the fields of the text line items. Which will look like: { \"version\": 1, \"actions\": [ { \"action\" : \"changeTextLineItemName\", \"textLineItemId\" : \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"name\": { \"de\": \"name1-DE\", \"en\": \"name1-EN\" } }, { \"action\" : \"changeTextLineItemQuantity\", \"textLineItemId\" : \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"quantity\" : 1 }, { \"action\" : \"setTextLineItemDescription\", \"textLineItemId\" : \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"description\": { \"de\": \"desc1-DE\", \"en\": \"desc1-EN\" } }, { \"action\" : \"setTextLineItemCustomField\", \"textLineItemId\" : \"24de3821-e27d-4ddb-bd0b-ecc99365285f\", \"name\" : \"textField\", \"value\" : \"text-1\" }, { \"action\" : \"addTextLineItem\", \"name\": { \"de\": \"name2-DE\", \"en\": \"name2-EN\" }, \"description\": { \"de\": \"desc2-DE\", \"en\": \"desc2-EN\" }, \"quantity\": 2, \"addedAt\": \"2020-11-04T09:38:35.571Z\", \"custom\": { \"type\": { \"key\": \"custom-type-for-shoppinglists\" }, \"fields\": { \"textField\": \"text-2\" } } } ] }","title":"How to ensure text line item order?"},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#common","text":"","title":"Common"},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#how-addedat-will-be-compared","text":"In commercetools shopping lists API, there is no update action to change the addedAt field of the LineItem and TextLineItem , also in API it has a default value described as Defaults to the current date and time. , when it's not set in the draft, so how to compare and update this field? Proposed solution: The addedAt field will be synced only if the value provided in the line item draft, otherwise, the addedAt value will be omitted. To be able to sync it we need to remove and add this line item back with the up-to-date value. After some discussions in pull requests, we decided to not change this field.","title":"How addedAt will be compared?"},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#decision","text":"In commercetools API, the product variant to be selected in the LineItemDraft can be specified either by its product ID plus variant ID or by its SKU. For the sync library, product variant will be matched by its SKU, if the SKU not set for a LineItemDraft, the draft will not be synced and an error callback will be triggered. Check LineItemDraft Product Variant Selection for more details. When a Change LineItems Order action is needed, the line items will be removed and added back with the order provided in the ShoppingListDraft . When a Change TextLineItems Order action is needed, the text line items will be updated with using update actions with the order provided in the ShoppingListDraft . In commercetools shopping lists API, there is no update action to change the addedAt field of the LineItem and TextLineItem , hereby we will not update the addedAt value.","title":"Decision"},{"location":"adr/0002-shopping-lists-lineitem-and-textlineitem-update-actions/#consequences","text":"To ensure the order of the line items, we need to remove and add line items. That means a bigger payload and a performance overhead. To ensure the order of text line items, we need to calculate and update more than expected. That means a bigger payload and a performance overhead. Caveat : addedAt values not synced.","title":"Consequences"},{"location":"adr/0003-syncing-attribute-type-changes/","text":"3. Syncing attribute type changes \u00b6 Date: 2021-09-28 Status \u00b6 Approved . Context \u00b6 When changing an attribute definition type, we were using the approach by removing and re-adding the attribute with a new type but this approach is not working anymore. See: #762 So when removing and adding an attribute from a productType in a single request the API returns: \"code\" : \"AttributeDefinitionAlreadyExists\", \"message\" : \"An attribute definition with name 'attr_name_1' already exists on product type 'newName'.\", We've discussed 3 different approaches to resolve the issue: Change the logic to apply remove action only and after that throw and just document as limitation that such errors can happen but if they run same import again later it should at some point work. Change the logic to apply remove action only and after that try apply re-add: handle specific error with a retry (exponential + backoff) with up to x retries. Check if attribute with the same name id deleted and added in the same request and skip the update with triggering error callback with a message to ask the user to handle it manually. Decision \u00b6 The third approach is favoured due to the unpredictability of the other approaches since removeAttributeDefinition action is eventually consistent now and only takes place after the corresponding attribute has been removed from all the products asynchronously by the platform. Best practice to change type \u00b6 Changes to attributes should be planned carefully and implemented with an understanding of the impact on the product data and performance for each change. Ensure product attributes of the same name are defined consistently across all product types. Allow time between attribute removal and the addition of attributes with the same name. Removal and addition actions of the attribute with the same name should be applied in separate requests. Consequences \u00b6 Support of changing the attribute type within a single API request is not supported anymore.","title":"3. Syncing attribute type changes"},{"location":"adr/0003-syncing-attribute-type-changes/#3-syncing-attribute-type-changes","text":"Date: 2021-09-28","title":"3. Syncing attribute type changes"},{"location":"adr/0003-syncing-attribute-type-changes/#status","text":"Approved .","title":"Status"},{"location":"adr/0003-syncing-attribute-type-changes/#context","text":"When changing an attribute definition type, we were using the approach by removing and re-adding the attribute with a new type but this approach is not working anymore. See: #762 So when removing and adding an attribute from a productType in a single request the API returns: \"code\" : \"AttributeDefinitionAlreadyExists\", \"message\" : \"An attribute definition with name 'attr_name_1' already exists on product type 'newName'.\", We've discussed 3 different approaches to resolve the issue: Change the logic to apply remove action only and after that throw and just document as limitation that such errors can happen but if they run same import again later it should at some point work. Change the logic to apply remove action only and after that try apply re-add: handle specific error with a retry (exponential + backoff) with up to x retries. Check if attribute with the same name id deleted and added in the same request and skip the update with triggering error callback with a message to ask the user to handle it manually.","title":"Context"},{"location":"adr/0003-syncing-attribute-type-changes/#decision","text":"The third approach is favoured due to the unpredictability of the other approaches since removeAttributeDefinition action is eventually consistent now and only takes place after the corresponding attribute has been removed from all the products asynchronously by the platform.","title":"Decision"},{"location":"adr/0003-syncing-attribute-type-changes/#best-practice-to-change-type","text":"Changes to attributes should be planned carefully and implemented with an understanding of the impact on the product data and performance for each change. Ensure product attributes of the same name are defined consistently across all product types. Allow time between attribute removal and the addition of attributes with the same name. Removal and addition actions of the attribute with the same name should be applied in separate requests.","title":"Best practice to change type"},{"location":"adr/0003-syncing-attribute-type-changes/#consequences","text":"Support of changing the attribute type within a single API request is not supported anymore.","title":"Consequences"},{"location":"usage/CART_DISCOUNT_SYNC/","text":"CartDiscount Sync \u00b6 The module used for importing/syncing CartDiscounts into a commercetools project. It also provides utilities for generating update actions based on the comparison of a CartDiscount against a CartDiscountDraft . Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync More examples of how to use the sync Build all update actions Build particular update action(s) Migration Guide Client configuration and creation Signature of CartDiscountSyncOptions Build CartDiscountDraft (syncing from external project) Query for Cart Discounts (syncing from CTP project) Caveats Usage \u00b6 Prerequisites \u00b6 ProjectApiRoot \u00b6 Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" ); Required Fields \u00b6 The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note CartDiscountDraft key Also, the cart discounts in the target project are expected to have the key fields set. Reference Resolution \u00b6 In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in the sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type custom.type ResourceIdentifier to a Type Note that a reference without the key field will be considered as an existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution. Syncing from a commercetools project \u00b6 When syncing from a source commercetools project, you can use toCartDiscountDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a CartDiscount to CartDiscountDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build a ByProjectKeyCartDiscountsGet for fetching cart discounts from a source CTP project without any references expanded for the sync: final ByProjectKeyCartDiscountsGet byProjectKeyCartDiscountsGet = client . cartDiscounts (). get (); // Query all cart discounts (NOTE this is just for example, please adjust your logic) final List < CartDiscount > cartDiscounts = QueryUtils . queryAll ( byProjectKeyCartDiscountsGet , ( cartDiscounts ) -> cartDiscounts ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the CartDiscount to CartDiscountDraft , Utils method toCartDiscountDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and cartDiscounts as parameters. For cache implementation, You can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from CartDiscount to CartDiscountDraft. With help of the cache same reference keys can be reused. CompletableFuture < List < CartDiscountDraft >> cartDiscountDrafts = CartDiscountTransformUtils . toCartDiscountDrafts ( client , referenceIdToKeyCache , cartDiscounts ); Syncing from an external resource \u00b6 When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final CartDiscountDraft cartDiscountDraft = CartDiscountDraftBuilder . of () . cartPredicate ( \"cartPredicate\" ) . name ( LocalizedString . ofEnglish ( \"foo\" )) . requiresDiscountCode ( true ) . sortOrder ( \"0.1\" ) . target ( CartDiscountTargetBuilder :: shippingBuilder ) . value ( CartDiscountValueAbsoluteDraftBuilder . of () . money ( MoneyBuilder . of () . centAmount ( 10L ) . currencyCode ( DefaultCurrencyUnits . EUR . getCurrencyCode ()) . build ()) . build ()) . key ( \"cart-discount-key\" ) . custom ( CustomFieldsDraftBuilder . of (). type ( typeResourceIdentifierBuilder -> typeResourceIdentifierBuilder . key ( \"type-key\" )). fields ( fieldContainerBuilder -> fieldContainerBuilder . values ( emptyMap ())). build ()) // note that custom type provided with key . build (); SyncOptions \u00b6 After the ProjectApiRoot is set up, a CartDiscountSyncOptions should be built as follows: // instantiating a CartDiscountSyncOptions final CartDiscountSyncOptions cartDiscountSyncOptions = CartDiscountSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations: errorCallback \u00b6 A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception cart discount draft from the source cart discount of the target project (only provided if an existing cart discount could be found) the update-actions, which failed (only provided if an existing cart discount could be found) final Logger logger = LoggerFactory . getLogger ( CartDiscountSync . class ); final CartDiscountSyncOptions cartDiscountSyncOptions = CartDiscountSyncOptionsBuilder . of ( sphereClient ) . errorCallback (( syncException , draft , cartDiscount , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build (); warningCallback \u00b6 A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception cart discount draft from the source cart discount of the target project (only provided if an existing cart discount could be found) final Logger logger = LoggerFactory . getLogger ( CartDiscountSync . class ); final CartDiscountSyncOptions cartDiscountSyncOptions = CartDiscountSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , cartDiscount , updateActions ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build (); beforeUpdateCallback \u00b6 During the sync process, if a target cart discount and a cart discount draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : cart discount draft from the source cart discount from the target project update actions that were calculated after comparing both final TriFunction < List < CartDiscountUpdateAction > , CartDiscountDraft , CartDiscount , List < CartDiscountUpdateAction >> beforeUpdateCartDiscountCallback = ( updateActions , newCartDiscountDraft , oldCartDiscount ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof CartDiscountChangeCartPredicateAction )) . collect ( Collectors . toList ()); final CartDiscountSyncOptions cartDiscountSyncOptions = CartDiscountSyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateCartDiscountCallback ). build (); beforeCreateCallback \u00b6 During the sync process, if a cart discount draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : cart discount draft that should be created Please refer to example in product sync document . batchSize \u00b6 A number that could be used to set the batch size with which cart discounts are fetched and processed, as cart discounts are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding cart discounts from the target project on the commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for cart discount sync. final CartDiscountSyncOptions cartDiscountSyncOptions = CartDiscountSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build (); cacheSize \u00b6 In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for cart discount sync. final CartDiscountSyncOptions cartDiscountSyncOptions = CartDiscountSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build (); Running the sync \u00b6 After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a cart discount sync final CartDiscountSync cartDiscountSync = new CartDiscountSync ( cartDiscountSyncOptions ); // execute the sync on your list of cart discounts CompletionStage < CartDiscountSyncStatistics > syncStatisticsStage = cartDiscountSync . sync ( cartDiscountDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a CartDiscountSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed cart discounts and the processing time of the last sync batch in different time units and in a human-readable format. final CartDiscountSyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 100 cart discounts were processed in total (11 created, 87 updated, 2 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied. More examples of how to use the sync \u00b6 Sync from another CTP project as a source . Sync from an external source . Make sure to read the Important Usage Tips for optimal performance. Build all update actions \u00b6 A utility method provided by the library to compare a CartDiscount with a new CartDiscountDraft and results in a list of cart discount update actions. List < CartDiscountUpdateAction > updateActions = CartDiscountSyncUtils . buildActions ( cartDiscount , cartDiscountDraft , cartDiscountSyncOptions ); Build particular update action(s) \u00b6 Utility methods provided by the library to compare the specific fields of a CartDiscount and a new CartDiscountDraft , and in turn builds the update action. One example is the buildChangeNameUpdateAction which compares names: Optional < CartDiscountUpdateAction > updateAction = CartDiscountUpdateActionUtils . buildChangeNameAction ( oldCartDiscount , cartDiscountDraft ); More examples of those utils for different cart discounts can be found here . Migration Guide \u00b6 The cart-discount-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies> Client configuration and creation \u00b6 For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document . Signature of CartDiscountSyncOptions \u00b6 As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with CartDiscount , CartDiscountDraft and CartDiscountUpdateAction from package com.commercetools.api.models.cart_discount.* Note: Type UpdateAction<CartDiscount> has changed to CartDiscountUpdateAction . Make sure you create and supply a specific CartDiscountUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a cart discount update action to change name taking the 'newName' of the cartDiscountDraft final Function < LocalizedString , CartDiscountUpdateAction > createBeforeUpdateAction = ( newName ) -> CartDiscountChangeNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < CartDiscountUpdateAction > , CartDiscountDraft , CartDiscount , List < CartDiscountUpdateAction >> beforeUpdateCartDiscountCallback = ( updateActions , newCartDiscountDraft , oldCartDiscount ) -> { final CartDiscountUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newCartDiscountDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; }; Build CartDiscountDraft (syncing from external project) \u00b6 The cartDiscount-sync expects a list of CartDiscountDraft s to process. If you use java-sync-library to sync your cart discounts from any external system into a commercetools platform project you have to convert your data into CTP compatible CartDiscountDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // CartDiscountDraftBuilder in v1 takes parameters 'name', 'cartPredicate', 'value', 'target', 'sortOrder', 'requiresDiscountCode' final CartDiscountDraft cartDiscountDraft = CartDiscountDraftBuilder . of ( ofEnglish ( \"name\" ), \"1 = 1\" , CartDiscountValue . ofAbsolute ( MoneyImpl . of ( 20 , EUR )), \"sku = \\\"0123456789\\\" or sku = \\\"0246891213\\\"\" , \"0.2\" , false ) . key ( \"key\" ) . active ( false ) . build () // CartDiscountDraftBuilder in v2 final CartDiscountDraft cartDiscountDraft = CartDiscountDraftBuilder . of () . name ( ofEnglish ( \"name\" )) . cartPredicate ( \"1 = 1\" ) . value ( CartDiscountValueAbsoluteDraftBuilder . of () . money ( CentPrecisionMoneyBuilder . of () . centAmount ( 20L ) . fractionDigits ( 0 ) . currencyCode ( DefaultCurrencyUnits . EUR . getCurrencyCode ()) . build () ) . build () ) . target ( \"sku = \\\"0123456789\\\" or sku = \\\"0246891213\\\"\" ) . sortOrder ( \"0.2\" ) . requiresDiscountCode ( false ) . key ( \"key\" ) . isActive ( false ) . build (); For more information, see the Guide to replace DraftBuilders . Query for Cart Discounts (syncing from CTP project) \u00b6 If you sync cart discounts between different commercetools projects you probably use CartDiscountTransformUtils#toCartDiscountDrafts to transform CartDiscount into CartDiscountDraft which can be used by the cartDiscount-sync. However, if you need to query Cart Discounts from a commercetools project instead of passing CartDiscountQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: CartDiscountQuery to fetch all cart discounts final CartDiscountQuery query = CartDiscountQuery . of (); final PagedQueryResult < CartDiscount > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all cart discounts in one line final CartDiscountPagedQueryResponse result = apiRoot . cart discounts (). get (). executeBlocking (). getBody (); Read more about querying resources. Caveats \u00b6 Syncing cart discounts with a CartDiscountValue of type giftLineItem is not supported yet. #411 .","title":"CartDiscount Sync"},{"location":"usage/CART_DISCOUNT_SYNC/#cartdiscount-sync","text":"The module used for importing/syncing CartDiscounts into a commercetools project. It also provides utilities for generating update actions based on the comparison of a CartDiscount against a CartDiscountDraft . Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync More examples of how to use the sync Build all update actions Build particular update action(s) Migration Guide Client configuration and creation Signature of CartDiscountSyncOptions Build CartDiscountDraft (syncing from external project) Query for Cart Discounts (syncing from CTP project) Caveats","title":"CartDiscount Sync"},{"location":"usage/CART_DISCOUNT_SYNC/#usage","text":"","title":"Usage"},{"location":"usage/CART_DISCOUNT_SYNC/#prerequisites","text":"","title":"Prerequisites"},{"location":"usage/CART_DISCOUNT_SYNC/#projectapiroot","text":"Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" );","title":"ProjectApiRoot"},{"location":"usage/CART_DISCOUNT_SYNC/#required-fields","text":"The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note CartDiscountDraft key Also, the cart discounts in the target project are expected to have the key fields set.","title":"Required Fields"},{"location":"usage/CART_DISCOUNT_SYNC/#reference-resolution","text":"In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in the sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type custom.type ResourceIdentifier to a Type Note that a reference without the key field will be considered as an existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution.","title":"Reference Resolution"},{"location":"usage/CART_DISCOUNT_SYNC/#syncing-from-a-commercetools-project","text":"When syncing from a source commercetools project, you can use toCartDiscountDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a CartDiscount to CartDiscountDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build a ByProjectKeyCartDiscountsGet for fetching cart discounts from a source CTP project without any references expanded for the sync: final ByProjectKeyCartDiscountsGet byProjectKeyCartDiscountsGet = client . cartDiscounts (). get (); // Query all cart discounts (NOTE this is just for example, please adjust your logic) final List < CartDiscount > cartDiscounts = QueryUtils . queryAll ( byProjectKeyCartDiscountsGet , ( cartDiscounts ) -> cartDiscounts ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the CartDiscount to CartDiscountDraft , Utils method toCartDiscountDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and cartDiscounts as parameters. For cache implementation, You can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from CartDiscount to CartDiscountDraft. With help of the cache same reference keys can be reused. CompletableFuture < List < CartDiscountDraft >> cartDiscountDrafts = CartDiscountTransformUtils . toCartDiscountDrafts ( client , referenceIdToKeyCache , cartDiscounts );","title":"Syncing from a commercetools project"},{"location":"usage/CART_DISCOUNT_SYNC/#syncing-from-an-external-resource","text":"When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final CartDiscountDraft cartDiscountDraft = CartDiscountDraftBuilder . of () . cartPredicate ( \"cartPredicate\" ) . name ( LocalizedString . ofEnglish ( \"foo\" )) . requiresDiscountCode ( true ) . sortOrder ( \"0.1\" ) . target ( CartDiscountTargetBuilder :: shippingBuilder ) . value ( CartDiscountValueAbsoluteDraftBuilder . of () . money ( MoneyBuilder . of () . centAmount ( 10L ) . currencyCode ( DefaultCurrencyUnits . EUR . getCurrencyCode ()) . build ()) . build ()) . key ( \"cart-discount-key\" ) . custom ( CustomFieldsDraftBuilder . of (). type ( typeResourceIdentifierBuilder -> typeResourceIdentifierBuilder . key ( \"type-key\" )). fields ( fieldContainerBuilder -> fieldContainerBuilder . values ( emptyMap ())). build ()) // note that custom type provided with key . build ();","title":"Syncing from an external resource"},{"location":"usage/CART_DISCOUNT_SYNC/#syncoptions","text":"After the ProjectApiRoot is set up, a CartDiscountSyncOptions should be built as follows: // instantiating a CartDiscountSyncOptions final CartDiscountSyncOptions cartDiscountSyncOptions = CartDiscountSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations:","title":"SyncOptions"},{"location":"usage/CART_DISCOUNT_SYNC/#errorcallback","text":"A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception cart discount draft from the source cart discount of the target project (only provided if an existing cart discount could be found) the update-actions, which failed (only provided if an existing cart discount could be found) final Logger logger = LoggerFactory . getLogger ( CartDiscountSync . class ); final CartDiscountSyncOptions cartDiscountSyncOptions = CartDiscountSyncOptionsBuilder . of ( sphereClient ) . errorCallback (( syncException , draft , cartDiscount , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"errorCallback"},{"location":"usage/CART_DISCOUNT_SYNC/#warningcallback","text":"A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception cart discount draft from the source cart discount of the target project (only provided if an existing cart discount could be found) final Logger logger = LoggerFactory . getLogger ( CartDiscountSync . class ); final CartDiscountSyncOptions cartDiscountSyncOptions = CartDiscountSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , cartDiscount , updateActions ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"warningCallback"},{"location":"usage/CART_DISCOUNT_SYNC/#beforeupdatecallback","text":"During the sync process, if a target cart discount and a cart discount draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : cart discount draft from the source cart discount from the target project update actions that were calculated after comparing both final TriFunction < List < CartDiscountUpdateAction > , CartDiscountDraft , CartDiscount , List < CartDiscountUpdateAction >> beforeUpdateCartDiscountCallback = ( updateActions , newCartDiscountDraft , oldCartDiscount ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof CartDiscountChangeCartPredicateAction )) . collect ( Collectors . toList ()); final CartDiscountSyncOptions cartDiscountSyncOptions = CartDiscountSyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateCartDiscountCallback ). build ();","title":"beforeUpdateCallback"},{"location":"usage/CART_DISCOUNT_SYNC/#beforecreatecallback","text":"During the sync process, if a cart discount draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : cart discount draft that should be created Please refer to example in product sync document .","title":"beforeCreateCallback"},{"location":"usage/CART_DISCOUNT_SYNC/#batchsize","text":"A number that could be used to set the batch size with which cart discounts are fetched and processed, as cart discounts are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding cart discounts from the target project on the commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for cart discount sync. final CartDiscountSyncOptions cartDiscountSyncOptions = CartDiscountSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build ();","title":"batchSize"},{"location":"usage/CART_DISCOUNT_SYNC/#cachesize","text":"In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for cart discount sync. final CartDiscountSyncOptions cartDiscountSyncOptions = CartDiscountSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build ();","title":"cacheSize"},{"location":"usage/CART_DISCOUNT_SYNC/#running-the-sync","text":"After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a cart discount sync final CartDiscountSync cartDiscountSync = new CartDiscountSync ( cartDiscountSyncOptions ); // execute the sync on your list of cart discounts CompletionStage < CartDiscountSyncStatistics > syncStatisticsStage = cartDiscountSync . sync ( cartDiscountDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a CartDiscountSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed cart discounts and the processing time of the last sync batch in different time units and in a human-readable format. final CartDiscountSyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 100 cart discounts were processed in total (11 created, 87 updated, 2 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied.","title":"Running the sync"},{"location":"usage/CART_DISCOUNT_SYNC/#more-examples-of-how-to-use-the-sync","text":"Sync from another CTP project as a source . Sync from an external source . Make sure to read the Important Usage Tips for optimal performance.","title":"More examples of how to use the sync"},{"location":"usage/CART_DISCOUNT_SYNC/#build-all-update-actions","text":"A utility method provided by the library to compare a CartDiscount with a new CartDiscountDraft and results in a list of cart discount update actions. List < CartDiscountUpdateAction > updateActions = CartDiscountSyncUtils . buildActions ( cartDiscount , cartDiscountDraft , cartDiscountSyncOptions );","title":"Build all update actions"},{"location":"usage/CART_DISCOUNT_SYNC/#build-particular-update-actions","text":"Utility methods provided by the library to compare the specific fields of a CartDiscount and a new CartDiscountDraft , and in turn builds the update action. One example is the buildChangeNameUpdateAction which compares names: Optional < CartDiscountUpdateAction > updateAction = CartDiscountUpdateActionUtils . buildChangeNameAction ( oldCartDiscount , cartDiscountDraft ); More examples of those utils for different cart discounts can be found here .","title":"Build particular update action(s)"},{"location":"usage/CART_DISCOUNT_SYNC/#migration-guide","text":"The cart-discount-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies>","title":"Migration Guide"},{"location":"usage/CART_DISCOUNT_SYNC/#client-configuration-and-creation","text":"For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document .","title":"Client configuration and creation"},{"location":"usage/CART_DISCOUNT_SYNC/#signature-of-cartdiscountsyncoptions","text":"As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with CartDiscount , CartDiscountDraft and CartDiscountUpdateAction from package com.commercetools.api.models.cart_discount.* Note: Type UpdateAction<CartDiscount> has changed to CartDiscountUpdateAction . Make sure you create and supply a specific CartDiscountUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a cart discount update action to change name taking the 'newName' of the cartDiscountDraft final Function < LocalizedString , CartDiscountUpdateAction > createBeforeUpdateAction = ( newName ) -> CartDiscountChangeNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < CartDiscountUpdateAction > , CartDiscountDraft , CartDiscount , List < CartDiscountUpdateAction >> beforeUpdateCartDiscountCallback = ( updateActions , newCartDiscountDraft , oldCartDiscount ) -> { final CartDiscountUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newCartDiscountDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; };","title":"Signature of CartDiscountSyncOptions"},{"location":"usage/CART_DISCOUNT_SYNC/#build-cartdiscountdraft-syncing-from-external-project","text":"The cartDiscount-sync expects a list of CartDiscountDraft s to process. If you use java-sync-library to sync your cart discounts from any external system into a commercetools platform project you have to convert your data into CTP compatible CartDiscountDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // CartDiscountDraftBuilder in v1 takes parameters 'name', 'cartPredicate', 'value', 'target', 'sortOrder', 'requiresDiscountCode' final CartDiscountDraft cartDiscountDraft = CartDiscountDraftBuilder . of ( ofEnglish ( \"name\" ), \"1 = 1\" , CartDiscountValue . ofAbsolute ( MoneyImpl . of ( 20 , EUR )), \"sku = \\\"0123456789\\\" or sku = \\\"0246891213\\\"\" , \"0.2\" , false ) . key ( \"key\" ) . active ( false ) . build () // CartDiscountDraftBuilder in v2 final CartDiscountDraft cartDiscountDraft = CartDiscountDraftBuilder . of () . name ( ofEnglish ( \"name\" )) . cartPredicate ( \"1 = 1\" ) . value ( CartDiscountValueAbsoluteDraftBuilder . of () . money ( CentPrecisionMoneyBuilder . of () . centAmount ( 20L ) . fractionDigits ( 0 ) . currencyCode ( DefaultCurrencyUnits . EUR . getCurrencyCode ()) . build () ) . build () ) . target ( \"sku = \\\"0123456789\\\" or sku = \\\"0246891213\\\"\" ) . sortOrder ( \"0.2\" ) . requiresDiscountCode ( false ) . key ( \"key\" ) . isActive ( false ) . build (); For more information, see the Guide to replace DraftBuilders .","title":"Build CartDiscountDraft (syncing from external project)"},{"location":"usage/CART_DISCOUNT_SYNC/#query-for-cart-discounts-syncing-from-ctp-project","text":"If you sync cart discounts between different commercetools projects you probably use CartDiscountTransformUtils#toCartDiscountDrafts to transform CartDiscount into CartDiscountDraft which can be used by the cartDiscount-sync. However, if you need to query Cart Discounts from a commercetools project instead of passing CartDiscountQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: CartDiscountQuery to fetch all cart discounts final CartDiscountQuery query = CartDiscountQuery . of (); final PagedQueryResult < CartDiscount > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all cart discounts in one line final CartDiscountPagedQueryResponse result = apiRoot . cart discounts (). get (). executeBlocking (). getBody (); Read more about querying resources.","title":"Query for Cart Discounts (syncing from CTP project)"},{"location":"usage/CART_DISCOUNT_SYNC/#caveats","text":"Syncing cart discounts with a CartDiscountValue of type giftLineItem is not supported yet. #411 .","title":"Caveats"},{"location":"usage/CATEGORY_SYNC/","text":"Category Sync \u00b6 Module used for importing/syncing Categories into a commercetools project. It also provides utilities for generating update actions based on the comparison of a Category against a CategoryDraft . Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Persistence of Category Drafts with irresolvable parent Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync More examples of how to use the sync Build all update actions Build particular update action(s) Migration Guide Client configuration and creation Signature of CategorySyncOptions Build CategoryDraft (syncing from external project) Query for Categories (syncing from CTP project) JVM-SDK-V2 migration guide Usage \u00b6 Prerequisites \u00b6 ProjectApiRoot \u00b6 Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" ); Required Fields \u00b6 The following fields are required to be set in, otherwise they won't be matched by sync: Draft Required Fields Note CategoryDraft key Also, the categories in the target project are expected to have the key fields set. Reference Resolution \u00b6 In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type parent CategoryResourceIdentifier custom.type TypeResourceIdentifier assets.custom.type TypeResourceIdentifier Note that a reference without the key field will be considered as existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution. Persistence of Category Drafts with irresolvable parent \u00b6 A CategoryDraft X could have a parent Category Y. But It could be that the parent Category Y is not supplied before X, which means the sync could fail to create/updating X. It could also be that Y is not supplied at all in this batch but at a later batch. The library keeps track of such \"referencing\" Category Drafts like X and persists them in storage ( Commercetools platform customObjects in the target project , in this case) to keep them and create/update them accordingly whenever the referenced drafts exist in the target project. The customObject will have a container: \"commercetools-sync-java.UnresolvedReferencesService.categoryDrafts\" and a key representing the key of the category Drafts that is waiting to be created/updated. Here is an example of a CustomObject in the target project that represents a category Draft with the key categoryKey1 . Being persisted as CustomObject means that the referenced parent Category with the key nonExistingParent does not exist yet. { \"id\" : \"81dcb42f-1959-4412-a4bb-8ad420d0d11f\" , \"version\" : 1 , \"createdAt\" : \"2021-01-13T12:19:45.937Z\" , \"lastModifiedAt\" : \"2021-01-13T12:19:45.937Z\" , \"lastModifiedBy\" : { \"clientId\" : \"7OSAGVPscneW_KS4nqskFkrd\" , \"isPlatformClient\" : false }, \"createdBy\" : { \"clientId\" : \"7OSAGVPscneW_KS4nqskFkrd\" , \"isPlatformClient\" : false }, \"container\" : \"commercetools-sync-java.UnresolvedReferencesService.categoryDrafts\" , \"key\" : \"8732a63fa8ca457e86f4075340d65154e7e2476a\" , \"value\" : { \"missingReferencedKeys\" : [ \"nonExistingParent\" ], \"waitingDraft\" : { \"custom\" : { \"type\" : { \"key\" : \"oldCategoryCustomTypeKey\" }, \"fields\" : { \"backgroundColor\" : { \"de\" : \"rot\" , \"en\" : \"red\" }, \"invisibleInShop\" : false } }, \"key\" : \"categoryKey1\" , \"name\" : { \"en\" : \"furniture\" }, \"parent\" : { \"key\" : \"nonExistingParent\" }, \"slug\" : { \"en\" : \"new-furniture1\" } } } } As soon, as the referenced parent Category Draft is supplied to the sync, the Category will be created/updated and the CustomObject will be removed from the target project. Syncing from a commercetools project \u00b6 When syncing from a source commercetools project, you can use toCategoryDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a Category to CategoryDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build ByProjectKeyCategoriesGet for fetching categories from a source CTP project without any references expanded for the sync: final ByProjectKeyCategoriesGet byProjectKeyCategoriesGet = client . categories (). get (); // Query all categories (NOTE this is just for example, please adjust your logic) final List < Categories > categories = QueryUtils . queryAll ( byProjectKeyCategoriesGet , ( categories ) -> categories ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the Category to CategoryDraft , Utils method toCategoryDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and categories as parameters. For cache implementation, You can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from Category to CategoryDraft. With help of the cache same reference keys can be reused. final CompletableFuture < List < CategoryDraft >> categoryDrafts = CategoryTransformUtils . toCategoryDrafts ( client , referenceIdToKeyCache , categories ); Syncing from an external resource \u00b6 When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final CategoryDraft categoryDraft = CategoryDraftBuilder . of ( ofEnglish ( \"name\" ), ofEnglish ( \"slug\" )) . parent ( ResourceIdentifier . ofKey ( \"parent-category-key\" )) // note that parent provided with key . custom ( CustomFieldsDraft . ofTypeKeyAndJson ( \"type-key\" , emptyMap ())) // note that custom type provided with key . assets ( singletonList ( AssetDraftBuilder . of ( emptyList (), LocalizedString . ofEnglish ( \"asset-name\" )) . custom ( CustomFieldsDraft . ofTypeKeyAndJson ( \"type-key\" , emptyMap ())) // note that custom type provided with key . key ( \"asset-key\" ) . build () )) . build (); final CustomFieldsDraft customFields = CustomFieldsDraftBuilder . of () . type ( TypeResourceIdentifierBuilder . of (). key ( \"type-key\" ). build ()) // note that custom type provided with key . fields ( FieldContainerBuilder . of (). values ( Collections . emptyMap ()). build ()) . build (); final CategoryResourceIdentifier categoryResourceIdentifier = CategoryResourceIdentifierBuilder . of () . key ( \"category-key\" ) . build (); final CategoryDraft categoryDraft = CategoryDraftBuilder . of () . key ( \"category-key\" ) . slug ( LocalizedString . of ( Locale . ENGLISH , \"category-slug\" )) . name ( LocalizedString . of ( Locale . ENGLISH , \"category-name\" )) . description ( LocalizedString . of ( Locale . ENGLISH , \"category-description\" )) . externalId ( \"external-id\" ) . metaDescription ( LocalizedString . of ( Locale . ENGLISH , \"meta-description\" )) . metaKeywords ( LocalizedString . of ( Locale . ENGLISH , \"meta-keywords\" )) . metaTitle ( LocalizedString . of ( Locale . ENGLISH , \"meta-title\" )) . orderHint ( \"order-hint\" ) . custom ( customFields ) . parent ( categoryResourceIdentifier ) . build () SyncOptions \u00b6 After the ProjectApiRoot is set up, a CategorySyncOptions should be built as follows: // instantiating a CategorySyncOptions final CategorySyncOptions categorySyncOptions = CategorySyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations: errorCallback \u00b6 A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When sync process of particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception category draft from the source category of the target project (only provided if an existing category could be found) the update-actions, which failed (only provided if an existing category could be found) final Logger logger = LoggerFactory . getLogger ( CategorySync . class ); final CategorySyncOptions categorySyncOptions = CategorySyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , category , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build (); warningCallback \u00b6 A callback that is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When sync process of particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception category draft from the source category of the target project (only provided if an existing category could be found) final Logger logger = LoggerFactory . getLogger ( CategorySync . class ); final CategorySyncOptions categorySyncOptions = CategorySyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , category , updateActions ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build (); beforeUpdateCallback \u00b6 During the sync process if a target category and a category draft are matched, this callback can be used to intercept the update request just before it is sent to commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : category draft from the source category from the target project update actions that were calculated after comparing both // Example: Ignore update actions that change category name final TriFunction < List < CategoryUpdateAction > , CategoryDraft , Category , List < CategoryUpdateAction >> beforeUpdateCategoryCallback = ( updateActions , newCategoryDraft , oldCategory ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof CategoryChangeNameAction )) . collect ( Collectors . toList ()); final CategorySyncOptions categorySyncOptions = CategorySyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateCategoryCallback ). build (); beforeCreateCallback \u00b6 During the sync process if a category draft should be created, this callback can be used to intercept the create request just before it is sent to commercetools platform. It contains following information : category draft that should be created Please refer to example in product sync document . batchSize \u00b6 A number that could be used to set the batch size with which categories are fetched and processed, as categories are obtained from the target project on commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding categories from the target project on commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for category sync. final CategorySyncOptions categorySyncOptions = CategorySyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build (); cacheSize \u00b6 In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. This cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for category sync. final CategorySyncOptions categorySyncOptions = CategorySyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build (); Running the sync \u00b6 After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a category sync final CategorySync categorySync = new CategorySync ( categorySyncOptions ); // execute the sync on your list of categories CompletionStage < CategorySyncStatistics > syncStatisticsStage = categorySync . sync ( categoryDrafts ); The result of the completing the syncStatisticsStage in the previous code snippet contains a CategorySyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed categories and the processing time of the last sync batch in different time units and in a human-readable format. final CategorySyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 2000 categories were processed in total (1000 created, 995 updated, 5 failed to sync and 0 categories with a missing parent).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied. More examples of how to use the sync \u00b6 Sync from another CTP project as a source . Sync from an external source . Make sure to read the Important Usage Tips for optimal performance. Build all update actions \u00b6 A utility method provided by the library to compare a Category with a new CategoryDraft and results in a list of category update actions. final List < CategoryUpdateAction > updateActions = CategorySyncUtils . buildActions ( category , categoryDraft , categorySyncOptions ); Examples of its usage can be found in the tests here . Build particular update action(s) \u00b6 Utility methods provided by the library to compare the specific fields of a Category and a new CategoryDraft, and in turn, build the update action. One example is the buildChangeNameUpdateAction which compares names: final Optional < CategoryUpdateAction > updateAction = CategoryUpdateActionUtils . buildChangeNameUpdateAction ( oldCategory , categoryDraft ); More examples of those utils for different fields can be found here . Migration Guide \u00b6 The category-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies> Client configuration and creation \u00b6 For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document . Signature of CategorySyncOptions \u00b6 As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with CategoryDraft , Category and CategoryUpdateAction from package com.commercetools.api.models.category.* Note: Type UpdateAction<Category> has changed to CategoryUpdateAction . Make sure you create and supply a specific CategoryUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a category update action to change name taking the 'newName' of the categoryDraft final Function < LocalizedString , CategoryUpdateAction > createBeforeUpdateAction = ( newName ) -> CategoryChangeNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < CategoryUpdateAction > , CategoryDraft , Category , List < CategoryUpdateAction >> beforeUpdateCategoryCallback = ( updateActions , newCategoryDraft , oldCategory ) -> { final CategoryUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newCategoryDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; }; Build CategoryDraft (syncing from external project) \u00b6 The category-sync expects a list of CategoryDraft s to process. If you use java-sync-library to sync your categories from any external system into a commercetools platform project you have to convert your data into CTP compatible CategoryDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // CategoryDraftBuilder in v1 takes parameters 'name' and 'slug' final CategoryDraft categoryDraft = CategoryDraftBuilder . of ( ofEnglish ( \"name\" ), ofEnglish ( \"slug\" )) . key ( \"category-key\" ) . build (); // CategoryDraftBuilder in v2 final CategoryDraft categoryDraft = CategoryDraftBuilder . of () . name ( LocalizedString . ofEnglish ( \"name\" )) . slug ( LocalizedString . ofEnglish ( \"slug\" )) . key ( \"category-key\" ) . build (); For more information, see the Guide to replace DraftBuilders . Query for Categories (syncing from CTP project) \u00b6 If you sync categories between different commercetools projects you probably use CategoryTransformUtils#toCategoryDrafts to transform Category into CategoryDraft which can be used by the category-sync. However, if you need to query Categories from a commercetools project instead of passing CategoryQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: CategoryQuery to fetch all categories final CategoryQuery query = CategoryQuery . of (); final PagedQueryResult < Category > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all categories in one line final CategoryPagedQueryResponse result = apiRoot . categories (). get (). executeBlocking (). getBody (); Read more about querying resources. JVM-SDK-V2 migration guide \u00b6 On any other needs to migrate your project using jvm-sdk-v2 please refer to it's Migration Guide .","title":"Category Sync"},{"location":"usage/CATEGORY_SYNC/#category-sync","text":"Module used for importing/syncing Categories into a commercetools project. It also provides utilities for generating update actions based on the comparison of a Category against a CategoryDraft . Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Persistence of Category Drafts with irresolvable parent Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync More examples of how to use the sync Build all update actions Build particular update action(s) Migration Guide Client configuration and creation Signature of CategorySyncOptions Build CategoryDraft (syncing from external project) Query for Categories (syncing from CTP project) JVM-SDK-V2 migration guide","title":"Category Sync"},{"location":"usage/CATEGORY_SYNC/#usage","text":"","title":"Usage"},{"location":"usage/CATEGORY_SYNC/#prerequisites","text":"","title":"Prerequisites"},{"location":"usage/CATEGORY_SYNC/#projectapiroot","text":"Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" );","title":"ProjectApiRoot"},{"location":"usage/CATEGORY_SYNC/#required-fields","text":"The following fields are required to be set in, otherwise they won't be matched by sync: Draft Required Fields Note CategoryDraft key Also, the categories in the target project are expected to have the key fields set.","title":"Required Fields"},{"location":"usage/CATEGORY_SYNC/#reference-resolution","text":"In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type parent CategoryResourceIdentifier custom.type TypeResourceIdentifier assets.custom.type TypeResourceIdentifier Note that a reference without the key field will be considered as existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution.","title":"Reference Resolution"},{"location":"usage/CATEGORY_SYNC/#persistence-of-category-drafts-with-irresolvable-parent","text":"A CategoryDraft X could have a parent Category Y. But It could be that the parent Category Y is not supplied before X, which means the sync could fail to create/updating X. It could also be that Y is not supplied at all in this batch but at a later batch. The library keeps track of such \"referencing\" Category Drafts like X and persists them in storage ( Commercetools platform customObjects in the target project , in this case) to keep them and create/update them accordingly whenever the referenced drafts exist in the target project. The customObject will have a container: \"commercetools-sync-java.UnresolvedReferencesService.categoryDrafts\" and a key representing the key of the category Drafts that is waiting to be created/updated. Here is an example of a CustomObject in the target project that represents a category Draft with the key categoryKey1 . Being persisted as CustomObject means that the referenced parent Category with the key nonExistingParent does not exist yet. { \"id\" : \"81dcb42f-1959-4412-a4bb-8ad420d0d11f\" , \"version\" : 1 , \"createdAt\" : \"2021-01-13T12:19:45.937Z\" , \"lastModifiedAt\" : \"2021-01-13T12:19:45.937Z\" , \"lastModifiedBy\" : { \"clientId\" : \"7OSAGVPscneW_KS4nqskFkrd\" , \"isPlatformClient\" : false }, \"createdBy\" : { \"clientId\" : \"7OSAGVPscneW_KS4nqskFkrd\" , \"isPlatformClient\" : false }, \"container\" : \"commercetools-sync-java.UnresolvedReferencesService.categoryDrafts\" , \"key\" : \"8732a63fa8ca457e86f4075340d65154e7e2476a\" , \"value\" : { \"missingReferencedKeys\" : [ \"nonExistingParent\" ], \"waitingDraft\" : { \"custom\" : { \"type\" : { \"key\" : \"oldCategoryCustomTypeKey\" }, \"fields\" : { \"backgroundColor\" : { \"de\" : \"rot\" , \"en\" : \"red\" }, \"invisibleInShop\" : false } }, \"key\" : \"categoryKey1\" , \"name\" : { \"en\" : \"furniture\" }, \"parent\" : { \"key\" : \"nonExistingParent\" }, \"slug\" : { \"en\" : \"new-furniture1\" } } } } As soon, as the referenced parent Category Draft is supplied to the sync, the Category will be created/updated and the CustomObject will be removed from the target project.","title":"Persistence of Category Drafts with irresolvable parent"},{"location":"usage/CATEGORY_SYNC/#syncing-from-a-commercetools-project","text":"When syncing from a source commercetools project, you can use toCategoryDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a Category to CategoryDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build ByProjectKeyCategoriesGet for fetching categories from a source CTP project without any references expanded for the sync: final ByProjectKeyCategoriesGet byProjectKeyCategoriesGet = client . categories (). get (); // Query all categories (NOTE this is just for example, please adjust your logic) final List < Categories > categories = QueryUtils . queryAll ( byProjectKeyCategoriesGet , ( categories ) -> categories ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the Category to CategoryDraft , Utils method toCategoryDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and categories as parameters. For cache implementation, You can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from Category to CategoryDraft. With help of the cache same reference keys can be reused. final CompletableFuture < List < CategoryDraft >> categoryDrafts = CategoryTransformUtils . toCategoryDrafts ( client , referenceIdToKeyCache , categories );","title":"Syncing from a commercetools project"},{"location":"usage/CATEGORY_SYNC/#syncing-from-an-external-resource","text":"When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final CategoryDraft categoryDraft = CategoryDraftBuilder . of ( ofEnglish ( \"name\" ), ofEnglish ( \"slug\" )) . parent ( ResourceIdentifier . ofKey ( \"parent-category-key\" )) // note that parent provided with key . custom ( CustomFieldsDraft . ofTypeKeyAndJson ( \"type-key\" , emptyMap ())) // note that custom type provided with key . assets ( singletonList ( AssetDraftBuilder . of ( emptyList (), LocalizedString . ofEnglish ( \"asset-name\" )) . custom ( CustomFieldsDraft . ofTypeKeyAndJson ( \"type-key\" , emptyMap ())) // note that custom type provided with key . key ( \"asset-key\" ) . build () )) . build (); final CustomFieldsDraft customFields = CustomFieldsDraftBuilder . of () . type ( TypeResourceIdentifierBuilder . of (). key ( \"type-key\" ). build ()) // note that custom type provided with key . fields ( FieldContainerBuilder . of (). values ( Collections . emptyMap ()). build ()) . build (); final CategoryResourceIdentifier categoryResourceIdentifier = CategoryResourceIdentifierBuilder . of () . key ( \"category-key\" ) . build (); final CategoryDraft categoryDraft = CategoryDraftBuilder . of () . key ( \"category-key\" ) . slug ( LocalizedString . of ( Locale . ENGLISH , \"category-slug\" )) . name ( LocalizedString . of ( Locale . ENGLISH , \"category-name\" )) . description ( LocalizedString . of ( Locale . ENGLISH , \"category-description\" )) . externalId ( \"external-id\" ) . metaDescription ( LocalizedString . of ( Locale . ENGLISH , \"meta-description\" )) . metaKeywords ( LocalizedString . of ( Locale . ENGLISH , \"meta-keywords\" )) . metaTitle ( LocalizedString . of ( Locale . ENGLISH , \"meta-title\" )) . orderHint ( \"order-hint\" ) . custom ( customFields ) . parent ( categoryResourceIdentifier ) . build ()","title":"Syncing from an external resource"},{"location":"usage/CATEGORY_SYNC/#syncoptions","text":"After the ProjectApiRoot is set up, a CategorySyncOptions should be built as follows: // instantiating a CategorySyncOptions final CategorySyncOptions categorySyncOptions = CategorySyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations:","title":"SyncOptions"},{"location":"usage/CATEGORY_SYNC/#errorcallback","text":"A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When sync process of particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception category draft from the source category of the target project (only provided if an existing category could be found) the update-actions, which failed (only provided if an existing category could be found) final Logger logger = LoggerFactory . getLogger ( CategorySync . class ); final CategorySyncOptions categorySyncOptions = CategorySyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , category , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"errorCallback"},{"location":"usage/CATEGORY_SYNC/#warningcallback","text":"A callback that is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When sync process of particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception category draft from the source category of the target project (only provided if an existing category could be found) final Logger logger = LoggerFactory . getLogger ( CategorySync . class ); final CategorySyncOptions categorySyncOptions = CategorySyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , category , updateActions ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"warningCallback"},{"location":"usage/CATEGORY_SYNC/#beforeupdatecallback","text":"During the sync process if a target category and a category draft are matched, this callback can be used to intercept the update request just before it is sent to commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : category draft from the source category from the target project update actions that were calculated after comparing both // Example: Ignore update actions that change category name final TriFunction < List < CategoryUpdateAction > , CategoryDraft , Category , List < CategoryUpdateAction >> beforeUpdateCategoryCallback = ( updateActions , newCategoryDraft , oldCategory ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof CategoryChangeNameAction )) . collect ( Collectors . toList ()); final CategorySyncOptions categorySyncOptions = CategorySyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateCategoryCallback ). build ();","title":"beforeUpdateCallback"},{"location":"usage/CATEGORY_SYNC/#beforecreatecallback","text":"During the sync process if a category draft should be created, this callback can be used to intercept the create request just before it is sent to commercetools platform. It contains following information : category draft that should be created Please refer to example in product sync document .","title":"beforeCreateCallback"},{"location":"usage/CATEGORY_SYNC/#batchsize","text":"A number that could be used to set the batch size with which categories are fetched and processed, as categories are obtained from the target project on commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding categories from the target project on commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for category sync. final CategorySyncOptions categorySyncOptions = CategorySyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build ();","title":"batchSize"},{"location":"usage/CATEGORY_SYNC/#cachesize","text":"In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. This cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for category sync. final CategorySyncOptions categorySyncOptions = CategorySyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build ();","title":"cacheSize"},{"location":"usage/CATEGORY_SYNC/#running-the-sync","text":"After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a category sync final CategorySync categorySync = new CategorySync ( categorySyncOptions ); // execute the sync on your list of categories CompletionStage < CategorySyncStatistics > syncStatisticsStage = categorySync . sync ( categoryDrafts ); The result of the completing the syncStatisticsStage in the previous code snippet contains a CategorySyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed categories and the processing time of the last sync batch in different time units and in a human-readable format. final CategorySyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 2000 categories were processed in total (1000 created, 995 updated, 5 failed to sync and 0 categories with a missing parent).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied.","title":"Running the sync"},{"location":"usage/CATEGORY_SYNC/#more-examples-of-how-to-use-the-sync","text":"Sync from another CTP project as a source . Sync from an external source . Make sure to read the Important Usage Tips for optimal performance.","title":"More examples of how to use the sync"},{"location":"usage/CATEGORY_SYNC/#build-all-update-actions","text":"A utility method provided by the library to compare a Category with a new CategoryDraft and results in a list of category update actions. final List < CategoryUpdateAction > updateActions = CategorySyncUtils . buildActions ( category , categoryDraft , categorySyncOptions ); Examples of its usage can be found in the tests here .","title":"Build all update actions"},{"location":"usage/CATEGORY_SYNC/#build-particular-update-actions","text":"Utility methods provided by the library to compare the specific fields of a Category and a new CategoryDraft, and in turn, build the update action. One example is the buildChangeNameUpdateAction which compares names: final Optional < CategoryUpdateAction > updateAction = CategoryUpdateActionUtils . buildChangeNameUpdateAction ( oldCategory , categoryDraft ); More examples of those utils for different fields can be found here .","title":"Build particular update action(s)"},{"location":"usage/CATEGORY_SYNC/#migration-guide","text":"The category-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies>","title":"Migration Guide"},{"location":"usage/CATEGORY_SYNC/#client-configuration-and-creation","text":"For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document .","title":"Client configuration and creation"},{"location":"usage/CATEGORY_SYNC/#signature-of-categorysyncoptions","text":"As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with CategoryDraft , Category and CategoryUpdateAction from package com.commercetools.api.models.category.* Note: Type UpdateAction<Category> has changed to CategoryUpdateAction . Make sure you create and supply a specific CategoryUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a category update action to change name taking the 'newName' of the categoryDraft final Function < LocalizedString , CategoryUpdateAction > createBeforeUpdateAction = ( newName ) -> CategoryChangeNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < CategoryUpdateAction > , CategoryDraft , Category , List < CategoryUpdateAction >> beforeUpdateCategoryCallback = ( updateActions , newCategoryDraft , oldCategory ) -> { final CategoryUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newCategoryDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; };","title":"Signature of CategorySyncOptions"},{"location":"usage/CATEGORY_SYNC/#build-categorydraft-syncing-from-external-project","text":"The category-sync expects a list of CategoryDraft s to process. If you use java-sync-library to sync your categories from any external system into a commercetools platform project you have to convert your data into CTP compatible CategoryDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // CategoryDraftBuilder in v1 takes parameters 'name' and 'slug' final CategoryDraft categoryDraft = CategoryDraftBuilder . of ( ofEnglish ( \"name\" ), ofEnglish ( \"slug\" )) . key ( \"category-key\" ) . build (); // CategoryDraftBuilder in v2 final CategoryDraft categoryDraft = CategoryDraftBuilder . of () . name ( LocalizedString . ofEnglish ( \"name\" )) . slug ( LocalizedString . ofEnglish ( \"slug\" )) . key ( \"category-key\" ) . build (); For more information, see the Guide to replace DraftBuilders .","title":"Build CategoryDraft (syncing from external project)"},{"location":"usage/CATEGORY_SYNC/#query-for-categories-syncing-from-ctp-project","text":"If you sync categories between different commercetools projects you probably use CategoryTransformUtils#toCategoryDrafts to transform Category into CategoryDraft which can be used by the category-sync. However, if you need to query Categories from a commercetools project instead of passing CategoryQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: CategoryQuery to fetch all categories final CategoryQuery query = CategoryQuery . of (); final PagedQueryResult < Category > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all categories in one line final CategoryPagedQueryResponse result = apiRoot . categories (). get (). executeBlocking (). getBody (); Read more about querying resources.","title":"Query for Categories (syncing from CTP project)"},{"location":"usage/CATEGORY_SYNC/#jvm-sdk-v2-migration-guide","text":"On any other needs to migrate your project using jvm-sdk-v2 please refer to it's Migration Guide .","title":"JVM-SDK-V2 migration guide"},{"location":"usage/CLEANUP_GUIDE/","text":"Cleanup of old unresolved reference custom objects \u00b6 TODO","title":"Cleanup Unresolved References"},{"location":"usage/CLEANUP_GUIDE/#cleanup-of-old-unresolved-reference-custom-objects","text":"TODO","title":"Cleanup of old unresolved reference custom objects"},{"location":"usage/CUSTOMER_SYNC/","text":"Customer Sync \u00b6 The module used for importing/syncing Customers into a commercetools project. It also provides utilities for generating update actions based on the comparison of a Customer against a CustomerDraft . Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync More examples of how to use the sync Build all update actions Build particular update action(s) Caveats Usage \u00b6 Prerequisites \u00b6 ProjectApiRoot \u00b6 Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" ); Required Fields \u00b6 The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note CustomerDraft key Also, the customers in the target project are expected to have the key fields set. CustomerDraft address.key Every customer BaseAddress needs a unique key to match the existing Address with the new AddressDraft . Reference Resolution \u00b6 In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in the sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type customerGroup CustomerGroupResourceIdentifier stores List of StoreResourceIdentifier custom.type TypeResourceIdentifier Note that a reference without the key field will be considered as an existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution. Syncing from a commercetools project \u00b6 When syncing from a source commercetools project, you can use toCustomerDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a Customer to CustomerDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build ByProjectKeyCustomersGet for fetching customers from a source CTP project without any references expanded for the sync: final ByProjectKeyCustomersGet byProjectKeyCustomersGet = client . customers (). get (); // Query all customers (NOTE this is just for example, please adjust your logic) final List < Customer > customers = QueryUtils . queryAll ( byProjectKeyCustomersGet , ( customers ) -> customers ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the Customer to CustomerDraft , Utils method toCustomerDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and customers as parameters. For cache implementation, You can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from Customer to CustomerDraft. With help of the cache same reference keys can be reused. CompletableFuture < List < CustomerDraft >> customerDrafts = CustomerTransformUtils . toCustomerDrafts ( client , referenceIdToKeyCache , customers ); Syncing from an external resource \u00b6 When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final CustomFieldsDraft customFields = CustomFieldsDraftBuilder . of () . type ( TypeResourceIdentifierBuilder . of (). key ( \"type-key\" ). build ()) // note that custom type provided with key . fields ( FieldContainerBuilder . of (). values ( Collections . emptyMap ()). build ()) . build (); final AddressDraft address = AddressDraftBuilder . of () . key ( \"address-key-1\" ) // note that addresses has to be provided with their keys . country ( \"DE\" ) . build (); final CustomerDraft customerDraft = CustomerDraftBuilder . of () . email ( \"email@example.com\" ) . password ( \"password\" ) . key ( \"customer-key\" ) . customerGroup ( CustomerGroupRescourceIdentifierBuilder . of (). key ( \"customer-group-key\" ). build ()) // note that customergroup reference provided with key . addresses ( address ) . custom ( customFields ) . stores ( StoresResourceIdentifierBuilder . of (). key ( \"store-key1\" ). build (), StoresResourceIdentifierBuilder . of (). key ( \"store-key2\" ). build ()) // note that store reference provided with key . build (); SyncOptions \u00b6 After the ProjectApiRoot is set up, a CustomerSyncOptions should be built as follows: // instantiating a CustomerSyncOptions final CustomerSyncOptions customerSyncOptions = CustomerSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations: errorCallback \u00b6 A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception customer draft from the source customer of the target project (only provided if an existing customer could be found) the update-actions, which failed (only provided if an existing customer could be found) final Logger logger = LoggerFactory . getLogger ( CustomerSync . class ); final CustomerSyncOptions customerSyncOptions = CustomerSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , customer , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build (); warningCallback \u00b6 A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception customer draft from the source customer of the target project (only provided if an existing customer could be found) final Logger logger = LoggerFactory . getLogger ( CustomerSync . class ); final CustomerSyncOptions customerSyncOptions = CustomerSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , customer ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build (); beforeUpdateCallback \u00b6 During the sync process, if a target customer and a customer draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : customer draft from the source customer from the target project update actions that were calculated after comparing both // Example: Ignore update actions which contain setting of lastName action final TriFunction < List < CustomerUpdateAction > , CustomerDraft , Customer , List < CustomerUpdateAction >> beforeUpdateCallback , = ( updateActions , newCustomerDraft , oldCustomer ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof CustomerSetLastNameActionImpl )) . collect ( Collectors . toList ()); final CustomerSyncOptions customerSyncOptions = CustomerSyncOptionsBuilder . of ( projectApiRoot ) . beforeUpdateCallback ( beforeUpdateCallback ) . build (); beforeCreateCallback \u00b6 During the sync process, if a customer draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : customer draft that should be created Please refer to the example in the product sync document . batchSize \u00b6 A number that could be used to set the batch size with which customers are fetched and processed, as customers are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding customers from the target project on the commercetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for customer sync. final CustomerSyncOptions customerSyncOptions = CustomerSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build (); cacheSize \u00b6 In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for customer sync. final CustomerSyncOptions customerSyncOptions = CustomerSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build (); Running the sync \u00b6 When all prerequisites are fulfilled, follow those steps to run the sync: // instantiating a customer sync final CustomerSync customerSync = new CustomerSync ( customerSyncOptions ); // execute the sync on your list of customers CompletionStage < CustomerSyncStatistics > syncStatisticsStage = customerSync . sync ( customerDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a CustomerSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed customers, and the processing time of the last sync batch in different time units and in a human-readable format. final CustomerSyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 100 customers were processed in total (11 created, 87 updated, 2 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied. More examples of how to use the sync \u00b6 Sync from an external source . Make sure to read the Important Usage Tips for optimal performance. Build all update actions \u00b6 A utility method provided by the library to compare a Customer to a new CustomerDraft . The results are collected in a list of customer update actions. List < CustomerUpdateAction > updateActions = CustomerSyncUtils . buildActions ( customer , customerDraft , customerSyncOptions ); Build particular update action(s) \u00b6 The library provides utility methods to compare specific fields of a Customer and a new CustomerDraft , and builds the update action(s) as a result. One example is the buildChangeEmailUpdateAction which compare email addresses: Optional < CustomerUpdateAction > updateAction = CustomerUpdateActionUtils . buildChangeEmailUpdateAction ( oldCustomer , customerDraft ); More examples for particular update actions can be found in the test scenarios for CustomerUpdateActionUtils and AddressUpdateActionUtils . Caveats \u00b6 The library does not support the synchronization of the password field of existing customers. For customers that do not exist in the project, a password will be created with the given customer draft\u2019s password.","title":"Customer Sync"},{"location":"usage/CUSTOMER_SYNC/#customer-sync","text":"The module used for importing/syncing Customers into a commercetools project. It also provides utilities for generating update actions based on the comparison of a Customer against a CustomerDraft . Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync More examples of how to use the sync Build all update actions Build particular update action(s) Caveats","title":"Customer Sync"},{"location":"usage/CUSTOMER_SYNC/#usage","text":"","title":"Usage"},{"location":"usage/CUSTOMER_SYNC/#prerequisites","text":"","title":"Prerequisites"},{"location":"usage/CUSTOMER_SYNC/#projectapiroot","text":"Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" );","title":"ProjectApiRoot"},{"location":"usage/CUSTOMER_SYNC/#required-fields","text":"The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note CustomerDraft key Also, the customers in the target project are expected to have the key fields set. CustomerDraft address.key Every customer BaseAddress needs a unique key to match the existing Address with the new AddressDraft .","title":"Required Fields"},{"location":"usage/CUSTOMER_SYNC/#reference-resolution","text":"In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in the sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type customerGroup CustomerGroupResourceIdentifier stores List of StoreResourceIdentifier custom.type TypeResourceIdentifier Note that a reference without the key field will be considered as an existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution.","title":"Reference Resolution"},{"location":"usage/CUSTOMER_SYNC/#syncing-from-a-commercetools-project","text":"When syncing from a source commercetools project, you can use toCustomerDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a Customer to CustomerDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build ByProjectKeyCustomersGet for fetching customers from a source CTP project without any references expanded for the sync: final ByProjectKeyCustomersGet byProjectKeyCustomersGet = client . customers (). get (); // Query all customers (NOTE this is just for example, please adjust your logic) final List < Customer > customers = QueryUtils . queryAll ( byProjectKeyCustomersGet , ( customers ) -> customers ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the Customer to CustomerDraft , Utils method toCustomerDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and customers as parameters. For cache implementation, You can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from Customer to CustomerDraft. With help of the cache same reference keys can be reused. CompletableFuture < List < CustomerDraft >> customerDrafts = CustomerTransformUtils . toCustomerDrafts ( client , referenceIdToKeyCache , customers );","title":"Syncing from a commercetools project"},{"location":"usage/CUSTOMER_SYNC/#syncing-from-an-external-resource","text":"When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final CustomFieldsDraft customFields = CustomFieldsDraftBuilder . of () . type ( TypeResourceIdentifierBuilder . of (). key ( \"type-key\" ). build ()) // note that custom type provided with key . fields ( FieldContainerBuilder . of (). values ( Collections . emptyMap ()). build ()) . build (); final AddressDraft address = AddressDraftBuilder . of () . key ( \"address-key-1\" ) // note that addresses has to be provided with their keys . country ( \"DE\" ) . build (); final CustomerDraft customerDraft = CustomerDraftBuilder . of () . email ( \"email@example.com\" ) . password ( \"password\" ) . key ( \"customer-key\" ) . customerGroup ( CustomerGroupRescourceIdentifierBuilder . of (). key ( \"customer-group-key\" ). build ()) // note that customergroup reference provided with key . addresses ( address ) . custom ( customFields ) . stores ( StoresResourceIdentifierBuilder . of (). key ( \"store-key1\" ). build (), StoresResourceIdentifierBuilder . of (). key ( \"store-key2\" ). build ()) // note that store reference provided with key . build ();","title":"Syncing from an external resource"},{"location":"usage/CUSTOMER_SYNC/#syncoptions","text":"After the ProjectApiRoot is set up, a CustomerSyncOptions should be built as follows: // instantiating a CustomerSyncOptions final CustomerSyncOptions customerSyncOptions = CustomerSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations:","title":"SyncOptions"},{"location":"usage/CUSTOMER_SYNC/#errorcallback","text":"A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception customer draft from the source customer of the target project (only provided if an existing customer could be found) the update-actions, which failed (only provided if an existing customer could be found) final Logger logger = LoggerFactory . getLogger ( CustomerSync . class ); final CustomerSyncOptions customerSyncOptions = CustomerSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , customer , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"errorCallback"},{"location":"usage/CUSTOMER_SYNC/#warningcallback","text":"A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception customer draft from the source customer of the target project (only provided if an existing customer could be found) final Logger logger = LoggerFactory . getLogger ( CustomerSync . class ); final CustomerSyncOptions customerSyncOptions = CustomerSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , customer ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"warningCallback"},{"location":"usage/CUSTOMER_SYNC/#beforeupdatecallback","text":"During the sync process, if a target customer and a customer draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : customer draft from the source customer from the target project update actions that were calculated after comparing both // Example: Ignore update actions which contain setting of lastName action final TriFunction < List < CustomerUpdateAction > , CustomerDraft , Customer , List < CustomerUpdateAction >> beforeUpdateCallback , = ( updateActions , newCustomerDraft , oldCustomer ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof CustomerSetLastNameActionImpl )) . collect ( Collectors . toList ()); final CustomerSyncOptions customerSyncOptions = CustomerSyncOptionsBuilder . of ( projectApiRoot ) . beforeUpdateCallback ( beforeUpdateCallback ) . build ();","title":"beforeUpdateCallback"},{"location":"usage/CUSTOMER_SYNC/#beforecreatecallback","text":"During the sync process, if a customer draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : customer draft that should be created Please refer to the example in the product sync document .","title":"beforeCreateCallback"},{"location":"usage/CUSTOMER_SYNC/#batchsize","text":"A number that could be used to set the batch size with which customers are fetched and processed, as customers are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding customers from the target project on the commercetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for customer sync. final CustomerSyncOptions customerSyncOptions = CustomerSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build ();","title":"batchSize"},{"location":"usage/CUSTOMER_SYNC/#cachesize","text":"In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for customer sync. final CustomerSyncOptions customerSyncOptions = CustomerSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build ();","title":"cacheSize"},{"location":"usage/CUSTOMER_SYNC/#running-the-sync","text":"When all prerequisites are fulfilled, follow those steps to run the sync: // instantiating a customer sync final CustomerSync customerSync = new CustomerSync ( customerSyncOptions ); // execute the sync on your list of customers CompletionStage < CustomerSyncStatistics > syncStatisticsStage = customerSync . sync ( customerDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a CustomerSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed customers, and the processing time of the last sync batch in different time units and in a human-readable format. final CustomerSyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 100 customers were processed in total (11 created, 87 updated, 2 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied.","title":"Running the sync"},{"location":"usage/CUSTOMER_SYNC/#more-examples-of-how-to-use-the-sync","text":"Sync from an external source . Make sure to read the Important Usage Tips for optimal performance.","title":"More examples of how to use the sync"},{"location":"usage/CUSTOMER_SYNC/#build-all-update-actions","text":"A utility method provided by the library to compare a Customer to a new CustomerDraft . The results are collected in a list of customer update actions. List < CustomerUpdateAction > updateActions = CustomerSyncUtils . buildActions ( customer , customerDraft , customerSyncOptions );","title":"Build all update actions"},{"location":"usage/CUSTOMER_SYNC/#build-particular-update-actions","text":"The library provides utility methods to compare specific fields of a Customer and a new CustomerDraft , and builds the update action(s) as a result. One example is the buildChangeEmailUpdateAction which compare email addresses: Optional < CustomerUpdateAction > updateAction = CustomerUpdateActionUtils . buildChangeEmailUpdateAction ( oldCustomer , customerDraft ); More examples for particular update actions can be found in the test scenarios for CustomerUpdateActionUtils and AddressUpdateActionUtils .","title":"Build particular update action(s)"},{"location":"usage/CUSTOMER_SYNC/#caveats","text":"The library does not support the synchronization of the password field of existing customers. For customers that do not exist in the project, a password will be created with the given customer draft\u2019s password.","title":"Caveats"},{"location":"usage/CUSTOM_OBJECT_SYNC/","text":"Custom Object Sync \u00b6 Module used for importing/syncing CustomObject into a commercetools project. It also provides utilities for correlating a custom object to a given custom object draft based on the comparison of a CustomObject against a CustomObjectDraft . Usage Prerequisites ProjectApiRoot Required Fields SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync More examples of how to use the sync Migration Guide Client configuration and creation Signature of CustomObjectSyncOptions Build CustomObjectDraft (syncing from external project) Query for CustomObjects JVM-SDK-V2 migration guide Usage \u00b6 Prerequisites \u00b6 ProjectApiRoot \u00b6 Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" ); Required Fields \u00b6 The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note CustomObjectDraft key Also, the custom objects in the target project are expected to have the key fields set. CustomObjectDraft container Also, the custom objects in the target project are expected to have the container fields set. SyncOptions \u00b6 After the projectApiRoot is set up, a CustomObjectSyncOptions should be built as follows: // instantiating a CustomObjectSyncOptions final CustomObjectSyncOptions customObjectSyncOptions = CustomObjectSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations: errorCallback \u00b6 A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception custom object draft from the source custom object of the target project (only provided if an existing custom object could be found) a fake list of update actions, as custom objects API does not provide update actions. NoopResourceUpdateAction.java final Logger logger = LoggerFactory . getLogger ( CustomObjectSync . class ); final CustomObjectSyncOptions customObjectSyncOptions = CustomObjectSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , customObject , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build (); warningCallback \u00b6 A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception custom object draft from the source custom object of the target project (only provided if an existing custom object could be found) final Logger logger = LoggerFactory . getLogger ( CustomObjectSync . class ); final CustomObjectSyncOptions customObjectSyncOptions = CustomObjectSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , customObject ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build (); beforeUpdateCallback \u00b6 In theory, CustomObjectSyncOptions provides callback before update operation. User can customize their own callback and inject into sync options. However, in the actual case, beforeUpdateCallback is not triggered in the custom object sync process. When the new custom object draft has the same key and container as an existing custom object but different in custom object values, the sync process automatically performs the create/update operation. The value of a corresponding custom object in the target project is overwritten. This approach is different from other resources and no update action is involved. Also see the API documentation of Create-or-update-customobject beforeCreateCallback \u00b6 During the sync process, if a custom object draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : custom object draft that should be created Please refer to example in product sync document . batchSize \u00b6 A number that could be used to set the batch size with which custom objects are fetched and processed, as custom objects are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding custom objects from the target project on the commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for custom object sync. final CustomObjectSyncOptions customObjectSyncOptions = CustomObjectSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build (); cacheSize \u00b6 In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for custom object sync. final CustomObjectSyncOptions customObjectSyncOptions = CustomObjectSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build (); Running the sync \u00b6 After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a CustomObjectSync final CustomObjectSync customObjectSync = new CustomObjectSync ( customObjectSyncOptions ); // execute the sync on your list of custom object drafts CompletionStage < CustomObjectSyncStatistics > syncStatisticsStage = customObjectSync . sync ( customObjectDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a CustomObjectSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed custom objects and the processing time of the last sync batch in different time units and in a human-readable format. final CustomObjectSyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 2000 custom objects were processed in total (1000 created, 995 updated, 5 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied. More examples of how to use the sync \u00b6 Sync from an external source . Make sure to read the Important Usage Tips for optimal performance. Migration Guide \u00b6 The custom-object-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . // Sample maven pom.xml <properties> <commercetools.version>LATEST</commercetools.version> </properties> <dependencies> <dependency> <groupId>com.commercetools.sdk</groupId> <artifactId>commercetools-http-client</artifactId> <version>${commercetools.version}</version> </dependency> <dependency> <groupId>com.commercetools.sdk</groupId> <artifactId>commercetools-sdk-java-api</artifactId> <version>${commercetools.version}</version> </dependency> </dependencies> Client configuration and creation \u00b6 For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document . Signature of CustomObjectSyncOptions \u00b6 As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with CustomObjectDraft , CustomObject (without type parameter as in v1) from package com.commercetools.api.models.custom_object.* and NoopResourceUpdateAction which is a fake class representing resource without update actions like custom-object. Note: Make sure beforeUpdateCallback isn't used as the sync will not trigger it in the process. Note: Further make sure on errorCallback to not operate on NoopResourceUpdateAction 's actions field as it is null. Build CustomObjectDraft (syncing from external project) \u00b6 The custom-object-sync expects a list of CustomObjectDraft s to process. To sync your categories from anywhere (including other CTP project) into a commercetools platform project you have to convert your data into CTP compatible CategoryDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: Note: In v1 the value in CustomObjectDraft is of generic type and custom-object-sync was expecting JsonNode as value. This changed in V2 SDK and the sync-library, and value field is of type Object now. // CategoryDraft builder in v1 takes parameters 'container', 'key' and 'value' final CustomObjectDraft cutomObjectDraft = CustomObjectDraft . ofUnversionedUpsert ( \"someContainer\" , \"someKey\" , JsonNodeFactory . instance . objectNode (). put ( \"json-field\" , \"json-value\" )); // CustomObjectDraftBuilder in v2 final CustomObjectDraft newCustomObjectDraft = CustomObjectDraftBuilder . of () . container ( \"someContainer\" ) . key ( \"someKey\" ) . value ( \"someValue\" ) . build (); For more information, see the Guide to replace DraftBuilders . Query for CustomObjects \u00b6 If you need to query CustomObjects from a commercetools project instead of passing CustomObjectQuery<T> s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: CategoryQuery to fetch all categories final CustomObjectQuery < JsonNode > query = CustomObjectQuery . ofJsonNode (); final PagedQueryResult < CustomObject < JsonNode >> pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all custom objects in one line final CustomObjectPagedQueryResponse result = apiRoot . customObjects (). get (). executeBlocking (). getBody (); Read more about querying resources. JVM-SDK-V2 migration guide \u00b6 On any other needs to migrate your project using jvm-sdk-v2 please refer to it's Migration Guide .","title":"CustomObject Sync"},{"location":"usage/CUSTOM_OBJECT_SYNC/#custom-object-sync","text":"Module used for importing/syncing CustomObject into a commercetools project. It also provides utilities for correlating a custom object to a given custom object draft based on the comparison of a CustomObject against a CustomObjectDraft . Usage Prerequisites ProjectApiRoot Required Fields SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync More examples of how to use the sync Migration Guide Client configuration and creation Signature of CustomObjectSyncOptions Build CustomObjectDraft (syncing from external project) Query for CustomObjects JVM-SDK-V2 migration guide","title":"Custom Object Sync"},{"location":"usage/CUSTOM_OBJECT_SYNC/#usage","text":"","title":"Usage"},{"location":"usage/CUSTOM_OBJECT_SYNC/#prerequisites","text":"","title":"Prerequisites"},{"location":"usage/CUSTOM_OBJECT_SYNC/#projectapiroot","text":"Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" );","title":"ProjectApiRoot"},{"location":"usage/CUSTOM_OBJECT_SYNC/#required-fields","text":"The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note CustomObjectDraft key Also, the custom objects in the target project are expected to have the key fields set. CustomObjectDraft container Also, the custom objects in the target project are expected to have the container fields set.","title":"Required Fields"},{"location":"usage/CUSTOM_OBJECT_SYNC/#syncoptions","text":"After the projectApiRoot is set up, a CustomObjectSyncOptions should be built as follows: // instantiating a CustomObjectSyncOptions final CustomObjectSyncOptions customObjectSyncOptions = CustomObjectSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations:","title":"SyncOptions"},{"location":"usage/CUSTOM_OBJECT_SYNC/#errorcallback","text":"A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception custom object draft from the source custom object of the target project (only provided if an existing custom object could be found) a fake list of update actions, as custom objects API does not provide update actions. NoopResourceUpdateAction.java final Logger logger = LoggerFactory . getLogger ( CustomObjectSync . class ); final CustomObjectSyncOptions customObjectSyncOptions = CustomObjectSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , customObject , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"errorCallback"},{"location":"usage/CUSTOM_OBJECT_SYNC/#warningcallback","text":"A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception custom object draft from the source custom object of the target project (only provided if an existing custom object could be found) final Logger logger = LoggerFactory . getLogger ( CustomObjectSync . class ); final CustomObjectSyncOptions customObjectSyncOptions = CustomObjectSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , customObject ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"warningCallback"},{"location":"usage/CUSTOM_OBJECT_SYNC/#beforeupdatecallback","text":"In theory, CustomObjectSyncOptions provides callback before update operation. User can customize their own callback and inject into sync options. However, in the actual case, beforeUpdateCallback is not triggered in the custom object sync process. When the new custom object draft has the same key and container as an existing custom object but different in custom object values, the sync process automatically performs the create/update operation. The value of a corresponding custom object in the target project is overwritten. This approach is different from other resources and no update action is involved. Also see the API documentation of Create-or-update-customobject","title":"beforeUpdateCallback"},{"location":"usage/CUSTOM_OBJECT_SYNC/#beforecreatecallback","text":"During the sync process, if a custom object draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : custom object draft that should be created Please refer to example in product sync document .","title":"beforeCreateCallback"},{"location":"usage/CUSTOM_OBJECT_SYNC/#batchsize","text":"A number that could be used to set the batch size with which custom objects are fetched and processed, as custom objects are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding custom objects from the target project on the commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for custom object sync. final CustomObjectSyncOptions customObjectSyncOptions = CustomObjectSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build ();","title":"batchSize"},{"location":"usage/CUSTOM_OBJECT_SYNC/#cachesize","text":"In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for custom object sync. final CustomObjectSyncOptions customObjectSyncOptions = CustomObjectSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build ();","title":"cacheSize"},{"location":"usage/CUSTOM_OBJECT_SYNC/#running-the-sync","text":"After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a CustomObjectSync final CustomObjectSync customObjectSync = new CustomObjectSync ( customObjectSyncOptions ); // execute the sync on your list of custom object drafts CompletionStage < CustomObjectSyncStatistics > syncStatisticsStage = customObjectSync . sync ( customObjectDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a CustomObjectSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed custom objects and the processing time of the last sync batch in different time units and in a human-readable format. final CustomObjectSyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 2000 custom objects were processed in total (1000 created, 995 updated, 5 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied.","title":"Running the sync"},{"location":"usage/CUSTOM_OBJECT_SYNC/#more-examples-of-how-to-use-the-sync","text":"Sync from an external source . Make sure to read the Important Usage Tips for optimal performance.","title":"More examples of how to use the sync"},{"location":"usage/CUSTOM_OBJECT_SYNC/#migration-guide","text":"The custom-object-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . // Sample maven pom.xml <properties> <commercetools.version>LATEST</commercetools.version> </properties> <dependencies> <dependency> <groupId>com.commercetools.sdk</groupId> <artifactId>commercetools-http-client</artifactId> <version>${commercetools.version}</version> </dependency> <dependency> <groupId>com.commercetools.sdk</groupId> <artifactId>commercetools-sdk-java-api</artifactId> <version>${commercetools.version}</version> </dependency> </dependencies>","title":"Migration Guide"},{"location":"usage/CUSTOM_OBJECT_SYNC/#client-configuration-and-creation","text":"For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document .","title":"Client configuration and creation"},{"location":"usage/CUSTOM_OBJECT_SYNC/#signature-of-customobjectsyncoptions","text":"As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with CustomObjectDraft , CustomObject (without type parameter as in v1) from package com.commercetools.api.models.custom_object.* and NoopResourceUpdateAction which is a fake class representing resource without update actions like custom-object. Note: Make sure beforeUpdateCallback isn't used as the sync will not trigger it in the process. Note: Further make sure on errorCallback to not operate on NoopResourceUpdateAction 's actions field as it is null.","title":"Signature of CustomObjectSyncOptions"},{"location":"usage/CUSTOM_OBJECT_SYNC/#build-customobjectdraft-syncing-from-external-project","text":"The custom-object-sync expects a list of CustomObjectDraft s to process. To sync your categories from anywhere (including other CTP project) into a commercetools platform project you have to convert your data into CTP compatible CategoryDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: Note: In v1 the value in CustomObjectDraft is of generic type and custom-object-sync was expecting JsonNode as value. This changed in V2 SDK and the sync-library, and value field is of type Object now. // CategoryDraft builder in v1 takes parameters 'container', 'key' and 'value' final CustomObjectDraft cutomObjectDraft = CustomObjectDraft . ofUnversionedUpsert ( \"someContainer\" , \"someKey\" , JsonNodeFactory . instance . objectNode (). put ( \"json-field\" , \"json-value\" )); // CustomObjectDraftBuilder in v2 final CustomObjectDraft newCustomObjectDraft = CustomObjectDraftBuilder . of () . container ( \"someContainer\" ) . key ( \"someKey\" ) . value ( \"someValue\" ) . build (); For more information, see the Guide to replace DraftBuilders .","title":"Build CustomObjectDraft (syncing from external project)"},{"location":"usage/CUSTOM_OBJECT_SYNC/#query-for-customobjects","text":"If you need to query CustomObjects from a commercetools project instead of passing CustomObjectQuery<T> s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: CategoryQuery to fetch all categories final CustomObjectQuery < JsonNode > query = CustomObjectQuery . ofJsonNode (); final PagedQueryResult < CustomObject < JsonNode >> pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all custom objects in one line final CustomObjectPagedQueryResponse result = apiRoot . customObjects (). get (). executeBlocking (). getBody (); Read more about querying resources.","title":"Query for CustomObjects"},{"location":"usage/CUSTOM_OBJECT_SYNC/#jvm-sdk-v2-migration-guide","text":"On any other needs to migrate your project using jvm-sdk-v2 please refer to it's Migration Guide .","title":"JVM-SDK-V2 migration guide"},{"location":"usage/IMPORTANT_USAGE_TIPS/","text":"Important Usage Tips \u00b6 Customized ProjectApiRoot Creation Tuning the Sync Process Customized ProjectApiRoot Creation \u00b6 When creating a customized ProjectApiRoot the following remarks should be considered: Limit the number of concurrent requests done to CTP. This can be done by adding a QueueMiddleware to the ApiRootBuilder QueueMiddleware Retry on 5xx errors with a retry strategy. This can be achieved by adding a RetryRequestMiddleware to the ApiRootBuilder RetryRequestMiddleware If you have no special requirements on the client creation, then you can use the ClientConfigurationUtils#createClient util which applies the best practices for ProjectApiRoot creation. To understand how to initialize those method arguments, please refer to the unit test To tune / customize your client please refer to Client Tuning Tuning the Sync Process \u00b6 The sync library is not meant to be executed in a parallel fashion. For example: final ProductSync productSync = new ProductSync ( syncOptions ); final CompletableFuture < ProductSyncStatistics > syncFuture1 = productSync . sync ( batch1 ). toCompletableFuture (); final CompletableFuture < ProductSyncStatistics > syncFuture2 = productSync . sync ( batch2 ). toCompletableFuture (); CompletableFuture . allOf ( syncFuture1 , syncFuture2 ). join ; The aforementioned example demonstrates how the library should NOT be used. The library, however, should be instead used in a sequential fashion: final ProductSync productSync = new ProductSync ( syncOptions ); productSync . sync ( batch1 ) . thenCompose ( result -> productSync . sync ( batch2 )) . toCompletableFuture () . join (); By design, scaling the sync process should not be done by executing the batches themselves in parallel. However, it can be done either by: Changing the number of max parallel requests within the projectApiRoot configuration. It defines how many requests the client can execute in parallel. or changing the draft batch size . It defines how many drafts can one batch contains. The current overridable default configuration of the projectApiRoot is the recommended good balance for stability and performance for the sync process. In order to exploit the number of max parallel requests , the batch size should have a value set that is equal or higher.","title":"Usage Tips"},{"location":"usage/IMPORTANT_USAGE_TIPS/#important-usage-tips","text":"Customized ProjectApiRoot Creation Tuning the Sync Process","title":"Important Usage Tips"},{"location":"usage/IMPORTANT_USAGE_TIPS/#customized-projectapiroot-creation","text":"When creating a customized ProjectApiRoot the following remarks should be considered: Limit the number of concurrent requests done to CTP. This can be done by adding a QueueMiddleware to the ApiRootBuilder QueueMiddleware Retry on 5xx errors with a retry strategy. This can be achieved by adding a RetryRequestMiddleware to the ApiRootBuilder RetryRequestMiddleware If you have no special requirements on the client creation, then you can use the ClientConfigurationUtils#createClient util which applies the best practices for ProjectApiRoot creation. To understand how to initialize those method arguments, please refer to the unit test To tune / customize your client please refer to Client Tuning","title":"Customized ProjectApiRoot Creation"},{"location":"usage/IMPORTANT_USAGE_TIPS/#tuning-the-sync-process","text":"The sync library is not meant to be executed in a parallel fashion. For example: final ProductSync productSync = new ProductSync ( syncOptions ); final CompletableFuture < ProductSyncStatistics > syncFuture1 = productSync . sync ( batch1 ). toCompletableFuture (); final CompletableFuture < ProductSyncStatistics > syncFuture2 = productSync . sync ( batch2 ). toCompletableFuture (); CompletableFuture . allOf ( syncFuture1 , syncFuture2 ). join ; The aforementioned example demonstrates how the library should NOT be used. The library, however, should be instead used in a sequential fashion: final ProductSync productSync = new ProductSync ( syncOptions ); productSync . sync ( batch1 ) . thenCompose ( result -> productSync . sync ( batch2 )) . toCompletableFuture () . join (); By design, scaling the sync process should not be done by executing the batches themselves in parallel. However, it can be done either by: Changing the number of max parallel requests within the projectApiRoot configuration. It defines how many requests the client can execute in parallel. or changing the draft batch size . It defines how many drafts can one batch contains. The current overridable default configuration of the projectApiRoot is the recommended good balance for stability and performance for the sync process. In order to exploit the number of max parallel requests , the batch size should have a value set that is equal or higher.","title":"Tuning the Sync Process"},{"location":"usage/INVENTORY_SYNC/","text":"InventoryEntry Sync \u00b6 The module used for importing/syncing InventoryEntries into a commercetools project. It also provides utilities for generating update actions based on the comparison of a InventoryEntry against a InventoryEntryDraft . Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize ensureChannels Running the sync Build all update actions Build particular update action(s) Migration Guide Client configuration and creation Signature of InventorySyncOptions Build InventoryEntryDraft (syncing from external project) Query for Inventories (syncing from CTP project) JVM-SDK-V2 migration guide Usage \u00b6 Prerequisites \u00b6 ProjectApiRoot \u00b6 Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" ); Required Fields \u00b6 The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note InventoryEntryDraft sku Also, the inventory entries in the target project are expected to have the sku fields set. Reference Resolution \u00b6 In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in the sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type supplyChannel ChannelResourceIdentifier custom.type TypeResourceIdentifier Note that a reference without the key field will be considered as an existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution. Syncing from a commercetools project \u00b6 When syncing from a source commercetools project, you can use toInventoryEntryDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a InventoryEntry to InventoryEntryDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build an ByProjectKeyInventoryGet for fetching inventories from a source CTP project without any references expanded for the sync: final ByProjectKeyInventoryEntriesGet inventoryEntryQuery = client . inventory (). get (); // Query all inventories (NOTE this is just for example, please adjust your logic) final List < InventoryEntry > categories = QueryUtils . queryAll ( inventoryEntryQuery , ( inventories ) -> inventories ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the InventoryEntry to InventoryEntryDraft , Utils method toInventoryEntryDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and inventoryEntries as parameters. For cache implementation, You can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from InventoryEntry to InventoryEntryDraft. With help of the cache same reference keys can be reused. CompletableFuture < List < InventoryEntryDraft >> inventoryEntryDrafts = InventoryTransformUtils . toInventoryEntryDrafts ( client , referenceIdToKeyCache , inventoryEntries ); Syncing from an external resource \u00b6 When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final InventoryEntryDraft inventoryEntryDraft = InventoryEntryDraftBuilder . of () . sku ( \"sku1\" ) . quantityOnStock ( 1L ) . custom ( CustomFieldsDraftBuilder . of (). type ( typeResourceIdentifierBuilder -> typeResourceIdentifierBuilder . key ( \"type-key\" )). fields ( fieldContainerBuilder -> fieldContainerBuilder . values ( emptyMap ())). build ())) // note that custom type provided with key . supplyChannel ( ChannelResourceIdentifierBuilder . of (). key ( \"channel-key\" ). build ()) // note that channel reference provided with key . build (); SyncOptions \u00b6 After the projectApiRoot is set up, an InventorySyncOptions should be built as follows: // instantiating a InventorySyncOptions final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations: errorCallback \u00b6 A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception inventory entry draft from the source inventory entry of the target project (only provided if an existing inventory entry could be found) the update-actions, which failed (only provided if an existing inventory entry could be found) final Logger logger = LoggerFactory . getLogger ( InventorySync . class ); final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , inventoryEntry , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build (); warningCallback \u00b6 A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception inventory entry draft from the source inventory entry of the target project (only provided if an existing inventory entry could be found) final Logger logger = LoggerFactory . getLogger ( InventorySync . class ); final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , inventoryEntry ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build (); beforeUpdateCallback \u00b6 During the sync process, if a target inventory entry and an inventory entry draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : inventory entry draft from the source inventory from the target project update actions that were calculated after comparing both final TriFunction < List < InventoryEntryUpdateAction > , InventoryEntryDraft , InventoryEntry , List < InventoryEntryUpdateAction >> beforeUpdateInventoryCallback = ( updateActions , newInventoryEntryDraft , oldInventoryEntry ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof InventoryEntryRemoveQuantityAction )) . collect ( Collectors . toList ()); final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateInventoryCallback ). build (); beforeCreateCallback \u00b6 During the sync process, if an inventory entry draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : inventory entry draft that should be created Please refer to example in product sync document . batchSize \u00b6 A number that could be used to set the batch size with which inventories are fetched and processed, as inventories are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding inventories from the target project on the commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 150 for inventory sync. final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 100 ). build (); cacheSize \u00b6 In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for inventory sync. final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build (); ensureChannels \u00b6 A flag to indicate whether the sync process should create a supply channel of the given key when it doesn't exist in a target project yet. - If ensureChannels is set to false this inventory won't be synced and the errorCallback will be triggered. - If ensureChannels is set to true the sync will attempt to create the missing supply channel with the given key. If it fails to create the supply channel, the inventory won't sync and errorCallback will be triggered. - If not provided, it is set to false by default. final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ). ensureChannels ( true ). build (); Running the sync \u00b6 After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating an inventory sync final InventorySync inventorySync = new InventorySync ( inventorySyncOptions ); // execute the sync on your list of inventories CompletionStage < InventorySyncStatistics > syncStatisticsStage = inventorySync . sync ( inventoryEntryDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a InventorySyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed inventories and the processing time of the sync in different time units and in a human-readable format. final InventorySyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 25 inventory entries were processed in total (9 created, 5 updated, 2 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied. More examples of how to use the sync can be found here . Make sure to read the Important Usage Tips for optimal performance. Build all update actions \u00b6 A utility method provided by the library to compare an InventoryEntry with a new InventoryEntryDraft and results in a list of InventoryEntry update actions. List < InventoryEntryUpdateAction > updateActions = InventorySyncUtils . buildActions ( oldEntry , newEntry , inventorySyncOptions ); Examples of its usage can be found in the tests here . Build particular update action(s) \u00b6 Utility methods provided by the library to compare the specific fields of an InventoryEntry and a new InventoryEntryDraft, and in turn builds the update action. One example is the buildChangeQuantityAction which compares quantities: Optional < InventoryEntryUpdateAction > updateAction = buildChangeQuantityAction ( oldEntry , newEntry ); Migration Guide \u00b6 The inventory-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies> Client configuration and creation \u00b6 For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document . Signature of InventorySyncOptions \u00b6 As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with InventoryEntryDraft , InventoryEntry and InventoryEntryUpdateAction from package com.commercetools.api.models.inventory.* Note: Type UpdateAction<InventoryEntry> has changed to InventoryEntryUpdateAction . Make sure you create and supply a specific InventoryEntryUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a inventory update action to change quantity taking the 'newQuantity' of the InventoryEntryDraft final Function < Long , InventoryEntryUpdateAction > createBeforeUpdateAction = ( newQuantity ) -> InventoryEntryChangeQuantityAction . builder (). quantity ( newQuantity ). build (); // Add the change quantity action to the list of update actions before update is executed final TriFunction < List < InventoryEntryUpdateAction > , InventoryEntryDraft , InventoryEntry , List < InventoryEntryUpdateAction >> beforeUpdateInventoryCallback = ( updateActions , newInventoryEntryDraft , oldInventoryEntry ) -> { final InventoryEntryUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newInventoryDraft . getQuantity ()); updateActions . add ( beforeUpdateAction ); return updateActions ; }; Build InventoryEntryDraft (syncing from external project) \u00b6 The inventory-sync expects a list of InventoryEntryDraft s to process. If you use java-sync-library to sync your inventories from any external system into a commercetools platform project you have to convert your data into CTP compatible InventoryEntryDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // InventoryEntryDraftBuilder in v1 takes parameters 'sku' and 'quantityOnStock' final InventoryEntryDraft inventoryEntryDraft = InventoryEntryDraftBuilder . of ( \"sku\" , 10L ) . restockableInDays ( 10 ) //Note: Field 'restockableInDays' is of type Integer . build (); // InventoryEntryDraftBuilder in v2 final InventoryEntryDraft inventoryEntryDraft = InventoryEntryDraftBuilder . of () . sku ( \"sku\" ) . quantityOnStock ( 10L ) . restockableInDays ( 10L ) //Note: Field 'restockableInDays' is of type Long . build (); For more information, see the Guide to replace DraftBuilders . Query for Inventories (syncing from CTP project) \u00b6 If you sync inventories between different commercetools projects you probably use InventoryTransformUtils#toInventoryEntryDrafts to transform InventoryEntry into InventoryEntryDraft which can be used by the inventory-sync. However, if you need to query Inventories from a commercetools project instead of passing InventoryEntryQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: InventoryEntryQuery to fetch all inventories final InventoryEntryQuery query = InventoryEntryQuery . of (); final PagedQueryResult < InventoryEntry > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all inventories in one line final InventoryEntryPagedQueryResponse result = apiRoot . inventory (). get (). executeBlocking (). getBody (); Read more about querying resources. Note: If you use predicates to query resources please keep in mind the URI length is limited to ~8kB. Therefore, consider limiting the query-predicates (max. 10.000 characters), because above this size it could return - Error 414 (Request-URI Too Large). JVM-SDK-V2 migration guide \u00b6 On any other needs to migrate your project using jvm-sdk-v2 please refer to it's Migration Guide .","title":"InventoryEntry Sync"},{"location":"usage/INVENTORY_SYNC/#inventoryentry-sync","text":"The module used for importing/syncing InventoryEntries into a commercetools project. It also provides utilities for generating update actions based on the comparison of a InventoryEntry against a InventoryEntryDraft . Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize ensureChannels Running the sync Build all update actions Build particular update action(s) Migration Guide Client configuration and creation Signature of InventorySyncOptions Build InventoryEntryDraft (syncing from external project) Query for Inventories (syncing from CTP project) JVM-SDK-V2 migration guide","title":"InventoryEntry Sync"},{"location":"usage/INVENTORY_SYNC/#usage","text":"","title":"Usage"},{"location":"usage/INVENTORY_SYNC/#prerequisites","text":"","title":"Prerequisites"},{"location":"usage/INVENTORY_SYNC/#projectapiroot","text":"Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" );","title":"ProjectApiRoot"},{"location":"usage/INVENTORY_SYNC/#required-fields","text":"The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note InventoryEntryDraft sku Also, the inventory entries in the target project are expected to have the sku fields set.","title":"Required Fields"},{"location":"usage/INVENTORY_SYNC/#reference-resolution","text":"In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in the sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type supplyChannel ChannelResourceIdentifier custom.type TypeResourceIdentifier Note that a reference without the key field will be considered as an existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution.","title":"Reference Resolution"},{"location":"usage/INVENTORY_SYNC/#syncing-from-a-commercetools-project","text":"When syncing from a source commercetools project, you can use toInventoryEntryDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a InventoryEntry to InventoryEntryDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build an ByProjectKeyInventoryGet for fetching inventories from a source CTP project without any references expanded for the sync: final ByProjectKeyInventoryEntriesGet inventoryEntryQuery = client . inventory (). get (); // Query all inventories (NOTE this is just for example, please adjust your logic) final List < InventoryEntry > categories = QueryUtils . queryAll ( inventoryEntryQuery , ( inventories ) -> inventories ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the InventoryEntry to InventoryEntryDraft , Utils method toInventoryEntryDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and inventoryEntries as parameters. For cache implementation, You can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from InventoryEntry to InventoryEntryDraft. With help of the cache same reference keys can be reused. CompletableFuture < List < InventoryEntryDraft >> inventoryEntryDrafts = InventoryTransformUtils . toInventoryEntryDrafts ( client , referenceIdToKeyCache , inventoryEntries );","title":"Syncing from a commercetools project"},{"location":"usage/INVENTORY_SYNC/#syncing-from-an-external-resource","text":"When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final InventoryEntryDraft inventoryEntryDraft = InventoryEntryDraftBuilder . of () . sku ( \"sku1\" ) . quantityOnStock ( 1L ) . custom ( CustomFieldsDraftBuilder . of (). type ( typeResourceIdentifierBuilder -> typeResourceIdentifierBuilder . key ( \"type-key\" )). fields ( fieldContainerBuilder -> fieldContainerBuilder . values ( emptyMap ())). build ())) // note that custom type provided with key . supplyChannel ( ChannelResourceIdentifierBuilder . of (). key ( \"channel-key\" ). build ()) // note that channel reference provided with key . build ();","title":"Syncing from an external resource"},{"location":"usage/INVENTORY_SYNC/#syncoptions","text":"After the projectApiRoot is set up, an InventorySyncOptions should be built as follows: // instantiating a InventorySyncOptions final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations:","title":"SyncOptions"},{"location":"usage/INVENTORY_SYNC/#errorcallback","text":"A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception inventory entry draft from the source inventory entry of the target project (only provided if an existing inventory entry could be found) the update-actions, which failed (only provided if an existing inventory entry could be found) final Logger logger = LoggerFactory . getLogger ( InventorySync . class ); final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , inventoryEntry , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"errorCallback"},{"location":"usage/INVENTORY_SYNC/#warningcallback","text":"A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception inventory entry draft from the source inventory entry of the target project (only provided if an existing inventory entry could be found) final Logger logger = LoggerFactory . getLogger ( InventorySync . class ); final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , inventoryEntry ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"warningCallback"},{"location":"usage/INVENTORY_SYNC/#beforeupdatecallback","text":"During the sync process, if a target inventory entry and an inventory entry draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : inventory entry draft from the source inventory from the target project update actions that were calculated after comparing both final TriFunction < List < InventoryEntryUpdateAction > , InventoryEntryDraft , InventoryEntry , List < InventoryEntryUpdateAction >> beforeUpdateInventoryCallback = ( updateActions , newInventoryEntryDraft , oldInventoryEntry ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof InventoryEntryRemoveQuantityAction )) . collect ( Collectors . toList ()); final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateInventoryCallback ). build ();","title":"beforeUpdateCallback"},{"location":"usage/INVENTORY_SYNC/#beforecreatecallback","text":"During the sync process, if an inventory entry draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : inventory entry draft that should be created Please refer to example in product sync document .","title":"beforeCreateCallback"},{"location":"usage/INVENTORY_SYNC/#batchsize","text":"A number that could be used to set the batch size with which inventories are fetched and processed, as inventories are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding inventories from the target project on the commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 150 for inventory sync. final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 100 ). build ();","title":"batchSize"},{"location":"usage/INVENTORY_SYNC/#cachesize","text":"In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for inventory sync. final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build ();","title":"cacheSize"},{"location":"usage/INVENTORY_SYNC/#ensurechannels","text":"A flag to indicate whether the sync process should create a supply channel of the given key when it doesn't exist in a target project yet. - If ensureChannels is set to false this inventory won't be synced and the errorCallback will be triggered. - If ensureChannels is set to true the sync will attempt to create the missing supply channel with the given key. If it fails to create the supply channel, the inventory won't sync and errorCallback will be triggered. - If not provided, it is set to false by default. final InventorySyncOptions inventorySyncOptions = InventorySyncOptionsBuilder . of ( projectApiRoot ). ensureChannels ( true ). build ();","title":"ensureChannels"},{"location":"usage/INVENTORY_SYNC/#running-the-sync","text":"After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating an inventory sync final InventorySync inventorySync = new InventorySync ( inventorySyncOptions ); // execute the sync on your list of inventories CompletionStage < InventorySyncStatistics > syncStatisticsStage = inventorySync . sync ( inventoryEntryDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a InventorySyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed inventories and the processing time of the sync in different time units and in a human-readable format. final InventorySyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 25 inventory entries were processed in total (9 created, 5 updated, 2 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied. More examples of how to use the sync can be found here . Make sure to read the Important Usage Tips for optimal performance.","title":"Running the sync"},{"location":"usage/INVENTORY_SYNC/#build-all-update-actions","text":"A utility method provided by the library to compare an InventoryEntry with a new InventoryEntryDraft and results in a list of InventoryEntry update actions. List < InventoryEntryUpdateAction > updateActions = InventorySyncUtils . buildActions ( oldEntry , newEntry , inventorySyncOptions ); Examples of its usage can be found in the tests here .","title":"Build all update actions"},{"location":"usage/INVENTORY_SYNC/#build-particular-update-actions","text":"Utility methods provided by the library to compare the specific fields of an InventoryEntry and a new InventoryEntryDraft, and in turn builds the update action. One example is the buildChangeQuantityAction which compares quantities: Optional < InventoryEntryUpdateAction > updateAction = buildChangeQuantityAction ( oldEntry , newEntry );","title":"Build particular update action(s)"},{"location":"usage/INVENTORY_SYNC/#migration-guide","text":"The inventory-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies>","title":"Migration Guide"},{"location":"usage/INVENTORY_SYNC/#client-configuration-and-creation","text":"For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document .","title":"Client configuration and creation"},{"location":"usage/INVENTORY_SYNC/#signature-of-inventorysyncoptions","text":"As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with InventoryEntryDraft , InventoryEntry and InventoryEntryUpdateAction from package com.commercetools.api.models.inventory.* Note: Type UpdateAction<InventoryEntry> has changed to InventoryEntryUpdateAction . Make sure you create and supply a specific InventoryEntryUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a inventory update action to change quantity taking the 'newQuantity' of the InventoryEntryDraft final Function < Long , InventoryEntryUpdateAction > createBeforeUpdateAction = ( newQuantity ) -> InventoryEntryChangeQuantityAction . builder (). quantity ( newQuantity ). build (); // Add the change quantity action to the list of update actions before update is executed final TriFunction < List < InventoryEntryUpdateAction > , InventoryEntryDraft , InventoryEntry , List < InventoryEntryUpdateAction >> beforeUpdateInventoryCallback = ( updateActions , newInventoryEntryDraft , oldInventoryEntry ) -> { final InventoryEntryUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newInventoryDraft . getQuantity ()); updateActions . add ( beforeUpdateAction ); return updateActions ; };","title":"Signature of InventorySyncOptions"},{"location":"usage/INVENTORY_SYNC/#build-inventoryentrydraft-syncing-from-external-project","text":"The inventory-sync expects a list of InventoryEntryDraft s to process. If you use java-sync-library to sync your inventories from any external system into a commercetools platform project you have to convert your data into CTP compatible InventoryEntryDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // InventoryEntryDraftBuilder in v1 takes parameters 'sku' and 'quantityOnStock' final InventoryEntryDraft inventoryEntryDraft = InventoryEntryDraftBuilder . of ( \"sku\" , 10L ) . restockableInDays ( 10 ) //Note: Field 'restockableInDays' is of type Integer . build (); // InventoryEntryDraftBuilder in v2 final InventoryEntryDraft inventoryEntryDraft = InventoryEntryDraftBuilder . of () . sku ( \"sku\" ) . quantityOnStock ( 10L ) . restockableInDays ( 10L ) //Note: Field 'restockableInDays' is of type Long . build (); For more information, see the Guide to replace DraftBuilders .","title":"Build InventoryEntryDraft (syncing from external project)"},{"location":"usage/INVENTORY_SYNC/#query-for-inventories-syncing-from-ctp-project","text":"If you sync inventories between different commercetools projects you probably use InventoryTransformUtils#toInventoryEntryDrafts to transform InventoryEntry into InventoryEntryDraft which can be used by the inventory-sync. However, if you need to query Inventories from a commercetools project instead of passing InventoryEntryQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: InventoryEntryQuery to fetch all inventories final InventoryEntryQuery query = InventoryEntryQuery . of (); final PagedQueryResult < InventoryEntry > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all inventories in one line final InventoryEntryPagedQueryResponse result = apiRoot . inventory (). get (). executeBlocking (). getBody (); Read more about querying resources. Note: If you use predicates to query resources please keep in mind the URI length is limited to ~8kB. Therefore, consider limiting the query-predicates (max. 10.000 characters), because above this size it could return - Error 414 (Request-URI Too Large).","title":"Query for Inventories (syncing from CTP project)"},{"location":"usage/INVENTORY_SYNC/#jvm-sdk-v2-migration-guide","text":"On any other needs to migrate your project using jvm-sdk-v2 please refer to it's Migration Guide .","title":"JVM-SDK-V2 migration guide"},{"location":"usage/PRODUCT_SYNC/","text":"Product Sync \u00b6 The module used for importing/syncing Products into a commercetools project. It also provides utilities for generating update actions based on the comparison of a ProductProjection against a ProductDraft . Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize syncFilter ensureChannels Running the sync Persistence of ProductDrafts with Irresolvable References More examples of how to use the sync Build all update actions Build particular update action(s) Caveats Migration Guide Client configuration and creation Signature of ProductSyncOptions Build ProductDraft (syncing from external project) Query for Products (syncing from CTP project) JVM-SDK-V2 migration guide Usage \u00b6 Prerequisites \u00b6 ProjectApiRoot \u00b6 Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" ); Required Fields \u00b6 The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note ProductDraft key Also, the products in the target project are expected to have the key fields set. ProductVariantDraft key , sku Also, all the variants in the target project are expected to have the key and sku fields set. Reference Resolution \u00b6 In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in the sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type Necessity productType ProductTypeResourceIdentifier Required categories List of CategoryResourceIdentifier Optional taxCategory TaxCategoryResourceIdentifier Optional state StateResourceIdentifier Optional variants.prices.channel ChannelResourceIdentifier Optional variants.prices.customerGroup CustomerGroupResourceIdentifier Optional variants.prices.custom.type TypeResourceIdentifier Required for custom (CustomFieldsDraft) variants.assets.custom.type TypeResourceIdentifier Required for custom (CustomFieldsDraft) variants.attributes Only the attributes with type ReferenceType , SetType with elementType as ReferenceType and NestedType requires key on the id field of the ReferenceType . Optional Note that a reference without the key field will be considered as existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution. Syncing from a commercetools project \u00b6 When syncing from a source commercetools project, you can use toProductDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a ProductProjection to ProductDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build a ProductQuery for fetching products from a source CTP project without any references expanded for the sync: final ByProjectKeyProductProjectionsGet byProjectKeyProductsGet = getCtpClient (). productProjections (). get (). addStaged ( true ); // Query all product projections (NOTE this is only for example, please adjust your logic) final List < ProductProjection > products = QueryUtils . queryAll ( byProjectKeyProductsGet , ( productProjections ) -> productProjections ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the ProductProjections to ProductDraft , Utils method toProductDrafts requires ProjectApiRoot , implementation of ReferenceIdToKeyCache and list of ProductProjection as parameters. For cache implementation, You can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from ProductProjection to ProductDraft. With help of the cache same reference keys can be reused. CompletableFuture < List < ProductDraft >> productDrafts = ProductTransformUtils . toProductDrafts ( client , referenceIdToKeyCache , products ); Syncing from an external resource \u00b6 When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final ProductDraft productDraft = ProductDraftBuilder . of () . productType ( ProductTypeResourceIdentifierBuilder . of (). key ( \"product-type-key\" ). build ()) . name ( LocalizedString . ofEnglish ( \"name\" )) . slug ( LocalizedString . ofEnglish ( \"slug\" )) . masterVariant ( masterVariant ) . key ( \"product-key\" ) . categories ( CategoryResourceIdentifierBuilder . of (). key ( \"category1-key\" ). build (), CategoryResourceIdentifierBuilder . of (). key ( \"category2-key\" ). build ()) . taxCategory ( TaxCategoryResourceIdentifierBuilder . of (). key ( \"tax-category-key\" ). build ()) . state ( StateResourceIdentifierBuilder . of (). key ( \"tax-category-key\" ). build ()) . build (); ````java final PriceDraft priceDraft = PriceDraftBuilder.of() .value(MoneyBuilder.of().centAmount(20L).currencyCode(\"EUR\").build()) .channel(ChannelResourceIdentifierBuilder.of().key(\"channel-key\").build()) .customerGroup( CustomerGroupResourceIdentifierBuilder.of().key(\"customer-group-key\").build()) .custom( CustomFieldsDraftBuilder.of() .type(TypeResourceIdentifierBuilder.of().key(\"type-key\").build()) .fields(FieldContainerBuilder.of().values(Collections.emptyMap()).build()).build()) .build(); - The product projection variant attributes with a type `ReferenceType` do not support the `ResourceIdentifier` yet, for those references you have to provide the `key` value on the `id` field of the reference. This means that calling `getId()` on the reference should return its `key`. ````java final ProductReference productReference = ProductReferenceBuilder.of().id(\"product-key\").build(); final Attribute attr = AttributeBuilder.of().name(\"attribute-name\").value(productReference).build(); For resolving key-value-document (custom object) references on attributes of type Reference , Set of Reference , NestedType or Set of NestedType , The id field of the reference in the attribute should be defined in the correct format. The correct format must have a vertical bar | character between the values of the container and key. For example, if the custom object has a container value container and key value key , the id field should be container|key , also, the key and container value should match the pattern [-_~.a-zA-Z0-9]+ . Please also keep in mind that length of the key is limited to 256 characters max: CustomObject final CustomObjectReference coReference = CustomObjectReferenceBuilder . of (). id ( \"co-container|co-key\" ). build (); final Attribute attr = AttributeBuilder . of (). name ( \"attribute-name\" ). value ( coReference ). build (); SyncOptions \u00b6 After the ProjectApiRoot is set up, a ProductSyncOptions should be built as follows: // instantiating a ProductSyncOptions final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations: errorCallback \u00b6 A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception product draft from the source product projection of the target project (only provided if an existing product projection could be found) the update-actions, which failed (only provided if an existing product projection could be found) final Logger logger = LoggerFactory . getLogger ( ProductSync . class ); final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , productProjection , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build (); warningCallback \u00b6 A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception product draft from the source product projection of the target project (only provided if an existing product projection could be found) final Logger logger = LoggerFactory . getLogger ( ProductSync . class ); final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , productProjection ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build (); beforeUpdateCallback \u00b6 During the sync process, if a target product projection and a product draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify the update actions array with custom actions or discard unwanted actions. The callback provides the following information : product draft from the source product projection from the target project update actions that were calculated after comparing both // Example: Ignore update actions which contain deletion of variants final TriFunction < List < ProductUpdateAction > , ProductDraft , ProductProjection , List < ProductUpdateAction >> beforeUpdateProductCallback = ( updateActions , newProductDraft , oldProduct ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof ProductRemoveVariantActionImpl )) . collect ( Collectors . toList ()); final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateProductCallback ). build (); beforeCreateCallback \u00b6 During the sync process, if a product draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : product draft that should be created // Example: Set publish stage if category references of given product draft exist final Function < ProductDraft , ProductDraft > beforeCreateProductCallback = ( callbackDraft ) -> { List < CategoryResourceIdentifier > categoryResourceIdentifier = callbackDraft . getCategories (); if ( categoryResourceIdentifier != null && ! categoryResourceIdentifier . isEmpty ()) { return ProductDraftBuilder . of ( callbackDraft ). publish ( true ). build (); } return callbackDraft ; }; final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ). beforeCreateCallback ( beforeCreateProductCallback ). build (); batchSize \u00b6 A number that could be used to set the batch size with which product projections are fetched and processed, as product projections are obtained from the target project on commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding product projections from the target project on the commercetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 30 for product sync. final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 50 ). build (); cacheSize \u00b6 In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for product sync. final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build (); syncFilter \u00b6 It represents either a blacklist or a whitelist for filtering certain update action groups. Blacklisting an update action group means that everything in products will be synced except for any group in the blacklist. A typical use case is to blacklist prices when syncing product projections. In other words, syncing everything in product projections except for prices. final ProductSyncOptions syncOptions = syncOptionsBuilder . syncFilter ( ofBlackList ( ActionGroup . PRICES )). build (); Whitelisting an update action group means that the groups in this whitelist will be the only group synced in products. One use case could be to whitelist prices when syncing products. In other words, syncing prices only in product projections and nothing else. final ProductSyncOptions syncOptions = syncOptionsBuilder . syncFilter ( ofWhiteList ( ActionGroup . PRICES )). build (); The list of action groups allowed to be blacklisted or whitelisted on product projections can be found here . ensureChannels \u00b6 A flag to indicate whether the sync process should create a price channel of the given key when it doesn't exist in a target project yet. - If ensureChannels is set to false this products won't be synced and the errorCallback will be triggered. - If ensureChannels is set to true the sync will attempt to create the missing channel with the given key. If it fails to create the price channel, the products won't sync and errorCallback will be triggered. - If not provided, it is set to false by default. final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ). ensureChannels ( true ). build (); Running the sync \u00b6 After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a product sync final ProductSync productSync = new ProductSync ( productSyncOptions ); // execute the sync on your list of products CompletionStage < ProductSyncStatistics > syncStatisticsStage = productSync . sync ( productDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a ProductSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed products and the processing time of the sync in different time units and in a human-readable format. final ProductSyncStatistics stats = syncStatisticsStage . toCompletableFuture (). join (); stats . getReportMessage (); /*Summary: 2000 product(s) were processed in total (1000 created, 995 updated, 5 failed to sync and 0 product(s) with missing reference(s)).*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied. Persistence of ProductDrafts with Irresolvable References \u00b6 A productDraft X could be supplied in with an attribute referencing productDraft Y. It could be that Y is not supplied before X, which means the sync could fail to create/update X. It could also be that Y is not supplied at all in this batch but at a later batch. The library keeps track of such \"referencing\" drafts like X and persists them in storage ( Commercetools platform customObjects in the target project , in this case) to keep them and create/update them accordingly whenever the referenced drafts exist in the target project. The customObject will have a container: \"commercetools-sync-java.UnresolvedReferencesService.productDrafts\" and a key representing the key of the productDraft that is waiting to be created/updated. Here is an example of a CustomObject in the target project that represents a productDraft with productKey1 . It being persisted as CustomObject means that the referenced productDrafts with keys foo and bar do not exist yet. { \"id\" : \"d0fbb69e-76e7-4ec0-893e-3aaab6f4f6b6\" , \"version\" : 1 , \"container\" : \"commercetools-sync-java.UnresolvedReferencesService.productDrafts\" , \"key\" : \"productKey1\" , \"value\" : { \"dependantProductKeys\" : [ \"foo\" , \"bar\" ], \"productDraft\" : { \"productType\" : { \"typeId\" : \"product-type\" , \"id\" : \"main-product-type\" }, \"masterVariant\" : { \"id\" : 1 , \"sku\" : \"white-shirt-1\" , \"key\" : \"white-shirt-1\" , \"prices\" : [], \"images\" : [], \"attributes\" : [ { \"name\" : \"product-reference-set\" , \"value\" : [ { \"typeId\" : \"product\" , \"id\" : \"foo\" }, { \"typeId\" : \"product\" , \"id\" : \"bar\" } ] } ] }, \"key\" : \"productKey1\" } }, \"createdAt\" : \"2019-09-27T13:45:35.495Z\" , \"lastModifiedAt\" : \"2019-09-27T13:45:35.495Z\" , \"lastModifiedBy\" : { \"clientId\" : \"8bV3XSW-taCpi873-GQTa8lf\" , \"isPlatformClient\" : false }, \"createdBy\" : { \"clientId\" : \"8bV3XSW-taCpi873-GQTa8lf\" , \"isPlatformClient\" : false } } As soon, as the referenced productDrafts are supplied to the sync, the draft will be created/updated and the CustomObject will be removed from the target project. Keeping the old custom objects around forever can negatively influence the performance of your project and the time it takes to restore it from a backup. Deleting unused data ensures the best performance for your project. Please have a look into the Cleanup guide to cleanup old unresolved custom objects. More examples of how to use the sync \u00b6 Sync from another commercetools project as a source . Sync from an external source . Sync with blacklisting/whitelisting . Make sure to read the Important Usage Tips for optimal performance. Build all update actions \u00b6 A utility method provided by the library to compare a ProductProjection with a new ProductDraft and results in a list of update actions. List < ProductUpdateAction > updateActions = ProductSyncUtils . buildActions ( productProjection , productDraft , productSyncOptions , attributesMetaData ); Examples of its usage can be found in the tests here . Build particular update action(s) \u00b6 Utility methods provided by the library to compare the specific fields of a ProductProjection and a new ProductDraft, build the update action. One example is the buildChangeNameUpdateAction which compares names: Optional < ProductUpdateAction > updateAction = buildChangeNameUpdateAction ( oldProductProjection , productDraft ); More examples of those utils for different fields can be found here . Caveats \u00b6 The commercetools-java-sync library has some exceptions to the data it can sync, particularly around product variant attributes. List of supported variant attributes, with an AttributeType : ReferenceType , that can be synced: referenceTypeId supported \u201ccart\u201d \u274c \u201ccategory\u201d \u2705 \u201cchannel\u201d \u274c \u201ccustomer\u201d \u2705 \u201ckey-value-document\u201d \u2705 \u201corder\u201d \u274c \u201cproduct\u201d \u2705 \u201cproduct-type\u201d \u2705 \u201creview\u201d \u274c \u201cstate\u201d \u2705 \u201cshipping-method\u201d \u274c \u201czone\u201d \u274c Support for syncing variant attributes with an AttributeType of SetType of ReferenceType (of elementType: ReferenceType ) with any of the aforementioned referenceTypeId , accordingly applies. Support for syncing variant attributes with an AttributeType of NestedType which has an attribute inside of it of ReferenceType with any of the aforementioned referenceTypeId , accordingly applies. Syncing products with cyclic dependencies are not supported yet. An example of a cyclic dependency is a product a which references a product b and at the same time product b references product a . Cycles can contain more than 2 products. For example: a -> b -> c -> a . If there are such cycles, the sync will consider all the products in the cycle as products with missing parents. They will be persisted as custom objects in the target project. Migration Guide \u00b6 The product-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies> Client configuration and creation \u00b6 For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document . Signature of ProductSyncOptions \u00b6 As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with ProductDraft , ProductProjection and ProductUpdateAction from package com.commercetools.api.models.product.* Note: Type UpdateAction<Product> has changed to ProductUpdateAction . Make sure you create and supply a specific ProductUpdateAction in beforeUpdateCallback . Therefore you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a product update action to change name taking the 'newName' of the productDraft final Function < LocalizedString , ProductUpdateAction > createBeforeUpdateAction = ( newName ) -> ProductChangeNameAction . builder (). name ( newName ). staged ( true ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < ProductUpdateAction > , ProductDraft , ProductProjection , List < ProductUpdateAction >> beforeUpdateProductCallback = ( updateActions , newProductDraft , oldProduct ) -> { final ProductUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newProductDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; }; Build ProductDraft (syncing from external project) \u00b6 The product-sync expects a list of ProductDraft s to process. If you use java-sync-library to sync your products from any external system into a commercetools platform project you have to convert your data into CTP compatible ProductDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // ProductDraftBuilder in v1 takes parameters 'productType', 'name', 'slug' and optional 'masterVariant' final ProductDraft productDraft = ProductDraftBuilder . of ( mock ( ProductType . class ), ofEnglish ( \"name\" ), ofEnglish ( \"slug\" ), emptyList ()) . key ( \"product-key\" ) . build (); // ProductDraftBuilder in v2 final ProductDraft productDraft = ProductDraftBuilder . of () . productType ( ProductTypeResourceIdentifierBuilder . of (). key ( \"product-type-key\" ). build ()) . name ( LocalizedString . ofEnglish ( \"name\" )) . slug ( LocalizedString . ofEnglish ( \"slug\" )) . masterVariant ( masterVariant ) . key ( \"product-key\" ) . build (); For more information, see the Guide to replace DraftBuilders . Query for Products (syncing from CTP project) \u00b6 If you sync products between different commercetools projects you probably use ProductTransformUtils#toProductDrafts to transform ProductProjection into ProductDraft which can be used by the product-sync. However, if you need to query Products / ProductProjections from a commercetools project instead of passing ProductQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: ProductProjectionQuery to fetch all staged product projections final ProductProjectionQuery query = ProductProjectionQuery . ofStaged (); final PagedQueryResult < ProductProjection > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all staged product projections in one line final ProductProjectionPagedQueryResponse result = apiRoot . productProjections (). get (). addStaged ( true ). executeBlocking (). getBody (); Read more about querying resources. JVM-SDK-V2 migration guide \u00b6 On any other needs to migrate your project using jvm-sdk-v2 please refer to it's Migration Guide .","title":"Product Sync"},{"location":"usage/PRODUCT_SYNC/#product-sync","text":"The module used for importing/syncing Products into a commercetools project. It also provides utilities for generating update actions based on the comparison of a ProductProjection against a ProductDraft . Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize syncFilter ensureChannels Running the sync Persistence of ProductDrafts with Irresolvable References More examples of how to use the sync Build all update actions Build particular update action(s) Caveats Migration Guide Client configuration and creation Signature of ProductSyncOptions Build ProductDraft (syncing from external project) Query for Products (syncing from CTP project) JVM-SDK-V2 migration guide","title":"Product Sync"},{"location":"usage/PRODUCT_SYNC/#usage","text":"","title":"Usage"},{"location":"usage/PRODUCT_SYNC/#prerequisites","text":"","title":"Prerequisites"},{"location":"usage/PRODUCT_SYNC/#projectapiroot","text":"Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" );","title":"ProjectApiRoot"},{"location":"usage/PRODUCT_SYNC/#required-fields","text":"The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note ProductDraft key Also, the products in the target project are expected to have the key fields set. ProductVariantDraft key , sku Also, all the variants in the target project are expected to have the key and sku fields set.","title":"Required Fields"},{"location":"usage/PRODUCT_SYNC/#reference-resolution","text":"In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in the sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type Necessity productType ProductTypeResourceIdentifier Required categories List of CategoryResourceIdentifier Optional taxCategory TaxCategoryResourceIdentifier Optional state StateResourceIdentifier Optional variants.prices.channel ChannelResourceIdentifier Optional variants.prices.customerGroup CustomerGroupResourceIdentifier Optional variants.prices.custom.type TypeResourceIdentifier Required for custom (CustomFieldsDraft) variants.assets.custom.type TypeResourceIdentifier Required for custom (CustomFieldsDraft) variants.attributes Only the attributes with type ReferenceType , SetType with elementType as ReferenceType and NestedType requires key on the id field of the ReferenceType . Optional Note that a reference without the key field will be considered as existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution.","title":"Reference Resolution"},{"location":"usage/PRODUCT_SYNC/#syncing-from-a-commercetools-project","text":"When syncing from a source commercetools project, you can use toProductDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a ProductProjection to ProductDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build a ProductQuery for fetching products from a source CTP project without any references expanded for the sync: final ByProjectKeyProductProjectionsGet byProjectKeyProductsGet = getCtpClient (). productProjections (). get (). addStaged ( true ); // Query all product projections (NOTE this is only for example, please adjust your logic) final List < ProductProjection > products = QueryUtils . queryAll ( byProjectKeyProductsGet , ( productProjections ) -> productProjections ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the ProductProjections to ProductDraft , Utils method toProductDrafts requires ProjectApiRoot , implementation of ReferenceIdToKeyCache and list of ProductProjection as parameters. For cache implementation, You can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from ProductProjection to ProductDraft. With help of the cache same reference keys can be reused. CompletableFuture < List < ProductDraft >> productDrafts = ProductTransformUtils . toProductDrafts ( client , referenceIdToKeyCache , products );","title":"Syncing from a commercetools project"},{"location":"usage/PRODUCT_SYNC/#syncing-from-an-external-resource","text":"When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final ProductDraft productDraft = ProductDraftBuilder . of () . productType ( ProductTypeResourceIdentifierBuilder . of (). key ( \"product-type-key\" ). build ()) . name ( LocalizedString . ofEnglish ( \"name\" )) . slug ( LocalizedString . ofEnglish ( \"slug\" )) . masterVariant ( masterVariant ) . key ( \"product-key\" ) . categories ( CategoryResourceIdentifierBuilder . of (). key ( \"category1-key\" ). build (), CategoryResourceIdentifierBuilder . of (). key ( \"category2-key\" ). build ()) . taxCategory ( TaxCategoryResourceIdentifierBuilder . of (). key ( \"tax-category-key\" ). build ()) . state ( StateResourceIdentifierBuilder . of (). key ( \"tax-category-key\" ). build ()) . build (); ````java final PriceDraft priceDraft = PriceDraftBuilder.of() .value(MoneyBuilder.of().centAmount(20L).currencyCode(\"EUR\").build()) .channel(ChannelResourceIdentifierBuilder.of().key(\"channel-key\").build()) .customerGroup( CustomerGroupResourceIdentifierBuilder.of().key(\"customer-group-key\").build()) .custom( CustomFieldsDraftBuilder.of() .type(TypeResourceIdentifierBuilder.of().key(\"type-key\").build()) .fields(FieldContainerBuilder.of().values(Collections.emptyMap()).build()).build()) .build(); - The product projection variant attributes with a type `ReferenceType` do not support the `ResourceIdentifier` yet, for those references you have to provide the `key` value on the `id` field of the reference. This means that calling `getId()` on the reference should return its `key`. ````java final ProductReference productReference = ProductReferenceBuilder.of().id(\"product-key\").build(); final Attribute attr = AttributeBuilder.of().name(\"attribute-name\").value(productReference).build(); For resolving key-value-document (custom object) references on attributes of type Reference , Set of Reference , NestedType or Set of NestedType , The id field of the reference in the attribute should be defined in the correct format. The correct format must have a vertical bar | character between the values of the container and key. For example, if the custom object has a container value container and key value key , the id field should be container|key , also, the key and container value should match the pattern [-_~.a-zA-Z0-9]+ . Please also keep in mind that length of the key is limited to 256 characters max: CustomObject final CustomObjectReference coReference = CustomObjectReferenceBuilder . of (). id ( \"co-container|co-key\" ). build (); final Attribute attr = AttributeBuilder . of (). name ( \"attribute-name\" ). value ( coReference ). build ();","title":"Syncing from an external resource"},{"location":"usage/PRODUCT_SYNC/#syncoptions","text":"After the ProjectApiRoot is set up, a ProductSyncOptions should be built as follows: // instantiating a ProductSyncOptions final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations:","title":"SyncOptions"},{"location":"usage/PRODUCT_SYNC/#errorcallback","text":"A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception product draft from the source product projection of the target project (only provided if an existing product projection could be found) the update-actions, which failed (only provided if an existing product projection could be found) final Logger logger = LoggerFactory . getLogger ( ProductSync . class ); final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , productProjection , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"errorCallback"},{"location":"usage/PRODUCT_SYNC/#warningcallback","text":"A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception product draft from the source product projection of the target project (only provided if an existing product projection could be found) final Logger logger = LoggerFactory . getLogger ( ProductSync . class ); final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , productProjection ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"warningCallback"},{"location":"usage/PRODUCT_SYNC/#beforeupdatecallback","text":"During the sync process, if a target product projection and a product draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify the update actions array with custom actions or discard unwanted actions. The callback provides the following information : product draft from the source product projection from the target project update actions that were calculated after comparing both // Example: Ignore update actions which contain deletion of variants final TriFunction < List < ProductUpdateAction > , ProductDraft , ProductProjection , List < ProductUpdateAction >> beforeUpdateProductCallback = ( updateActions , newProductDraft , oldProduct ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof ProductRemoveVariantActionImpl )) . collect ( Collectors . toList ()); final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateProductCallback ). build ();","title":"beforeUpdateCallback"},{"location":"usage/PRODUCT_SYNC/#beforecreatecallback","text":"During the sync process, if a product draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : product draft that should be created // Example: Set publish stage if category references of given product draft exist final Function < ProductDraft , ProductDraft > beforeCreateProductCallback = ( callbackDraft ) -> { List < CategoryResourceIdentifier > categoryResourceIdentifier = callbackDraft . getCategories (); if ( categoryResourceIdentifier != null && ! categoryResourceIdentifier . isEmpty ()) { return ProductDraftBuilder . of ( callbackDraft ). publish ( true ). build (); } return callbackDraft ; }; final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ). beforeCreateCallback ( beforeCreateProductCallback ). build ();","title":"beforeCreateCallback"},{"location":"usage/PRODUCT_SYNC/#batchsize","text":"A number that could be used to set the batch size with which product projections are fetched and processed, as product projections are obtained from the target project on commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding product projections from the target project on the commercetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 30 for product sync. final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 50 ). build ();","title":"batchSize"},{"location":"usage/PRODUCT_SYNC/#cachesize","text":"In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for product sync. final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build ();","title":"cacheSize"},{"location":"usage/PRODUCT_SYNC/#syncfilter","text":"It represents either a blacklist or a whitelist for filtering certain update action groups. Blacklisting an update action group means that everything in products will be synced except for any group in the blacklist. A typical use case is to blacklist prices when syncing product projections. In other words, syncing everything in product projections except for prices. final ProductSyncOptions syncOptions = syncOptionsBuilder . syncFilter ( ofBlackList ( ActionGroup . PRICES )). build (); Whitelisting an update action group means that the groups in this whitelist will be the only group synced in products. One use case could be to whitelist prices when syncing products. In other words, syncing prices only in product projections and nothing else. final ProductSyncOptions syncOptions = syncOptionsBuilder . syncFilter ( ofWhiteList ( ActionGroup . PRICES )). build (); The list of action groups allowed to be blacklisted or whitelisted on product projections can be found here .","title":"syncFilter"},{"location":"usage/PRODUCT_SYNC/#ensurechannels","text":"A flag to indicate whether the sync process should create a price channel of the given key when it doesn't exist in a target project yet. - If ensureChannels is set to false this products won't be synced and the errorCallback will be triggered. - If ensureChannels is set to true the sync will attempt to create the missing channel with the given key. If it fails to create the price channel, the products won't sync and errorCallback will be triggered. - If not provided, it is set to false by default. final ProductSyncOptions productSyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ). ensureChannels ( true ). build ();","title":"ensureChannels"},{"location":"usage/PRODUCT_SYNC/#running-the-sync","text":"After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a product sync final ProductSync productSync = new ProductSync ( productSyncOptions ); // execute the sync on your list of products CompletionStage < ProductSyncStatistics > syncStatisticsStage = productSync . sync ( productDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a ProductSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed products and the processing time of the sync in different time units and in a human-readable format. final ProductSyncStatistics stats = syncStatisticsStage . toCompletableFuture (). join (); stats . getReportMessage (); /*Summary: 2000 product(s) were processed in total (1000 created, 995 updated, 5 failed to sync and 0 product(s) with missing reference(s)).*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied.","title":"Running the sync"},{"location":"usage/PRODUCT_SYNC/#persistence-of-productdrafts-with-irresolvable-references","text":"A productDraft X could be supplied in with an attribute referencing productDraft Y. It could be that Y is not supplied before X, which means the sync could fail to create/update X. It could also be that Y is not supplied at all in this batch but at a later batch. The library keeps track of such \"referencing\" drafts like X and persists them in storage ( Commercetools platform customObjects in the target project , in this case) to keep them and create/update them accordingly whenever the referenced drafts exist in the target project. The customObject will have a container: \"commercetools-sync-java.UnresolvedReferencesService.productDrafts\" and a key representing the key of the productDraft that is waiting to be created/updated. Here is an example of a CustomObject in the target project that represents a productDraft with productKey1 . It being persisted as CustomObject means that the referenced productDrafts with keys foo and bar do not exist yet. { \"id\" : \"d0fbb69e-76e7-4ec0-893e-3aaab6f4f6b6\" , \"version\" : 1 , \"container\" : \"commercetools-sync-java.UnresolvedReferencesService.productDrafts\" , \"key\" : \"productKey1\" , \"value\" : { \"dependantProductKeys\" : [ \"foo\" , \"bar\" ], \"productDraft\" : { \"productType\" : { \"typeId\" : \"product-type\" , \"id\" : \"main-product-type\" }, \"masterVariant\" : { \"id\" : 1 , \"sku\" : \"white-shirt-1\" , \"key\" : \"white-shirt-1\" , \"prices\" : [], \"images\" : [], \"attributes\" : [ { \"name\" : \"product-reference-set\" , \"value\" : [ { \"typeId\" : \"product\" , \"id\" : \"foo\" }, { \"typeId\" : \"product\" , \"id\" : \"bar\" } ] } ] }, \"key\" : \"productKey1\" } }, \"createdAt\" : \"2019-09-27T13:45:35.495Z\" , \"lastModifiedAt\" : \"2019-09-27T13:45:35.495Z\" , \"lastModifiedBy\" : { \"clientId\" : \"8bV3XSW-taCpi873-GQTa8lf\" , \"isPlatformClient\" : false }, \"createdBy\" : { \"clientId\" : \"8bV3XSW-taCpi873-GQTa8lf\" , \"isPlatformClient\" : false } } As soon, as the referenced productDrafts are supplied to the sync, the draft will be created/updated and the CustomObject will be removed from the target project. Keeping the old custom objects around forever can negatively influence the performance of your project and the time it takes to restore it from a backup. Deleting unused data ensures the best performance for your project. Please have a look into the Cleanup guide to cleanup old unresolved custom objects.","title":"Persistence of ProductDrafts with Irresolvable References"},{"location":"usage/PRODUCT_SYNC/#more-examples-of-how-to-use-the-sync","text":"Sync from another commercetools project as a source . Sync from an external source . Sync with blacklisting/whitelisting . Make sure to read the Important Usage Tips for optimal performance.","title":"More examples of how to use the sync"},{"location":"usage/PRODUCT_SYNC/#build-all-update-actions","text":"A utility method provided by the library to compare a ProductProjection with a new ProductDraft and results in a list of update actions. List < ProductUpdateAction > updateActions = ProductSyncUtils . buildActions ( productProjection , productDraft , productSyncOptions , attributesMetaData ); Examples of its usage can be found in the tests here .","title":"Build all update actions"},{"location":"usage/PRODUCT_SYNC/#build-particular-update-actions","text":"Utility methods provided by the library to compare the specific fields of a ProductProjection and a new ProductDraft, build the update action. One example is the buildChangeNameUpdateAction which compares names: Optional < ProductUpdateAction > updateAction = buildChangeNameUpdateAction ( oldProductProjection , productDraft ); More examples of those utils for different fields can be found here .","title":"Build particular update action(s)"},{"location":"usage/PRODUCT_SYNC/#caveats","text":"The commercetools-java-sync library has some exceptions to the data it can sync, particularly around product variant attributes. List of supported variant attributes, with an AttributeType : ReferenceType , that can be synced: referenceTypeId supported \u201ccart\u201d \u274c \u201ccategory\u201d \u2705 \u201cchannel\u201d \u274c \u201ccustomer\u201d \u2705 \u201ckey-value-document\u201d \u2705 \u201corder\u201d \u274c \u201cproduct\u201d \u2705 \u201cproduct-type\u201d \u2705 \u201creview\u201d \u274c \u201cstate\u201d \u2705 \u201cshipping-method\u201d \u274c \u201czone\u201d \u274c Support for syncing variant attributes with an AttributeType of SetType of ReferenceType (of elementType: ReferenceType ) with any of the aforementioned referenceTypeId , accordingly applies. Support for syncing variant attributes with an AttributeType of NestedType which has an attribute inside of it of ReferenceType with any of the aforementioned referenceTypeId , accordingly applies. Syncing products with cyclic dependencies are not supported yet. An example of a cyclic dependency is a product a which references a product b and at the same time product b references product a . Cycles can contain more than 2 products. For example: a -> b -> c -> a . If there are such cycles, the sync will consider all the products in the cycle as products with missing parents. They will be persisted as custom objects in the target project.","title":"Caveats"},{"location":"usage/PRODUCT_SYNC/#migration-guide","text":"The product-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies>","title":"Migration Guide"},{"location":"usage/PRODUCT_SYNC/#client-configuration-and-creation","text":"For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document .","title":"Client configuration and creation"},{"location":"usage/PRODUCT_SYNC/#signature-of-productsyncoptions","text":"As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with ProductDraft , ProductProjection and ProductUpdateAction from package com.commercetools.api.models.product.* Note: Type UpdateAction<Product> has changed to ProductUpdateAction . Make sure you create and supply a specific ProductUpdateAction in beforeUpdateCallback . Therefore you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a product update action to change name taking the 'newName' of the productDraft final Function < LocalizedString , ProductUpdateAction > createBeforeUpdateAction = ( newName ) -> ProductChangeNameAction . builder (). name ( newName ). staged ( true ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < ProductUpdateAction > , ProductDraft , ProductProjection , List < ProductUpdateAction >> beforeUpdateProductCallback = ( updateActions , newProductDraft , oldProduct ) -> { final ProductUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newProductDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; };","title":"Signature of ProductSyncOptions"},{"location":"usage/PRODUCT_SYNC/#build-productdraft-syncing-from-external-project","text":"The product-sync expects a list of ProductDraft s to process. If you use java-sync-library to sync your products from any external system into a commercetools platform project you have to convert your data into CTP compatible ProductDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // ProductDraftBuilder in v1 takes parameters 'productType', 'name', 'slug' and optional 'masterVariant' final ProductDraft productDraft = ProductDraftBuilder . of ( mock ( ProductType . class ), ofEnglish ( \"name\" ), ofEnglish ( \"slug\" ), emptyList ()) . key ( \"product-key\" ) . build (); // ProductDraftBuilder in v2 final ProductDraft productDraft = ProductDraftBuilder . of () . productType ( ProductTypeResourceIdentifierBuilder . of (). key ( \"product-type-key\" ). build ()) . name ( LocalizedString . ofEnglish ( \"name\" )) . slug ( LocalizedString . ofEnglish ( \"slug\" )) . masterVariant ( masterVariant ) . key ( \"product-key\" ) . build (); For more information, see the Guide to replace DraftBuilders .","title":"Build ProductDraft (syncing from external project)"},{"location":"usage/PRODUCT_SYNC/#query-for-products-syncing-from-ctp-project","text":"If you sync products between different commercetools projects you probably use ProductTransformUtils#toProductDrafts to transform ProductProjection into ProductDraft which can be used by the product-sync. However, if you need to query Products / ProductProjections from a commercetools project instead of passing ProductQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: ProductProjectionQuery to fetch all staged product projections final ProductProjectionQuery query = ProductProjectionQuery . ofStaged (); final PagedQueryResult < ProductProjection > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all staged product projections in one line final ProductProjectionPagedQueryResponse result = apiRoot . productProjections (). get (). addStaged ( true ). executeBlocking (). getBody (); Read more about querying resources.","title":"Query for Products (syncing from CTP project)"},{"location":"usage/PRODUCT_SYNC/#jvm-sdk-v2-migration-guide","text":"On any other needs to migrate your project using jvm-sdk-v2 please refer to it's Migration Guide .","title":"JVM-SDK-V2 migration guide"},{"location":"usage/PRODUCT_TYPE_SYNC/","text":"ProductType Sync \u00b6 The module used for importing/syncing ProductTypes into a commercetools project. It also provides utilities for generating update actions based on the comparison of a ProductType against a ProductTypeDraft . Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync Important to Note More examples of how to use the sync Build all update actions Build particular update action(s) Caveats Migration Guide Client configuration and creation Signature of ProductTypeSyncOptions Build ProductTypeDraft (syncing from external project) Query for ProductTypes (syncing from CTP project) JVM-SDK-V2 migration guide Usage \u00b6 Prerequisites \u00b6 ProjectApiRoot \u00b6 Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create the required ClientCredentials for client creation, please utilize the ClientCredentialsBuilder provided in the java-sdk-v2 Client OAUTH2 package . If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" ); Required Fields \u00b6 The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note ProductTypeDraft key Also, the product types in the target project are expected to have the key fields set. Reference Resolution \u00b6 In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in the sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type attributes Only the attributes with type AttributeNestedType and AttributeSetType with elementType as AttributeNestedType requires key on the id field of the ProductTypeReference . Note that a reference without the key field will be considered as an existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution. Syncing from a commercetools project \u00b6 When syncing from a source commercetools project, you can use toProductTypeDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a ProductType to ProductTypeDraft . It can be configured to use a cache that will speed up the reference resolution performed during the sync, for example: // Build ByProjectKeyProductTypesGet for fetching product-types from a source CTP project without any references expanded for the sync: final ByProjectKeyProductTypesGet byProjectKeyProductTypesGet = client . productTypes (). get (); // Query all product-types (NOTE this is just for example, please adjust your logic) final List < ProductTypes > productTypes = QueryUtils . queryAll ( byProjectKeyProductTypesGet , ( productTypes ) -> productTypes ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the ProductType to ProductTypeDraft , Utils method toProductTypeDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and a list of productTypes as parameters. For cache implementation, you have two options: you can either use your own cache implementation or utilize the class CaffeineReferenceIdToKeyCacheImpl provided in the library. This class implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy.Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from ProductType to ProductTypeDraft. With help of the cache same reference keys can be reused. CompletableFuture < List < ProductTypeDraft >> productTypeDrafts = ProductTransformUtils . toProductTypeDrafts ( client , referenceIdToKeyCache , productTypes ); Syncing from an external resource \u00b6 Attributes with type AttributeNestedType do not support the ResourceIdentifier yet, for those references you have to provide the key value on the id field of the reference. This means that calling getId() on the reference should return its key . final AttributeDefinitionDraft nestedTypeAttr = AttributeDefinitionDraftBuilder . of () . type ( AttributeNestedTypeBuilder . of () . typeReference ( ProductTypeReferenceBuilder . of (). id ( \"product-type-key\" ). build ()) // note that key is provided in the id field of reference . build ()) . name ( \"attrNestedType\" ) . label ( LocalizedString . ofEnglish ( \"attrNestedType\" )) . isRequired ( true ) . build (); final AttributeDefinitionDraft setOfNestedTypeAttr = AttributeDefinitionDraftBuilder . of () . type ( AttributeSetTypeBuilder . of () . elementType ( AttributeNestedTypeBuilder . of () . typeReference ( ProductTypeReferenceBuilder . of () . id ( \"product-type-key\" ). build ()) . build ()) . build ()) . name ( \"attrNestedType\" ) . label ( LocalizedString . ofEnglish ( \"attrNestedType\" )) . isRequired ( true ) . build (); final ProductTypeDraft productTypeDraft = ProductTypeDraftBuilder . of () . name ( \"foo\" ) . description ( \"description\" ) . key ( \"key\" ) . attributes ( nestedTypeAttr , setOfNestedTypeAttr ) . build (); SyncOptions \u00b6 After the projectApiRoot is setup, a ProductTypeSyncOptions should be built as follows: // instantiating a ProductTypeSyncOptions final ProductTypeSyncOptions productTypeSyncOptions = ProductTypeSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations: errorCallback \u00b6 A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception product type draft from the source product type of the target project (only provided if an existing product type could be found) the update-actions, which failed (only provided if an existing product type could be found) final Logger logger = LoggerFactory . getLogger ( ProductTypeSync . class ); final ProductTypeSyncOptions productTypeSyncOptions = ProductTypeSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , productType , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build (); warningCallback \u00b6 A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception product type draft from the source product type of the target project (only provided if an existing product type could be found) final Logger logger = LoggerFactory . getLogger ( ProductTypeSync . class ); final ProductTypeSyncOptions productTypeSyncOptions = ProductTypeSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , productType ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build (); beforeUpdateCallback \u00b6 During the sync process, if a target product type and a product type draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : product type draft from the source product type from the target project update actions that were calculated after comparing both final TriFunction < List < ProductTypeUpdateAction > , ProductTypeDraft , ProductType , List < ProductTypeUpdateAction >> beforeUpdateProductTypeCallback = ( updateActions , newProductTypeDraft , oldProductType ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof ProductTypeRemoveAttributeDefinitionAction )) . collect ( Collectors . toList ()); final ProductTypeSyncOptions productTypeSyncOptions = ProductTypeSyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateProductTypeCallback ). build (); beforeCreateCallback \u00b6 During the sync process, if a product type draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : product type draft that should be created Please refer to example in product sync document . batchSize \u00b6 A number that could be used to set the batch size with which product types are fetched and processed, as product types are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding product types from the target project on the commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for product type sync. final ProductTypeSyncOptions productTypeSyncOptions = ProductTypeSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build (); cacheSize \u00b6 In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for product type sync. final ProductTypeSyncOptions productTypeSyncOptions = ProductTypeSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build (); Running the sync \u00b6 After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a product type sync final ProductTypeSync productTypeSync = new ProductTypeSync ( productTypeSyncOptions ); // execute the sync on your list of product types CompletionStage < ProductTypeSyncStatistics > syncStatisticsStage = productTypeSync . sync ( productTypeDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a ProductTypeSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed product types and the processing time of the last sync batch in different time units and in a human-readable format. final ProductTypeSyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 2000 products types were processed in total (1000 created, 995 updated, 5 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied. Important to Note \u00b6 If two matching attributeDefinition s (old and new) on the matching productType s (old and new) have a different AttributeType , the sync will remove the existing attributeDefinition and then add a new attributeDefinition with the new AttributeType . The attributeDefinition for which the AttributeType is not defined ( null ) will not be synced. More examples of how to use the sync \u00b6 Sync from another CTP project as a source . Sync from an external source . Make sure to read the Important Usage Tips for optimal performance. Build all update actions \u00b6 A utility method provided by the library to compare a ProductType with a new ProductTypeDraft and results in a list of product type update actions. List < ProductTypeUpdateAction > updateActions = ProductTypeSyncUtils . buildActions ( productType , productTypeDraft , productTypeSyncOptions ); Build particular update action(s) \u00b6 Utility methods provided by the library to compare the specific fields of a ProductType and a new ProductTypeDraft, and in turn, build the update action. One example is the buildChangeNameUpdateAction which compares names: Optional < ProductTypeUpdateAction > updateAction = ProductTypeUpdateActionUtils . buildChangeNameAction ( oldProductType , productTypeDraft ); More examples of those utils for different fields can be found here . Caveats \u00b6 The order of attribute definitions in the synced product types is not guaranteed. Changing the attribute definition type is not supported. Instead, remove and re-add it with a new type manually, either over API or merchant center. For more information please check this ADR . Migration Guide \u00b6 The producttype-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies> Client configuration and creation \u00b6 For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document . Signature of ProductTypeSyncOptions \u00b6 As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with ProductTypeDraft , ProductType and ProductTypeUpdateAction from package com.commercetools.api.models.product_type.* Note: Type UpdateAction<ProductType> has changed to ProductTypeUpdateAction . Make sure you create and supply a specific ProductTypeUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a producttype update action to change name taking the 'newName' of the productTypeDraft final Function < LocalizedString , ProductTypeUpdateAction > createBeforeUpdateAction = ( newName ) -> ProductTypeChangeNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < ProductTypeUpdateAction > , ProductTypeDraft , ProductType , List < ProductTypeUpdateAction >> beforeUpdateProductTypeCallback = ( updateActions , newProductTypeDraft , oldProductType ) -> { final ProductTypeUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newProductTypeDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; }; Build ProductTypeDraft (syncing from external project) \u00b6 The producttype-sync expects a list of ProductTypeDraft s to process. If you use java-sync-library to sync your producttypes from any external system into a commercetools platform project you have to convert your data into CTP compatible ProductTypeDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // SDK v1: ProductTypeDraftBuilder.of takes parameters 'key', 'name', 'description' and list of 'attributes' final ProductTypeDraft productTypeDraft = ProductTypeDraftBuilder . of ( \"key\" , \"name\" , \"description\" , emptyList ()) . build (); // SDK v2: ProductTypeDraftBuilder without draftTemplate final ProductTypeDraft productTypeDraft = ProductTypeDraftBuilder . of () . description ( \"product-type-description\" ) . key ( \"product-type-key\" ) . name ( \"product-type-name\" ) . build (); For more information, see the Guide to replace DraftBuilders . Query for ProductTypes (syncing from CTP project) \u00b6 If you sync producttypes between different commercetools projects you probably use ProductTypeTransformUtils#toProductTypeDrafts to transform ProductType into ProductTypeDraft which can be used by the producttype-sync. However, if you need to query ProductTypes from a commercetools project instead of passing ProductTypeQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: ProductTypeQuery to fetch all producttypes final ProductTypeQuery query = ProductTypeQuery . of (); final PagedQueryResult < ProductType > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all producttypes in one line final ProductTypePagedQueryResponse result = apiRoot . productTypes (). get (). executeBlocking (). getBody (); Read more about querying resources. JVM-SDK-V2 migration guide \u00b6 On any other needs to migrate your project using jvm-sdk-v2 please refer to its Migration Guide .","title":"ProductType Sync"},{"location":"usage/PRODUCT_TYPE_SYNC/#producttype-sync","text":"The module used for importing/syncing ProductTypes into a commercetools project. It also provides utilities for generating update actions based on the comparison of a ProductType against a ProductTypeDraft . Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync Important to Note More examples of how to use the sync Build all update actions Build particular update action(s) Caveats Migration Guide Client configuration and creation Signature of ProductTypeSyncOptions Build ProductTypeDraft (syncing from external project) Query for ProductTypes (syncing from CTP project) JVM-SDK-V2 migration guide","title":"ProductType Sync"},{"location":"usage/PRODUCT_TYPE_SYNC/#usage","text":"","title":"Usage"},{"location":"usage/PRODUCT_TYPE_SYNC/#prerequisites","text":"","title":"Prerequisites"},{"location":"usage/PRODUCT_TYPE_SYNC/#projectapiroot","text":"Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create the required ClientCredentials for client creation, please utilize the ClientCredentialsBuilder provided in the java-sdk-v2 Client OAUTH2 package . If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" );","title":"ProjectApiRoot"},{"location":"usage/PRODUCT_TYPE_SYNC/#required-fields","text":"The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note ProductTypeDraft key Also, the product types in the target project are expected to have the key fields set.","title":"Required Fields"},{"location":"usage/PRODUCT_TYPE_SYNC/#reference-resolution","text":"In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in the sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type attributes Only the attributes with type AttributeNestedType and AttributeSetType with elementType as AttributeNestedType requires key on the id field of the ProductTypeReference . Note that a reference without the key field will be considered as an existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution.","title":"Reference Resolution"},{"location":"usage/PRODUCT_TYPE_SYNC/#syncing-from-a-commercetools-project","text":"When syncing from a source commercetools project, you can use toProductTypeDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a ProductType to ProductTypeDraft . It can be configured to use a cache that will speed up the reference resolution performed during the sync, for example: // Build ByProjectKeyProductTypesGet for fetching product-types from a source CTP project without any references expanded for the sync: final ByProjectKeyProductTypesGet byProjectKeyProductTypesGet = client . productTypes (). get (); // Query all product-types (NOTE this is just for example, please adjust your logic) final List < ProductTypes > productTypes = QueryUtils . queryAll ( byProjectKeyProductTypesGet , ( productTypes ) -> productTypes ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the ProductType to ProductTypeDraft , Utils method toProductTypeDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and a list of productTypes as parameters. For cache implementation, you have two options: you can either use your own cache implementation or utilize the class CaffeineReferenceIdToKeyCacheImpl provided in the library. This class implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy.Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from ProductType to ProductTypeDraft. With help of the cache same reference keys can be reused. CompletableFuture < List < ProductTypeDraft >> productTypeDrafts = ProductTransformUtils . toProductTypeDrafts ( client , referenceIdToKeyCache , productTypes );","title":"Syncing from a commercetools project"},{"location":"usage/PRODUCT_TYPE_SYNC/#syncing-from-an-external-resource","text":"Attributes with type AttributeNestedType do not support the ResourceIdentifier yet, for those references you have to provide the key value on the id field of the reference. This means that calling getId() on the reference should return its key . final AttributeDefinitionDraft nestedTypeAttr = AttributeDefinitionDraftBuilder . of () . type ( AttributeNestedTypeBuilder . of () . typeReference ( ProductTypeReferenceBuilder . of (). id ( \"product-type-key\" ). build ()) // note that key is provided in the id field of reference . build ()) . name ( \"attrNestedType\" ) . label ( LocalizedString . ofEnglish ( \"attrNestedType\" )) . isRequired ( true ) . build (); final AttributeDefinitionDraft setOfNestedTypeAttr = AttributeDefinitionDraftBuilder . of () . type ( AttributeSetTypeBuilder . of () . elementType ( AttributeNestedTypeBuilder . of () . typeReference ( ProductTypeReferenceBuilder . of () . id ( \"product-type-key\" ). build ()) . build ()) . build ()) . name ( \"attrNestedType\" ) . label ( LocalizedString . ofEnglish ( \"attrNestedType\" )) . isRequired ( true ) . build (); final ProductTypeDraft productTypeDraft = ProductTypeDraftBuilder . of () . name ( \"foo\" ) . description ( \"description\" ) . key ( \"key\" ) . attributes ( nestedTypeAttr , setOfNestedTypeAttr ) . build ();","title":"Syncing from an external resource"},{"location":"usage/PRODUCT_TYPE_SYNC/#syncoptions","text":"After the projectApiRoot is setup, a ProductTypeSyncOptions should be built as follows: // instantiating a ProductTypeSyncOptions final ProductTypeSyncOptions productTypeSyncOptions = ProductTypeSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations:","title":"SyncOptions"},{"location":"usage/PRODUCT_TYPE_SYNC/#errorcallback","text":"A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception product type draft from the source product type of the target project (only provided if an existing product type could be found) the update-actions, which failed (only provided if an existing product type could be found) final Logger logger = LoggerFactory . getLogger ( ProductTypeSync . class ); final ProductTypeSyncOptions productTypeSyncOptions = ProductTypeSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , productType , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"errorCallback"},{"location":"usage/PRODUCT_TYPE_SYNC/#warningcallback","text":"A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception product type draft from the source product type of the target project (only provided if an existing product type could be found) final Logger logger = LoggerFactory . getLogger ( ProductTypeSync . class ); final ProductTypeSyncOptions productTypeSyncOptions = ProductTypeSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , productType ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"warningCallback"},{"location":"usage/PRODUCT_TYPE_SYNC/#beforeupdatecallback","text":"During the sync process, if a target product type and a product type draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : product type draft from the source product type from the target project update actions that were calculated after comparing both final TriFunction < List < ProductTypeUpdateAction > , ProductTypeDraft , ProductType , List < ProductTypeUpdateAction >> beforeUpdateProductTypeCallback = ( updateActions , newProductTypeDraft , oldProductType ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof ProductTypeRemoveAttributeDefinitionAction )) . collect ( Collectors . toList ()); final ProductTypeSyncOptions productTypeSyncOptions = ProductTypeSyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateProductTypeCallback ). build ();","title":"beforeUpdateCallback"},{"location":"usage/PRODUCT_TYPE_SYNC/#beforecreatecallback","text":"During the sync process, if a product type draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : product type draft that should be created Please refer to example in product sync document .","title":"beforeCreateCallback"},{"location":"usage/PRODUCT_TYPE_SYNC/#batchsize","text":"A number that could be used to set the batch size with which product types are fetched and processed, as product types are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding product types from the target project on the commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for product type sync. final ProductTypeSyncOptions productTypeSyncOptions = ProductTypeSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build ();","title":"batchSize"},{"location":"usage/PRODUCT_TYPE_SYNC/#cachesize","text":"In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for product type sync. final ProductTypeSyncOptions productTypeSyncOptions = ProductTypeSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build ();","title":"cacheSize"},{"location":"usage/PRODUCT_TYPE_SYNC/#running-the-sync","text":"After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a product type sync final ProductTypeSync productTypeSync = new ProductTypeSync ( productTypeSyncOptions ); // execute the sync on your list of product types CompletionStage < ProductTypeSyncStatistics > syncStatisticsStage = productTypeSync . sync ( productTypeDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a ProductTypeSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed product types and the processing time of the last sync batch in different time units and in a human-readable format. final ProductTypeSyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 2000 products types were processed in total (1000 created, 995 updated, 5 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied.","title":"Running the sync"},{"location":"usage/PRODUCT_TYPE_SYNC/#important-to-note","text":"If two matching attributeDefinition s (old and new) on the matching productType s (old and new) have a different AttributeType , the sync will remove the existing attributeDefinition and then add a new attributeDefinition with the new AttributeType . The attributeDefinition for which the AttributeType is not defined ( null ) will not be synced.","title":"Important to Note"},{"location":"usage/PRODUCT_TYPE_SYNC/#more-examples-of-how-to-use-the-sync","text":"Sync from another CTP project as a source . Sync from an external source . Make sure to read the Important Usage Tips for optimal performance.","title":"More examples of how to use the sync"},{"location":"usage/PRODUCT_TYPE_SYNC/#build-all-update-actions","text":"A utility method provided by the library to compare a ProductType with a new ProductTypeDraft and results in a list of product type update actions. List < ProductTypeUpdateAction > updateActions = ProductTypeSyncUtils . buildActions ( productType , productTypeDraft , productTypeSyncOptions );","title":"Build all update actions"},{"location":"usage/PRODUCT_TYPE_SYNC/#build-particular-update-actions","text":"Utility methods provided by the library to compare the specific fields of a ProductType and a new ProductTypeDraft, and in turn, build the update action. One example is the buildChangeNameUpdateAction which compares names: Optional < ProductTypeUpdateAction > updateAction = ProductTypeUpdateActionUtils . buildChangeNameAction ( oldProductType , productTypeDraft ); More examples of those utils for different fields can be found here .","title":"Build particular update action(s)"},{"location":"usage/PRODUCT_TYPE_SYNC/#caveats","text":"The order of attribute definitions in the synced product types is not guaranteed. Changing the attribute definition type is not supported. Instead, remove and re-add it with a new type manually, either over API or merchant center. For more information please check this ADR .","title":"Caveats"},{"location":"usage/PRODUCT_TYPE_SYNC/#migration-guide","text":"The producttype-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies>","title":"Migration Guide"},{"location":"usage/PRODUCT_TYPE_SYNC/#client-configuration-and-creation","text":"For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document .","title":"Client configuration and creation"},{"location":"usage/PRODUCT_TYPE_SYNC/#signature-of-producttypesyncoptions","text":"As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with ProductTypeDraft , ProductType and ProductTypeUpdateAction from package com.commercetools.api.models.product_type.* Note: Type UpdateAction<ProductType> has changed to ProductTypeUpdateAction . Make sure you create and supply a specific ProductTypeUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a producttype update action to change name taking the 'newName' of the productTypeDraft final Function < LocalizedString , ProductTypeUpdateAction > createBeforeUpdateAction = ( newName ) -> ProductTypeChangeNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < ProductTypeUpdateAction > , ProductTypeDraft , ProductType , List < ProductTypeUpdateAction >> beforeUpdateProductTypeCallback = ( updateActions , newProductTypeDraft , oldProductType ) -> { final ProductTypeUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newProductTypeDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; };","title":"Signature of ProductTypeSyncOptions"},{"location":"usage/PRODUCT_TYPE_SYNC/#build-producttypedraft-syncing-from-external-project","text":"The producttype-sync expects a list of ProductTypeDraft s to process. If you use java-sync-library to sync your producttypes from any external system into a commercetools platform project you have to convert your data into CTP compatible ProductTypeDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // SDK v1: ProductTypeDraftBuilder.of takes parameters 'key', 'name', 'description' and list of 'attributes' final ProductTypeDraft productTypeDraft = ProductTypeDraftBuilder . of ( \"key\" , \"name\" , \"description\" , emptyList ()) . build (); // SDK v2: ProductTypeDraftBuilder without draftTemplate final ProductTypeDraft productTypeDraft = ProductTypeDraftBuilder . of () . description ( \"product-type-description\" ) . key ( \"product-type-key\" ) . name ( \"product-type-name\" ) . build (); For more information, see the Guide to replace DraftBuilders .","title":"Build ProductTypeDraft (syncing from external project)"},{"location":"usage/PRODUCT_TYPE_SYNC/#query-for-producttypes-syncing-from-ctp-project","text":"If you sync producttypes between different commercetools projects you probably use ProductTypeTransformUtils#toProductTypeDrafts to transform ProductType into ProductTypeDraft which can be used by the producttype-sync. However, if you need to query ProductTypes from a commercetools project instead of passing ProductTypeQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: ProductTypeQuery to fetch all producttypes final ProductTypeQuery query = ProductTypeQuery . of (); final PagedQueryResult < ProductType > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all producttypes in one line final ProductTypePagedQueryResponse result = apiRoot . productTypes (). get (). executeBlocking (). getBody (); Read more about querying resources.","title":"Query for ProductTypes (syncing from CTP project)"},{"location":"usage/PRODUCT_TYPE_SYNC/#jvm-sdk-v2-migration-guide","text":"On any other needs to migrate your project using jvm-sdk-v2 please refer to its Migration Guide .","title":"JVM-SDK-V2 migration guide"},{"location":"usage/QUICK_START/","text":"\u26a1 Quick Start \u00b6 1. Installation 2. Setup Syncing Options 3. Start Syncing 4. And you're done \u2728 1. Installation \u00b6 Make sure you have JDK 11 or higher installed. Add the following dependency in your application: For Maven users: <!-- Add commercetools-sync-java dependency. --> <dependency> <groupId> com.commercetools </groupId> <artifactId> commercetools-sync-java </artifactId> <version> 10.0.4 </version> </dependency> For Gradle users: // Add commercetools-sync-java dependency. implementation 'com.commercetools:commercetools-sync-java:10.0.4' 2. Setup Syncing Options \u00b6 final Logger logger = LoggerFactory . getLogger ( MySync . class ); final ProductSyncOptions productsyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , productProjection , updateActions ) -> logger . error ( syncException . getMessage (), syncException )) . warningCallback (( exception , oldProductProjection , newResources ) -> logger . warn ( exception . getMessage (), exception )) . build (); 3. Start Syncing \u00b6 // Transform your product feed batch into a list of ProductDrafts using your preferred way. final List < ProductDraft > productDraftsBatch = ... final ProductSync productSync = new ProductSync ( productSyncOptions ); // execute the sync on your list of products final CompletionStage < ProductSyncStatistics > syncStatisticsStage = productSync . sync ( productDraftsBatch ); 4. And you're done \u2728 \u00b6 final ProductSyncStatistics stats = syncStatisticsStage . toCompletebleFuture () . join (); stats . getReportMessage (); /*\"Summary: 2000 product(s) were processed in total (1000 created, 995 updated, 5 failed to sync and 0 product(s) with missing reference(s)).\"*/ More Details \u00b6 Product Sync , ProductType Sync , Category Sync , Inventory Sync , Type Sync , CartDiscount Sync , TaxCategory Sync , State Sync , CustomObject Sync , Customer Sync , ShoppingLists Sync","title":"Quick Start"},{"location":"usage/QUICK_START/#quick-start","text":"1. Installation 2. Setup Syncing Options 3. Start Syncing 4. And you're done \u2728","title":"\u26a1 Quick Start"},{"location":"usage/QUICK_START/#1-installation","text":"Make sure you have JDK 11 or higher installed. Add the following dependency in your application: For Maven users: <!-- Add commercetools-sync-java dependency. --> <dependency> <groupId> com.commercetools </groupId> <artifactId> commercetools-sync-java </artifactId> <version> 10.0.4 </version> </dependency> For Gradle users: // Add commercetools-sync-java dependency. implementation 'com.commercetools:commercetools-sync-java:10.0.4'","title":"1. Installation"},{"location":"usage/QUICK_START/#2-setup-syncing-options","text":"final Logger logger = LoggerFactory . getLogger ( MySync . class ); final ProductSyncOptions productsyncOptions = ProductSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , productProjection , updateActions ) -> logger . error ( syncException . getMessage (), syncException )) . warningCallback (( exception , oldProductProjection , newResources ) -> logger . warn ( exception . getMessage (), exception )) . build ();","title":"2. Setup Syncing Options"},{"location":"usage/QUICK_START/#3-start-syncing","text":"// Transform your product feed batch into a list of ProductDrafts using your preferred way. final List < ProductDraft > productDraftsBatch = ... final ProductSync productSync = new ProductSync ( productSyncOptions ); // execute the sync on your list of products final CompletionStage < ProductSyncStatistics > syncStatisticsStage = productSync . sync ( productDraftsBatch );","title":"3. Start Syncing"},{"location":"usage/QUICK_START/#4-and-youre-done","text":"final ProductSyncStatistics stats = syncStatisticsStage . toCompletebleFuture () . join (); stats . getReportMessage (); /*\"Summary: 2000 product(s) were processed in total (1000 created, 995 updated, 5 failed to sync and 0 product(s) with missing reference(s)).\"*/","title":"4. And you're done \u2728"},{"location":"usage/QUICK_START/#more-details","text":"Product Sync , ProductType Sync , Category Sync , Inventory Sync , Type Sync , CartDiscount Sync , TaxCategory Sync , State Sync , CustomObject Sync , Customer Sync , ShoppingLists Sync","title":"More Details"},{"location":"usage/SHOPPING_LIST_SYNC/","text":"Shopping List Sync \u00b6 The module used for importing/syncing Shopping Lists into a commercetools project. It also provides utilities for generating update actions based on the comparison of a ShoppingList against a ShoppingListDraft . Table of Contents Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync More examples of how to use the sync Build all update actions Build particular update action(s) Caveats Migration Guide Client configuration and creation Signature of ShoppingListSyncOptions Build ShoppingListDraft (syncing from external project) Query for ShoppingLists (syncing from CTP project) JVM-SDK-V2 migration guide Usage \u00b6 Prerequisites \u00b6 ProjectApiRoot \u00b6 Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create the required ClientCredentials for client creation, please utilize the ClientCredentialsBuilder provided in the java-sdk-v2 Client OAUTH2 package . If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" ); Required Fields \u00b6 The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note ShoppingListDraft key Also, the shopping lists in the target project are expected to have the key fields set. LineItemDraft sku Also, all the line items in the target project are expected to have the sku fields set. TextLineItemDraft name Reference Resolution \u00b6 In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in the sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type customer CustomerResourceIdentifier custom.type TypeResourceIdentifier lineItems.custom.type TypeResourceIdentifier textLineItems.custom.type TypeResourceIdentifier Note that a reference without the key field will be considered as an existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution. Syncing from a commercetools project \u00b6 When syncing from a source commercetools project, you can use toShoppingListDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a ShoppingList to ShoppingListDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build a ShoppingListQuery for fetching shopping lists from a source CTP project with expansion for line items for the sync: final ByProjectKeyShoppingListsGet byProjectKeyShoppingListsGet = client . shoppingLists (). addExpand ( \"lineItems[*].variant\" ). get (); // Query all shopping lists (NOTE this is just for example, please adjust your logic) final List < ShoppingList > states = QueryUtils . queryAll ( byProjectKeyShoppingListsGet , ( shoppingLists ) -> shoppingLists ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the ShoppingList to ShoppingListDraft , Utils method toShoppingListDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and shoppingLists as parameters. For cache implementation, you can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from ShoppingList to ShoppingListDraft. With help of the cache same reference keys can be reused. final CompletableFuture < List < ShoppingListDraft >> shoppingListDrafts = ShoppingListTransformUtils . toShoppingListDrafts ( client , referenceIdToKeyCache , shoppingLists ); Syncing from an external resource \u00b6 When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final ShoppingListDraft shoppingListDraft = ShoppingListDraftBuilder . of () . name ( LocalizedString . ofEnglish ( \"name\" )) . key ( \"shopping-list-key\" ) . customer ( CustomerResourceIdentifierBuilder . of (). key ( \"customer-key\" ). build ()) // note that customer provided with key . custom ( CustomFieldsDraftBuilder . of (). type ( typeResourceIdentifierBuilder -> typeResourceIdentifierBuilder . key ( \"type-key\" )) . fields ( fieldContainerBuilder -> fieldContainerBuilder . values ( Map . of ())). build () ) // note that custom type provided with key . lineItems ( List . of ( ShoppingListLineItemDraftBuilder . of () . sku ( \"SKU-1\" ) . quantity ( 1L ) // note that sku field is set. . custom ( CustomFieldsDraftBuilder . of (). type ( typeResourceIdentifierBuilder -> typeResourceIdentifierBuilder . key ( \"type-key\" )) . fields ( fieldContainerBuilder -> fieldContainerBuilder . values ( Map . of ())). build () ) // note that custom type provided with key . build ()) ) . textLineItems ( List . of ( TextLineItemDraftBuilder . of (). name ( ofEnglish ( \"name\" )). quantity ( 1L ) // note that name field is set for text line item. . custom ( CustomFieldsDraftBuilder . of (). type ( typeResourceIdentifierBuilder -> typeResourceIdentifierBuilder . key ( \"type-key\" )) . fields ( fieldContainerBuilder -> fieldContainerBuilder . values ( Map . of ())). build () ) // note that custom type provided with key . build () ) ) . build (); SyncOptions \u00b6 After the projectApiRoot is set up, a ShoppingListSyncOptions should be built as follows: // instantiating a ShoppingListSyncOptions final ShoppingListSyncOptions shoppingListSyncOptions = ShoppingListSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations: errorCallback \u00b6 A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception shopping list draft from the source shopping list of the target project (only provided if an existing shopping list could be found) the update-actions, which failed (only provided if an existing shopping list could be found) final Logger logger = LoggerFactory . getLogger ( ShoppingListSync . class ); final ShoppingListSyncOptions shoppingListSyncOptions = ShoppingListSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , shoppingList , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build (); warningCallback \u00b6 A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception shopping list draft from the source shopping list of the target project (only provided if an existing shopping list could be found) final Logger logger = LoggerFactory . getLogger ( ShoppingListSync . class ); final ShoppingListSyncOptions shoppingListSyncOptions = ShoppingListSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , shoppingList ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build (); beforeUpdateCallback \u00b6 During the sync process, if a target customer and a customer draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : shopping list draft from the source shopping list from the target project update actions that were calculated after comparing both final TriFunction < List < ShoppingListUpdateAction > , ShoppingListDraft , ShoppingList , List < ShoppingListUpdateAction >> beforeUpdateCallback = ( updateActions , newShoppingList , oldShoppingList ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof ShoppingListSetSlugAction )) . collect ( Collectors . toList ()); final ShoppingListSyncOptions shoppingListSyncOptions = ShoppingListSyncOptionsBuilder . of ( projectApiRoot ) . beforeUpdateCallback ( beforeUpdateCallback ) . build (); beforeCreateCallback \u00b6 During the sync process, if a shopping list draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : shopping list that should be created Please refer to the example in the product sync document . batchSize \u00b6 A number that could be used to set the batch size with which shopping lists are fetched and processed, as shopping lists are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding shopping lists from the target project on the commercetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for shopping list sync. final ShoppingListSyncOptions shoppingListSyncOptions = ShoppingListSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build (); cacheSize \u00b6 In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for shopping list sync. final ShoppingListSyncOptions shoppingListSyncOptions = ShoppingListSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build (); Running the sync \u00b6 When all prerequisites are fulfilled, follow these steps to run the sync: // instantiating a shopping list sync final ShoppingListSync shoppingListSync = new ShoppingListSync ( shoppingListSyncOptions ); // execute the sync on your list of shopping lists CompletionStage < ShoppingListSyncStatistics > syncStatisticsStage = shoppingListSync . sync ( shoppingListDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a ShoppingListSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed shopping lists, and the processing time of the last sync batch in different time units and in a human-readable format. final ShoppingListSyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 100 shopping lists were processed in total (11 created, 87 updated, 2 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied. More examples of how to use the sync \u00b6 Sync from another CTP project as a source . Sync from an external source . Make sure to read the Important Usage Tips for optimal performance. Build all update actions \u00b6 A utility method provided by the library to compare a ShoppingList to a new ShoppingListDraft . The results are collected in a list of shopping list update actions. List < ShoppingListUpdateAction > updateActions = ShoppingListSyncUtils . buildActions ( shoppingList , shoppingListDraft , shoppingListSyncOptions ); Build particular update action(s) \u00b6 The library provides utility methods to compare specific fields of a ShoppingList and a new ShoppingListDraft , and builds the update action(s) as a result. One example is the buildChangeNameUpdateAction which compare shopping list names: Optional < ShoppingListUpdateAction > updateAction = ShoppingListUpdateActionUtils . buildChangeNameAction ( shoppingList , shoppingListDraft ); More examples for particular update actions can be found in the test scenarios for ShoppingListUpdateActionUtils . Caveats \u00b6 In commercetools shopping lists API, there is no update action to change the addedAt field of the LineItem and TextLineItem , hereby commercetools-java-sync library will not update the addedAt value. For the new LineItem and TextLineItem the addedAt values will be added, if the draft has the value set. Migration Guide \u00b6 The shopping-list-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies> Client configuration and creation \u00b6 For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document . Signature of ShoppingListSyncOptions \u00b6 As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with ShoppingListDraft , ShoppingList and ShoppingListUpdateAction from package com.commercetools.api.models.shopping_list.* Note: Type UpdateAction<ShoppingList> has changed to ShoppingListUpdateAction . Make sure you create and supply a specific ShoppingListUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a shopping-list update action to change name taking the 'newName' of the shoppingListDraft final Function < LocalizedString , ShoppingListUpdateAction > createBeforeUpdateAction = ( newName ) -> ShoppingListChangeNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < ShoppingListUpdateAction > , ShoppingListDraft , ShoppingList , List < ShoppingListUpdateAction >> beforeUpdateShoppingListCallback = ( updateActions , newShoppingListDraft , oldShoppingList ) -> { final ShoppingListUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newShoppingListDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; }; Build ShoppingListDraft (syncing from external project) \u00b6 The shopping-list-sync expects a list of ShoppingListDraft s to process. If you use java-sync-library to sync your shopping-lists from any external system into a commercetools platform project you have to convert your data into CTP compatible ShoppingListDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // SDK v1: ShoppingListDraftBuilder.of takes parameters 'key', 'name' and 1 line item final ShoppingListDraft shoppingListDraft = ShoppingListDraftBuilder . of ( LocalizedString . ofEnglish ( \"name\" )) . key ( \"key\" ) . plusLineItems ( LineItemDraftBuilder . ofSku ( \"sku\" , Long . valueOf ( 1 )). build ()) . build () // SDK v2: ShoppingListDraftBuilder without draftTemplate final ShoppingListDraft shoppingListDraft = ShoppingListDraftBuilder . of () . name ( LocalizedString . ofEnglish ( \"name\" )) . key ( \"product-type-key\" ) . lineItems ( ShoppingListLineItemDraftBuilder . of (). sku ( \"SKU-1\" ). quantity ( 1L ). build ()) . build (); For more information, see the Guide to replace DraftBuilders . Query for ShoppingLists (syncing from CTP project) \u00b6 If you sync shopping lists between different commercetools projects you probably use ShoppingListTransformUtils#toShoppingListDrafts to transform ShoppingList into ShoppingListDraft which can be used by the shopping-list-sync. However, if you need to query ShoppingLists from a commercetools project instead of passing ShoppingListQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: ShoppingListQuery to fetch all shopping lists final ShoppingListQuery query = ShoppingListQuery . of (); final PagedQueryResult < ShoppingList > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all shopping lists in one line final ShoppingListPagedQueryResponse result = apiRoot . shoppingLists (). get (). executeBlocking (). getBody (); Read more about querying resources. JVM-SDK-V2 migration guide \u00b6 On any other needs to migrate your project using jvm-sdk-v2 please refer to its Migration Guide .","title":"ShoppingList Sync"},{"location":"usage/SHOPPING_LIST_SYNC/#shopping-list-sync","text":"The module used for importing/syncing Shopping Lists into a commercetools project. It also provides utilities for generating update actions based on the comparison of a ShoppingList against a ShoppingListDraft . Table of Contents Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync More examples of how to use the sync Build all update actions Build particular update action(s) Caveats Migration Guide Client configuration and creation Signature of ShoppingListSyncOptions Build ShoppingListDraft (syncing from external project) Query for ShoppingLists (syncing from CTP project) JVM-SDK-V2 migration guide","title":"Shopping List Sync"},{"location":"usage/SHOPPING_LIST_SYNC/#usage","text":"","title":"Usage"},{"location":"usage/SHOPPING_LIST_SYNC/#prerequisites","text":"","title":"Prerequisites"},{"location":"usage/SHOPPING_LIST_SYNC/#projectapiroot","text":"Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create the required ClientCredentials for client creation, please utilize the ClientCredentialsBuilder provided in the java-sdk-v2 Client OAUTH2 package . If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" );","title":"ProjectApiRoot"},{"location":"usage/SHOPPING_LIST_SYNC/#required-fields","text":"The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note ShoppingListDraft key Also, the shopping lists in the target project are expected to have the key fields set. LineItemDraft sku Also, all the line items in the target project are expected to have the sku fields set. TextLineItemDraft name","title":"Required Fields"},{"location":"usage/SHOPPING_LIST_SYNC/#reference-resolution","text":"In commercetools, a reference can be created by providing the key instead of the ID with the type ResourceIdentifier . When the reference key is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. Therefore, in order to resolve the actual ids of those references in the sync process, ResourceIdentifier s with their key s have to be supplied. Reference Field Type customer CustomerResourceIdentifier custom.type TypeResourceIdentifier lineItems.custom.type TypeResourceIdentifier textLineItems.custom.type TypeResourceIdentifier Note that a reference without the key field will be considered as an existing resource on the target commercetools project and the library will issue an update/create an API request without reference resolution.","title":"Reference Resolution"},{"location":"usage/SHOPPING_LIST_SYNC/#syncing-from-a-commercetools-project","text":"When syncing from a source commercetools project, you can use toShoppingListDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a ShoppingList to ShoppingListDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build a ShoppingListQuery for fetching shopping lists from a source CTP project with expansion for line items for the sync: final ByProjectKeyShoppingListsGet byProjectKeyShoppingListsGet = client . shoppingLists (). addExpand ( \"lineItems[*].variant\" ). get (); // Query all shopping lists (NOTE this is just for example, please adjust your logic) final List < ShoppingList > states = QueryUtils . queryAll ( byProjectKeyShoppingListsGet , ( shoppingLists ) -> shoppingLists ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the ShoppingList to ShoppingListDraft , Utils method toShoppingListDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and shoppingLists as parameters. For cache implementation, you can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from ShoppingList to ShoppingListDraft. With help of the cache same reference keys can be reused. final CompletableFuture < List < ShoppingListDraft >> shoppingListDrafts = ShoppingListTransformUtils . toShoppingListDrafts ( client , referenceIdToKeyCache , shoppingLists );","title":"Syncing from a commercetools project"},{"location":"usage/SHOPPING_LIST_SYNC/#syncing-from-an-external-resource","text":"When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final ShoppingListDraft shoppingListDraft = ShoppingListDraftBuilder . of () . name ( LocalizedString . ofEnglish ( \"name\" )) . key ( \"shopping-list-key\" ) . customer ( CustomerResourceIdentifierBuilder . of (). key ( \"customer-key\" ). build ()) // note that customer provided with key . custom ( CustomFieldsDraftBuilder . of (). type ( typeResourceIdentifierBuilder -> typeResourceIdentifierBuilder . key ( \"type-key\" )) . fields ( fieldContainerBuilder -> fieldContainerBuilder . values ( Map . of ())). build () ) // note that custom type provided with key . lineItems ( List . of ( ShoppingListLineItemDraftBuilder . of () . sku ( \"SKU-1\" ) . quantity ( 1L ) // note that sku field is set. . custom ( CustomFieldsDraftBuilder . of (). type ( typeResourceIdentifierBuilder -> typeResourceIdentifierBuilder . key ( \"type-key\" )) . fields ( fieldContainerBuilder -> fieldContainerBuilder . values ( Map . of ())). build () ) // note that custom type provided with key . build ()) ) . textLineItems ( List . of ( TextLineItemDraftBuilder . of (). name ( ofEnglish ( \"name\" )). quantity ( 1L ) // note that name field is set for text line item. . custom ( CustomFieldsDraftBuilder . of (). type ( typeResourceIdentifierBuilder -> typeResourceIdentifierBuilder . key ( \"type-key\" )) . fields ( fieldContainerBuilder -> fieldContainerBuilder . values ( Map . of ())). build () ) // note that custom type provided with key . build () ) ) . build ();","title":"Syncing from an external resource"},{"location":"usage/SHOPPING_LIST_SYNC/#syncoptions","text":"After the projectApiRoot is set up, a ShoppingListSyncOptions should be built as follows: // instantiating a ShoppingListSyncOptions final ShoppingListSyncOptions shoppingListSyncOptions = ShoppingListSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations:","title":"SyncOptions"},{"location":"usage/SHOPPING_LIST_SYNC/#errorcallback","text":"A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception shopping list draft from the source shopping list of the target project (only provided if an existing shopping list could be found) the update-actions, which failed (only provided if an existing shopping list could be found) final Logger logger = LoggerFactory . getLogger ( ShoppingListSync . class ); final ShoppingListSyncOptions shoppingListSyncOptions = ShoppingListSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , shoppingList , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"errorCallback"},{"location":"usage/SHOPPING_LIST_SYNC/#warningcallback","text":"A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception shopping list draft from the source shopping list of the target project (only provided if an existing shopping list could be found) final Logger logger = LoggerFactory . getLogger ( ShoppingListSync . class ); final ShoppingListSyncOptions shoppingListSyncOptions = ShoppingListSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , shoppingList ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"warningCallback"},{"location":"usage/SHOPPING_LIST_SYNC/#beforeupdatecallback","text":"During the sync process, if a target customer and a customer draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : shopping list draft from the source shopping list from the target project update actions that were calculated after comparing both final TriFunction < List < ShoppingListUpdateAction > , ShoppingListDraft , ShoppingList , List < ShoppingListUpdateAction >> beforeUpdateCallback = ( updateActions , newShoppingList , oldShoppingList ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof ShoppingListSetSlugAction )) . collect ( Collectors . toList ()); final ShoppingListSyncOptions shoppingListSyncOptions = ShoppingListSyncOptionsBuilder . of ( projectApiRoot ) . beforeUpdateCallback ( beforeUpdateCallback ) . build ();","title":"beforeUpdateCallback"},{"location":"usage/SHOPPING_LIST_SYNC/#beforecreatecallback","text":"During the sync process, if a shopping list draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : shopping list that should be created Please refer to the example in the product sync document .","title":"beforeCreateCallback"},{"location":"usage/SHOPPING_LIST_SYNC/#batchsize","text":"A number that could be used to set the batch size with which shopping lists are fetched and processed, as shopping lists are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding shopping lists from the target project on the commercetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for shopping list sync. final ShoppingListSyncOptions shoppingListSyncOptions = ShoppingListSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build ();","title":"batchSize"},{"location":"usage/SHOPPING_LIST_SYNC/#cachesize","text":"In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for shopping list sync. final ShoppingListSyncOptions shoppingListSyncOptions = ShoppingListSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build ();","title":"cacheSize"},{"location":"usage/SHOPPING_LIST_SYNC/#running-the-sync","text":"When all prerequisites are fulfilled, follow these steps to run the sync: // instantiating a shopping list sync final ShoppingListSync shoppingListSync = new ShoppingListSync ( shoppingListSyncOptions ); // execute the sync on your list of shopping lists CompletionStage < ShoppingListSyncStatistics > syncStatisticsStage = shoppingListSync . sync ( shoppingListDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a ShoppingListSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed shopping lists, and the processing time of the last sync batch in different time units and in a human-readable format. final ShoppingListSyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 100 shopping lists were processed in total (11 created, 87 updated, 2 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied.","title":"Running the sync"},{"location":"usage/SHOPPING_LIST_SYNC/#more-examples-of-how-to-use-the-sync","text":"Sync from another CTP project as a source . Sync from an external source . Make sure to read the Important Usage Tips for optimal performance.","title":"More examples of how to use the sync"},{"location":"usage/SHOPPING_LIST_SYNC/#build-all-update-actions","text":"A utility method provided by the library to compare a ShoppingList to a new ShoppingListDraft . The results are collected in a list of shopping list update actions. List < ShoppingListUpdateAction > updateActions = ShoppingListSyncUtils . buildActions ( shoppingList , shoppingListDraft , shoppingListSyncOptions );","title":"Build all update actions"},{"location":"usage/SHOPPING_LIST_SYNC/#build-particular-update-actions","text":"The library provides utility methods to compare specific fields of a ShoppingList and a new ShoppingListDraft , and builds the update action(s) as a result. One example is the buildChangeNameUpdateAction which compare shopping list names: Optional < ShoppingListUpdateAction > updateAction = ShoppingListUpdateActionUtils . buildChangeNameAction ( shoppingList , shoppingListDraft ); More examples for particular update actions can be found in the test scenarios for ShoppingListUpdateActionUtils .","title":"Build particular update action(s)"},{"location":"usage/SHOPPING_LIST_SYNC/#caveats","text":"In commercetools shopping lists API, there is no update action to change the addedAt field of the LineItem and TextLineItem , hereby commercetools-java-sync library will not update the addedAt value. For the new LineItem and TextLineItem the addedAt values will be added, if the draft has the value set.","title":"Caveats"},{"location":"usage/SHOPPING_LIST_SYNC/#migration-guide","text":"The shopping-list-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies>","title":"Migration Guide"},{"location":"usage/SHOPPING_LIST_SYNC/#client-configuration-and-creation","text":"For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document .","title":"Client configuration and creation"},{"location":"usage/SHOPPING_LIST_SYNC/#signature-of-shoppinglistsyncoptions","text":"As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with ShoppingListDraft , ShoppingList and ShoppingListUpdateAction from package com.commercetools.api.models.shopping_list.* Note: Type UpdateAction<ShoppingList> has changed to ShoppingListUpdateAction . Make sure you create and supply a specific ShoppingListUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a shopping-list update action to change name taking the 'newName' of the shoppingListDraft final Function < LocalizedString , ShoppingListUpdateAction > createBeforeUpdateAction = ( newName ) -> ShoppingListChangeNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < ShoppingListUpdateAction > , ShoppingListDraft , ShoppingList , List < ShoppingListUpdateAction >> beforeUpdateShoppingListCallback = ( updateActions , newShoppingListDraft , oldShoppingList ) -> { final ShoppingListUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newShoppingListDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; };","title":"Signature of ShoppingListSyncOptions"},{"location":"usage/SHOPPING_LIST_SYNC/#build-shoppinglistdraft-syncing-from-external-project","text":"The shopping-list-sync expects a list of ShoppingListDraft s to process. If you use java-sync-library to sync your shopping-lists from any external system into a commercetools platform project you have to convert your data into CTP compatible ShoppingListDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // SDK v1: ShoppingListDraftBuilder.of takes parameters 'key', 'name' and 1 line item final ShoppingListDraft shoppingListDraft = ShoppingListDraftBuilder . of ( LocalizedString . ofEnglish ( \"name\" )) . key ( \"key\" ) . plusLineItems ( LineItemDraftBuilder . ofSku ( \"sku\" , Long . valueOf ( 1 )). build ()) . build () // SDK v2: ShoppingListDraftBuilder without draftTemplate final ShoppingListDraft shoppingListDraft = ShoppingListDraftBuilder . of () . name ( LocalizedString . ofEnglish ( \"name\" )) . key ( \"product-type-key\" ) . lineItems ( ShoppingListLineItemDraftBuilder . of (). sku ( \"SKU-1\" ). quantity ( 1L ). build ()) . build (); For more information, see the Guide to replace DraftBuilders .","title":"Build ShoppingListDraft (syncing from external project)"},{"location":"usage/SHOPPING_LIST_SYNC/#query-for-shoppinglists-syncing-from-ctp-project","text":"If you sync shopping lists between different commercetools projects you probably use ShoppingListTransformUtils#toShoppingListDrafts to transform ShoppingList into ShoppingListDraft which can be used by the shopping-list-sync. However, if you need to query ShoppingLists from a commercetools project instead of passing ShoppingListQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: ShoppingListQuery to fetch all shopping lists final ShoppingListQuery query = ShoppingListQuery . of (); final PagedQueryResult < ShoppingList > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all shopping lists in one line final ShoppingListPagedQueryResponse result = apiRoot . shoppingLists (). get (). executeBlocking (). getBody (); Read more about querying resources.","title":"Query for ShoppingLists (syncing from CTP project)"},{"location":"usage/SHOPPING_LIST_SYNC/#jvm-sdk-v2-migration-guide","text":"On any other needs to migrate your project using jvm-sdk-v2 please refer to its Migration Guide .","title":"JVM-SDK-V2 migration guide"},{"location":"usage/STATE_SYNC/","text":"State Sync \u00b6 The module used for importing/syncing States into a commercetools project. It also provides utilities for generating update actions based on the comparison a State (which basically represents what commercetools already has) against a StateDraft (which represents a new version of the state supplied by the user). Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync Persistence of StateDrafts with missing references More examples of how to use the sync Build all update actions Build particular update action(s) Migration Guide Client configuration and creation Signature of StateSyncOptions Build StateDraft (syncing from external project) Query for states (syncing from CTP project) Referencing other states in transitions Usage \u00b6 Prerequisites \u00b6 ProjectApiRoot \u00b6 Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" ); Required Fields \u00b6 The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note StateDraft key Also, the states in the target project are expected to have the key fields set. Reference Resolution \u00b6 Transitions are a way to describe possible transformations of the current state to other states of the same type (for example Initial -> Shipped). When performing a SetTransitions , an array of ResourceIdentifiers to State is needed. In commercetools, a ResourceIdentifier can be created by providing either the key or the ID. When the key to a referenced state is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. ResourceIdentifier Field Type transitions Array of StateResourceIdentifiers Syncing from a commercetools project \u00b6 When syncing from a source commercetools project, you can use toStateDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a State to StateDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build a ByProjectKeyStatesGet for fetching states from a source CTP project without any references expanded for the sync: final ByProjectKeyStatesGet byProjectKeyStatesGet = client . states (). get (); // Query all states (NOTE this is just for example, please adjust your logic) final List < State > states = QueryUtils . queryAll ( byProjectKeyStatesGet , ( states ) -> states ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the State to StateDraft , Utils method toStateDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and states as parameters. For cache implementation, You can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from State to StateDraft. With help of the cache same reference keys can be reused. final CompletableFuture < List < StateDraft >> stateDrafts = StateTransformUtils . toStateDrafts ( client , referenceIdToKeyCache , states ); Syncing from an external resource \u00b6 When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final StateDraft stateDraft = StateDraftBuilder . of () . key ( \"state-key\" ) . type ( StateTypeEnum . LINE_ITEM_STATE ) . transitions ( StateResourceIdentifierBuilder . of (). key ( \"another-state-key\" ). build ()) . build (); SyncOptions \u00b6 After the projectApiRoot is set up, a StateSyncOptions should be built as follows: // instantiating a StateSyncOptions final StateSyncOptions stateSyncOptions = StateSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations: errorCallback \u00b6 A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception state draft from the source state of the target project (only provided if an existing state could be found) the update-actions, which failed (only provided if an existing state could be found) final Logger logger = LoggerFactory . getLogger ( StateSync . class ); final StateSyncOptions stateSyncOptions = StateSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , state , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build (); warningCallback \u00b6 A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception state draft from the source state of the target project (only provided if an existing state could be found) final Logger logger = LoggerFactory . getLogger ( StateSync . class ); final StateSyncOptions stateSyncOptions = StateSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , state ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build (); beforeUpdateCallback \u00b6 During the sync process, if a target state and a state draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : state draft from the source state from the target project update actions that were calculated after comparing both final TriFunction < List < StateUpdateAction > , StateDraft , State , List < StateUpdateAction >> beforeUpdateStateCallback = ( updateActions , newStateDraft , oldState ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof StateRemoveRolesAction )) . collect ( Collectors . toList ()); final StateSyncOptions stateSyncOptions = StateSyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateStateCallback ). build (); beforeCreateCallback \u00b6 During the sync process, if a state draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : state draft that should be created Please refer to example in product sync document . batchSize \u00b6 A number that could be used to set the batch size with which states are fetched and processed, as states are obtained from the target project on commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding states from the target project on the commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for state sync. final StateSyncOptions stateSyncOptions = StateSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build (); cacheSize \u00b6 In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for state sync. final StateSyncOptions stateSyncOptions = StateSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build (); Running the sync \u00b6 After all the aforementioned points in the previous section have been fulfilled, run the sync as follows: // instantiating a State sync final StateSync stateSync = new StateSync ( stateSyncOptions ); // execute the sync on your list of StateDraft final CompletionStage < StateSyncStatistics > stateSyncStatisticsStage = stateSync . sync ( stateDrafts ); The result of the completing the StateSyncStatistics in the previous code snippet contains a StateSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed states, the missing parent of transitions and the processing time of the sync in different time units and in a human-readable format. final StateSyncStatistics stats = stateSyncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); // Summary: 3 state(s) were processed in total (3 created, 0 updated, 0 failed to sync and 0 state(s) with missing transition(s). Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied. Persistence of StateDrafts with missing references \u00b6 A StateDraft (state-A) could be supplied with a transition referencing StateDraft (state-B). It could be that (state-B) is not supplied before (state-A), which means the sync could fail to create/update (state-A). It could also be that (state-B) is not supplied at all in this batch but at a later batch. The library keeps tracks of such \"referencing\" states like (state-A) and persists them in storage ( commercetools customObjects in the target project , in this case) to keep them and create/update them accordingly whenever the referenced state has been provided at some point. The customObject will have a container: \"commercetools-sync-java.UnresolvedTransitionsService.stateDrafts\" and a key representing a hash value of the StateDraft key that is waiting to be created/updated. Here is an example of a CustomObject in the target project that represents a StateDraft with key state-A . It being persisted as CustomObject means that the referenced StateDrafts with keys state-B do not exist yet. { \"container\" : \"commercetools-sync-java.UnresolvedTransitionsService.stateDrafts\" , \"key\" : \"518ea82bb78755c0cdd67909dd3206d56186f7e5\" , \"value\" : { \"missingTransitionStateKeys\" : [ \"state-B\" ], \"stateDraft\" : { \"type\" : \"ReviewState\" , \"transitions\" : [ { \"id\" : \"state-B\" , \"typeId\" : \"state\" } ], \"roles\" : [ \"ReviewIncludedInStatistics\" ], \"key\" : \"state-A\" , \"initial\" : true } } } As soon, as the referenced StateDrafts are supplied to the sync, the draft will be created/updated and the CustomObject will be removed from the target project. Keeping the old custom objects around forever can negatively influence the performance of your project and the time it takes to restore it from a backup. Deleting unused data ensures the best performance for your project. Please have a look into the Cleanup guide to cleanup old unresolved custom objects. More examples of how to use the sync \u00b6 Sync from another CTP project as a source . Sync from an external source . Make sure to read the Important Usage Tips for optimal performance. Build all update actions \u00b6 A utility method provided by the library to compare a State with a new StateDraft and results in a list of state update actions. update actions. List < StateUpdateAction > updateActions = StateSyncUtils . buildActions ( state , stateDraft , stateSyncOptions ); Build particular update action(s) \u00b6 Utility methods provided by the library to compare the specific fields of a State and a new StateDraft , and in turn builds the update action. One example is the buildSetNameAction which compares names: Optional < StateUpdateAction > updateAction = StateUpdateActionUtils . buildSetNameAction ( oldState , stateDraft ); More examples of those utils for different types can be found here . Migration Guide \u00b6 The state-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies> Client configuration and creation \u00b6 For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document . Signature of StateSyncOptions \u00b6 As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with State , StateDraft and StateUpdateAction from package com.commercetools.api.models.state.* Note: Type StateUpdateAction has changed to StateUpdateAction . Make sure you create and supply a specific StateUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a state update action to change name taking the 'newName' of the stateDraft final Function < LocalizedString , StateUpdateAction > createBeforeUpdateAction = ( newName ) -> StateSetNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < StateUpdateAction > , StateDraft , State , List < StateUpdateAction >> beforeUpdateStateCallback = ( updateActions , newStateDraft , oldState ) -> { final StateUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newStateDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; }; Build StateDraft (syncing from external project) \u00b6 The state-sync expects a list of StateDraft s to process. If you use java-sync-library to sync your states from any external system into a commercetools platform project you have to convert your data into CTP compatible StateDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // StateDraftBuilder in v1 takes parameters 'key', 'type' final StateDraft stateDraft = StateDraftBuilder . of ( \"key\" , StateType . LINE_ITEM_STATE ) . name ( ofEnglish ( \"state-name\" )) . description ( ofEnglish ( \"state-desc\" )) . roles ( Collections . singleton ( StateRole . RETURN )) . initial ( false ) . build (); // StateDraftBuilder in v2 final StateDraft stateDraft = StateDraftBuilder . of () . key ( \"key\" ) . type ( StateTypeEnum . LINE_ITEM_STATE ) . name ( ofEnglish ( \"state-name\" )) . description ( ofEnglish ( \"state-desc\" )) . roles ( StateRoleEnum . RETURN ) . initial ( false ) . build (); For more information, see the Guide to replace DraftBuilders . Query for states (syncing from CTP project) \u00b6 If you sync states between different commercetools projects you probably use StateTransformUtils#toStateDrafts to transform State into StateDraft which can be used by the state-sync. However, if you need to query states from a commercetools project instead of passing StateQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: StateQuery to fetch all states final StateQuery query = StateQuery . of (); final PagedQueryResult < State > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all states in one line final StatePagedQueryResponse result = apiRoot . states (). get (). executeBlocking (). getBody (); Read more about querying resources. Referencing other states in transitions \u00b6 When you use references to other states in the field transitions , the state-sync needs to do the reference resolution process. In the previous java-sdk-v1 it was required to provide the key value on the id field of the reference. In the current java-sdk-v2 you must provide the key field in StateResourceIdentifier . For detailed information see the Reference resolution section .","title":"State Sync"},{"location":"usage/STATE_SYNC/#state-sync","text":"The module used for importing/syncing States into a commercetools project. It also provides utilities for generating update actions based on the comparison a State (which basically represents what commercetools already has) against a StateDraft (which represents a new version of the state supplied by the user). Usage Prerequisites ProjectApiRoot Required Fields Reference Resolution Syncing from a commercetools project Syncing from an external resource SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync Persistence of StateDrafts with missing references More examples of how to use the sync Build all update actions Build particular update action(s) Migration Guide Client configuration and creation Signature of StateSyncOptions Build StateDraft (syncing from external project) Query for states (syncing from CTP project) Referencing other states in transitions","title":"State Sync"},{"location":"usage/STATE_SYNC/#usage","text":"","title":"Usage"},{"location":"usage/STATE_SYNC/#prerequisites","text":"","title":"Prerequisites"},{"location":"usage/STATE_SYNC/#projectapiroot","text":"Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" );","title":"ProjectApiRoot"},{"location":"usage/STATE_SYNC/#required-fields","text":"The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note StateDraft key Also, the states in the target project are expected to have the key fields set.","title":"Required Fields"},{"location":"usage/STATE_SYNC/#reference-resolution","text":"Transitions are a way to describe possible transformations of the current state to other states of the same type (for example Initial -> Shipped). When performing a SetTransitions , an array of ResourceIdentifiers to State is needed. In commercetools, a ResourceIdentifier can be created by providing either the key or the ID. When the key to a referenced state is provided with a ResourceIdentifier , the sync will resolve the resource with the given key and use the ID of the found resource to create or update a reference. ResourceIdentifier Field Type transitions Array of StateResourceIdentifiers","title":"Reference Resolution"},{"location":"usage/STATE_SYNC/#syncing-from-a-commercetools-project","text":"When syncing from a source commercetools project, you can use toStateDrafts method that transforms(resolves by querying and caching key-id pairs) and maps from a State to StateDraft using cache in order to make them ready for reference resolution by the sync, for example: // Build a ByProjectKeyStatesGet for fetching states from a source CTP project without any references expanded for the sync: final ByProjectKeyStatesGet byProjectKeyStatesGet = client . states (). get (); // Query all states (NOTE this is just for example, please adjust your logic) final List < State > states = QueryUtils . queryAll ( byProjectKeyStatesGet , ( states ) -> states ) . thenApply ( lists -> lists . stream (). flatMap ( List :: stream ). collect ( Collectors . toList ())) . toCompletableFuture () . join (); In order to transform and map the State to StateDraft , Utils method toStateDrafts requires projectApiRoot , implementation of ReferenceIdToKeyCache and states as parameters. For cache implementation, You can use your own cache implementation or use the class in the library - which implements the cache using caffeine library with an LRU (Least Recently Used) based cache eviction strategy CaffeineReferenceIdToKeyCacheImpl . Example as shown below: //Implement the cache using library class. final ReferenceIdToKeyCache referenceIdToKeyCache = new CaffeineReferenceIdToKeyCacheImpl (); //For every reference fetch its key using id, cache it and map from State to StateDraft. With help of the cache same reference keys can be reused. final CompletableFuture < List < StateDraft >> stateDrafts = StateTransformUtils . toStateDrafts ( client , referenceIdToKeyCache , states );","title":"Syncing from a commercetools project"},{"location":"usage/STATE_SYNC/#syncing-from-an-external-resource","text":"When syncing from an external resource, ResourceIdentifier s with their key s have to be supplied as following example: final StateDraft stateDraft = StateDraftBuilder . of () . key ( \"state-key\" ) . type ( StateTypeEnum . LINE_ITEM_STATE ) . transitions ( StateResourceIdentifierBuilder . of (). key ( \"another-state-key\" ). build ()) . build ();","title":"Syncing from an external resource"},{"location":"usage/STATE_SYNC/#syncoptions","text":"After the projectApiRoot is set up, a StateSyncOptions should be built as follows: // instantiating a StateSyncOptions final StateSyncOptions stateSyncOptions = StateSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations:","title":"SyncOptions"},{"location":"usage/STATE_SYNC/#errorcallback","text":"A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception state draft from the source state of the target project (only provided if an existing state could be found) the update-actions, which failed (only provided if an existing state could be found) final Logger logger = LoggerFactory . getLogger ( StateSync . class ); final StateSyncOptions stateSyncOptions = StateSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , state , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"errorCallback"},{"location":"usage/STATE_SYNC/#warningcallback","text":"A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception state draft from the source state of the target project (only provided if an existing state could be found) final Logger logger = LoggerFactory . getLogger ( StateSync . class ); final StateSyncOptions stateSyncOptions = StateSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , state ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"warningCallback"},{"location":"usage/STATE_SYNC/#beforeupdatecallback","text":"During the sync process, if a target state and a state draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : state draft from the source state from the target project update actions that were calculated after comparing both final TriFunction < List < StateUpdateAction > , StateDraft , State , List < StateUpdateAction >> beforeUpdateStateCallback = ( updateActions , newStateDraft , oldState ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof StateRemoveRolesAction )) . collect ( Collectors . toList ()); final StateSyncOptions stateSyncOptions = StateSyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateStateCallback ). build ();","title":"beforeUpdateCallback"},{"location":"usage/STATE_SYNC/#beforecreatecallback","text":"During the sync process, if a state draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : state draft that should be created Please refer to example in product sync document .","title":"beforeCreateCallback"},{"location":"usage/STATE_SYNC/#batchsize","text":"A number that could be used to set the batch size with which states are fetched and processed, as states are obtained from the target project on commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding states from the target project on the commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for state sync. final StateSyncOptions stateSyncOptions = StateSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build ();","title":"batchSize"},{"location":"usage/STATE_SYNC/#cachesize","text":"In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for state sync. final StateSyncOptions stateSyncOptions = StateSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build ();","title":"cacheSize"},{"location":"usage/STATE_SYNC/#running-the-sync","text":"After all the aforementioned points in the previous section have been fulfilled, run the sync as follows: // instantiating a State sync final StateSync stateSync = new StateSync ( stateSyncOptions ); // execute the sync on your list of StateDraft final CompletionStage < StateSyncStatistics > stateSyncStatisticsStage = stateSync . sync ( stateDrafts ); The result of the completing the StateSyncStatistics in the previous code snippet contains a StateSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed states, the missing parent of transitions and the processing time of the sync in different time units and in a human-readable format. final StateSyncStatistics stats = stateSyncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); // Summary: 3 state(s) were processed in total (3 created, 0 updated, 0 failed to sync and 0 state(s) with missing transition(s). Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied.","title":"Running the sync"},{"location":"usage/STATE_SYNC/#persistence-of-statedrafts-with-missing-references","text":"A StateDraft (state-A) could be supplied with a transition referencing StateDraft (state-B). It could be that (state-B) is not supplied before (state-A), which means the sync could fail to create/update (state-A). It could also be that (state-B) is not supplied at all in this batch but at a later batch. The library keeps tracks of such \"referencing\" states like (state-A) and persists them in storage ( commercetools customObjects in the target project , in this case) to keep them and create/update them accordingly whenever the referenced state has been provided at some point. The customObject will have a container: \"commercetools-sync-java.UnresolvedTransitionsService.stateDrafts\" and a key representing a hash value of the StateDraft key that is waiting to be created/updated. Here is an example of a CustomObject in the target project that represents a StateDraft with key state-A . It being persisted as CustomObject means that the referenced StateDrafts with keys state-B do not exist yet. { \"container\" : \"commercetools-sync-java.UnresolvedTransitionsService.stateDrafts\" , \"key\" : \"518ea82bb78755c0cdd67909dd3206d56186f7e5\" , \"value\" : { \"missingTransitionStateKeys\" : [ \"state-B\" ], \"stateDraft\" : { \"type\" : \"ReviewState\" , \"transitions\" : [ { \"id\" : \"state-B\" , \"typeId\" : \"state\" } ], \"roles\" : [ \"ReviewIncludedInStatistics\" ], \"key\" : \"state-A\" , \"initial\" : true } } } As soon, as the referenced StateDrafts are supplied to the sync, the draft will be created/updated and the CustomObject will be removed from the target project. Keeping the old custom objects around forever can negatively influence the performance of your project and the time it takes to restore it from a backup. Deleting unused data ensures the best performance for your project. Please have a look into the Cleanup guide to cleanup old unresolved custom objects.","title":"Persistence of StateDrafts with missing references"},{"location":"usage/STATE_SYNC/#more-examples-of-how-to-use-the-sync","text":"Sync from another CTP project as a source . Sync from an external source . Make sure to read the Important Usage Tips for optimal performance.","title":"More examples of how to use the sync"},{"location":"usage/STATE_SYNC/#build-all-update-actions","text":"A utility method provided by the library to compare a State with a new StateDraft and results in a list of state update actions. update actions. List < StateUpdateAction > updateActions = StateSyncUtils . buildActions ( state , stateDraft , stateSyncOptions );","title":"Build all update actions"},{"location":"usage/STATE_SYNC/#build-particular-update-actions","text":"Utility methods provided by the library to compare the specific fields of a State and a new StateDraft , and in turn builds the update action. One example is the buildSetNameAction which compares names: Optional < StateUpdateAction > updateAction = StateUpdateActionUtils . buildSetNameAction ( oldState , stateDraft ); More examples of those utils for different types can be found here .","title":"Build particular update action(s)"},{"location":"usage/STATE_SYNC/#migration-guide","text":"The state-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies>","title":"Migration Guide"},{"location":"usage/STATE_SYNC/#client-configuration-and-creation","text":"For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document .","title":"Client configuration and creation"},{"location":"usage/STATE_SYNC/#signature-of-statesyncoptions","text":"As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with State , StateDraft and StateUpdateAction from package com.commercetools.api.models.state.* Note: Type StateUpdateAction has changed to StateUpdateAction . Make sure you create and supply a specific StateUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a state update action to change name taking the 'newName' of the stateDraft final Function < LocalizedString , StateUpdateAction > createBeforeUpdateAction = ( newName ) -> StateSetNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < StateUpdateAction > , StateDraft , State , List < StateUpdateAction >> beforeUpdateStateCallback = ( updateActions , newStateDraft , oldState ) -> { final StateUpdateAction beforeUpdateAction = createBeforeUpdateAction . apply ( newStateDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; };","title":"Signature of StateSyncOptions"},{"location":"usage/STATE_SYNC/#build-statedraft-syncing-from-external-project","text":"The state-sync expects a list of StateDraft s to process. If you use java-sync-library to sync your states from any external system into a commercetools platform project you have to convert your data into CTP compatible StateDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // StateDraftBuilder in v1 takes parameters 'key', 'type' final StateDraft stateDraft = StateDraftBuilder . of ( \"key\" , StateType . LINE_ITEM_STATE ) . name ( ofEnglish ( \"state-name\" )) . description ( ofEnglish ( \"state-desc\" )) . roles ( Collections . singleton ( StateRole . RETURN )) . initial ( false ) . build (); // StateDraftBuilder in v2 final StateDraft stateDraft = StateDraftBuilder . of () . key ( \"key\" ) . type ( StateTypeEnum . LINE_ITEM_STATE ) . name ( ofEnglish ( \"state-name\" )) . description ( ofEnglish ( \"state-desc\" )) . roles ( StateRoleEnum . RETURN ) . initial ( false ) . build (); For more information, see the Guide to replace DraftBuilders .","title":"Build StateDraft (syncing from external project)"},{"location":"usage/STATE_SYNC/#query-for-states-syncing-from-ctp-project","text":"If you sync states between different commercetools projects you probably use StateTransformUtils#toStateDrafts to transform State into StateDraft which can be used by the state-sync. However, if you need to query states from a commercetools project instead of passing StateQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: StateQuery to fetch all states final StateQuery query = StateQuery . of (); final PagedQueryResult < State > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all states in one line final StatePagedQueryResponse result = apiRoot . states (). get (). executeBlocking (). getBody (); Read more about querying resources.","title":"Query for states (syncing from CTP project)"},{"location":"usage/STATE_SYNC/#referencing-other-states-in-transitions","text":"When you use references to other states in the field transitions , the state-sync needs to do the reference resolution process. In the previous java-sdk-v1 it was required to provide the key value on the id field of the reference. In the current java-sdk-v2 you must provide the key field in StateResourceIdentifier . For detailed information see the Reference resolution section .","title":"Referencing other states in transitions"},{"location":"usage/SYNC_OPTIONS/","text":"Sync Options \u00b6 errorCallback \u00b6 a callback that is called whenever an error event occurs during the sync process. It contains the following information about the error-event: sync exception the resource draft of the source project the resource of the target project the update-actions, which failed warningCallback \u00b6 a callback that is called whenever a warning event occurs during the sync process. It contains the following information about the warning message: sync exception the resource draft of the source project the resource of the target project beforeUpdateCallback \u00b6 during the sync process, if a target resource and a resource draft are matched, this callback can be used to intercept the update request just before it is sent to CTP. It contains information about the resource draft, the target resource, and the update actions that were calculated after comparing both. beforeCreateCallback \u00b6 during the sync process, if a resource draft should be created, this callback can be used to intercept the create request just before it sent to CTP. It contains information about the resource draft that should be created. batchSize \u00b6 a number that could be used to set the batch size with which resources are fetched and processed, as resources are obtained from the target CTP project in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetch the corresponding resources from the target CTP project in a single request. Playing with this option can slightly improve or reduce processing speed. cacheSize \u00b6 In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for the sync. syncFilter (Only for Product Sync Options) \u00b6 represents either a blacklist or a whitelist for filtering certain update action groups. Blacklisting an update action group means that everything in products will be synced except for any group in the blacklist. A typical use case is to blacklist prices when syncing products. In other words, syncing everything in products except for prices. Whitelisting an update action group means that the groups in this whitelist will be the only group synced in products. One use case could be to whitelist prices when syncing products. In other words, syncing prices only in products and nothing else. The list of action groups allowed to be blacklisted or whitelisted on products can be found here . ensureChannels (Only for Product and Inventory Sync Options) \u00b6 a flag that represents a strategy to handle syncing inventory entries with missing channels. Having an inventory entry or a product, with a missing channel reference, could be processed in either of the following ways: - If ensureChannels is set to false this inventory entry/product won't be synced and the errorCallback will be triggered. - If ensureChannels is set to true the sync will attempt to create the missing channel with the given key. If it fails to create the supply channel, the inventory entry/product won't sync and errorCallback will be triggered. - If not provided, it is set to false by default. Examples \u00b6 1. Using errorCallback and warningCallback for logging \u00b6 final Logger logger = LoggerFactory . getLogger ( MySync . class ); final ProductSyncOptions productsyncOptions = ProductSyncOptionsBuilder . of ( sphereClient ) . errorCallback (( syncException , draft , product , updateActions ) -> logger . error ( syncException . getMessage (), syncException )) . warningCallback (( exception , oldResource , newResources ) -> logger . warn ( exception . getMessage (), exception )) . build (); 2. Using beforeUpdateCallback for syncing a single locale . \u00b6 3. Using beforeUpdateCallback for keeping other variants . \u00b6 4. Using syncFilter for blacklisting product categories while syncing products . \u00b6 5. Using syncFilter for whitelisting product names while syncing products . \u00b6","title":"Sync Options"},{"location":"usage/SYNC_OPTIONS/#sync-options","text":"","title":"Sync Options"},{"location":"usage/SYNC_OPTIONS/#errorcallback","text":"a callback that is called whenever an error event occurs during the sync process. It contains the following information about the error-event: sync exception the resource draft of the source project the resource of the target project the update-actions, which failed","title":"errorCallback"},{"location":"usage/SYNC_OPTIONS/#warningcallback","text":"a callback that is called whenever a warning event occurs during the sync process. It contains the following information about the warning message: sync exception the resource draft of the source project the resource of the target project","title":"warningCallback"},{"location":"usage/SYNC_OPTIONS/#beforeupdatecallback","text":"during the sync process, if a target resource and a resource draft are matched, this callback can be used to intercept the update request just before it is sent to CTP. It contains information about the resource draft, the target resource, and the update actions that were calculated after comparing both.","title":"beforeUpdateCallback"},{"location":"usage/SYNC_OPTIONS/#beforecreatecallback","text":"during the sync process, if a resource draft should be created, this callback can be used to intercept the create request just before it sent to CTP. It contains information about the resource draft that should be created.","title":"beforeCreateCallback"},{"location":"usage/SYNC_OPTIONS/#batchsize","text":"a number that could be used to set the batch size with which resources are fetched and processed, as resources are obtained from the target CTP project in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetch the corresponding resources from the target CTP project in a single request. Playing with this option can slightly improve or reduce processing speed.","title":"batchSize"},{"location":"usage/SYNC_OPTIONS/#cachesize","text":"In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for the sync.","title":"cacheSize"},{"location":"usage/SYNC_OPTIONS/#syncfilter-only-for-product-sync-options","text":"represents either a blacklist or a whitelist for filtering certain update action groups. Blacklisting an update action group means that everything in products will be synced except for any group in the blacklist. A typical use case is to blacklist prices when syncing products. In other words, syncing everything in products except for prices. Whitelisting an update action group means that the groups in this whitelist will be the only group synced in products. One use case could be to whitelist prices when syncing products. In other words, syncing prices only in products and nothing else. The list of action groups allowed to be blacklisted or whitelisted on products can be found here .","title":"syncFilter (Only for Product Sync Options)"},{"location":"usage/SYNC_OPTIONS/#ensurechannels-only-for-product-and-inventory-sync-options","text":"a flag that represents a strategy to handle syncing inventory entries with missing channels. Having an inventory entry or a product, with a missing channel reference, could be processed in either of the following ways: - If ensureChannels is set to false this inventory entry/product won't be synced and the errorCallback will be triggered. - If ensureChannels is set to true the sync will attempt to create the missing channel with the given key. If it fails to create the supply channel, the inventory entry/product won't sync and errorCallback will be triggered. - If not provided, it is set to false by default.","title":"ensureChannels (Only for Product and Inventory Sync Options)"},{"location":"usage/SYNC_OPTIONS/#examples","text":"","title":"Examples"},{"location":"usage/SYNC_OPTIONS/#1-using-errorcallback-and-warningcallback-for-logging","text":"final Logger logger = LoggerFactory . getLogger ( MySync . class ); final ProductSyncOptions productsyncOptions = ProductSyncOptionsBuilder . of ( sphereClient ) . errorCallback (( syncException , draft , product , updateActions ) -> logger . error ( syncException . getMessage (), syncException )) . warningCallback (( exception , oldResource , newResources ) -> logger . warn ( exception . getMessage (), exception )) . build ();","title":"1. Using errorCallback and warningCallback for logging"},{"location":"usage/SYNC_OPTIONS/#2-using-beforeupdatecallback-for-syncing-a-single-locale","text":"","title":"2. Using beforeUpdateCallback for syncing a single locale."},{"location":"usage/SYNC_OPTIONS/#3-using-beforeupdatecallback-for-keeping-other-variants","text":"","title":"3. Using beforeUpdateCallback for keeping other variants."},{"location":"usage/SYNC_OPTIONS/#4-using-syncfilter-for-blacklisting-product-categories-while-syncing-products","text":"","title":"4. Using syncFilter for blacklisting product categories while syncing products."},{"location":"usage/SYNC_OPTIONS/#5-using-syncfilter-for-whitelisting-product-names-while-syncing-products","text":"","title":"5. Using syncFilter for whitelisting product names while syncing products."},{"location":"usage/TAX_CATEGORY_SYNC/","text":"Tax Category Sync \u00b6 Allows importing/syncing TaxCategory into a commercetools project. It also provides utilities for generating update actions based on the comparison of a TaxCategory against a TaxCategoryDraft . Usage Prerequisites ProjectApiRoot Required Fields SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync More examples of how to use the sync Build all update actions Build particular update action(s) Migration Guide Client configuration and creation Signature of TaxCategorySyncOptions Build TaxCategoryDraft (syncing from external project) Query for TaxCategories (syncing from CTP project) JVM-SDK-V2 migration guide Usage \u00b6 Prerequisites \u00b6 ProjectApiRoot \u00b6 Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" ); Required Fields \u00b6 The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note TaxCategoryDraft key Also, the tax categories in the target project are expected to have the key fields set. SyncOptions \u00b6 After the projectApiRoot is set up, a TaxCategorySyncOptions should be built as follows: // instantiating a TaxCategorySyncOptions final TaxCategorySyncOptions taxCategorySyncOptions = TaxCategorySyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations: errorCallback \u00b6 A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception tax category draft from the source tax category of the target project (only provided if an existing tax category could be found) the update-actions, which failed (only provided if an existing tax category could be found) final Logger logger = LoggerFactory . getLogger ( TaxCategorySync . class ); final TaxCategorySyncOptions taxCategorySyncOptions = TaxCategorySyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , taxCategory , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build (); warningCallback \u00b6 A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception tax category draft from the source tax category of the target project (only provided if an existing tax category could be found) final Logger logger = LoggerFactory . getLogger ( TaxCategorySync . class ); final TaxCategorySyncOptions taxCategorySyncOptions = TaxCategorySyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , taxCategory ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build (); beforeUpdateCallback \u00b6 During the sync process, if a target tax category and a tax category draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : tax category draft from the source tax category from the target project update actions that were calculated after comparing both final TriFunction < List < TaxCategoryUpdateAction > , TaxCategoryDraft , TaxCategory , List < TaxCategoryUpdateAction >> beforeUpdateTaxCategoryCallback = ( updateActions , newTaxCategoryDraft , oldTaxCategory ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof TaxCategoryRemoveTaxRateAction )) . collect ( Collectors . toList ()); final TaxCategorySyncOptions taxCategorySyncOptions = TaxCategorySyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateTaxCategoryCallback ). build (); beforeCreateCallback \u00b6 During the sync process, if a tax category draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : tax category draft that should be created Please refer to example in product sync document . batchSize \u00b6 A number that could be used to set the batch size with which tax categories are fetched and processed, as tax categories are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding tax categories from the target project on commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for tax category sync. final TaxCategorySyncOptions taxCategorySyncOptions = TaxCategorySyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build (); cacheSize \u00b6 In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for tax category sync. final TaxCategorySyncOptions taxCategorySyncOptions = TaxCategorySyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build (); Running the sync \u00b6 After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a TaxCategorySync final TaxCategorySync taxCategorySync = new TaxCategorySync ( taxCategorySyncOptions ); // execute the sync on your list of tax categories CompletionStage < TaxCategorySyncStatistics > syncStatisticsStage = taxCategorySync . sync ( taxCategoryDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a TaxCategorySyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed tax categories and the processing time of the last sync batch in different time units and in a human-readable format. final TaxCategorySyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 2000 tax categories were processed in total (1000 created, 995 updated, 5 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied. More examples of how to use the sync \u00b6 Sync from an external source . Make sure to read the Important Usage Tips for optimal performance. Build all update actions \u00b6 A utility method provided by the library to compare a TaxCategory with a new TaxCategoryDraft and results in a list of tax category update actions. List < TaxCategoryUpdateAction > updateActions = TaxCategorySyncUtils . buildActions ( taxCategory , taxCategoryDraft , taxCategorySyncOptions ); Build particular update action(s) \u00b6 Utility methods provided by the library to compare the specific fields of a TaxCategory and a new TaxCategoryDraft , and in turn builds the update action. One example is the buildChangeNameUpdateAction which compares names: Optional < TaxCategoryUpdateAction > updateAction = TaxCategoryUpdateActionUtils . buildChangeNameAction ( oldTaxCategory , taxCategoryDraft ); More examples of those utils for different tax categories can be found here . Migration Guide \u00b6 The tax-category-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies> Client configuration and creation \u00b6 For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document . Signature of TaxCategorySyncOptions \u00b6 As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with TaxCategoryDraft , TaxCategory and TaxCategoryUpdateAction from package com.commercetools.api.models.tax_category.* Note: Type UpdateAction<TaxCategory> has changed to TaxCategoryUpdateAction . Make sure you create and supply a specific TaxCategoryUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a tax-category update action to change name taking the 'newName' of the taxCategoryDraft final Function < String , TaxCategoryUpdateAction > changeNameBeforeUpdateAction = ( newName ) -> TaxCategoryChangeNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < TaxCategoryUpdateAction > , TaxCategoryDraft , TaxCategory , List < TaxCategoryUpdateAction >> beforeUpdateTypeCallback = ( updateActions , newTaxCategoryDraft , oldTaxCategory ) -> { final TaxCategoryUpdateAction beforeUpdateAction = changeNameBeforeUpdateAction . apply ( newTaxCategoryDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; }; Build TaxCategoryDraft (syncing from external project) \u00b6 The tax-category-sync expects a list of TaxCategoryDraft s to process. If you use java-sync-library to sync your types from any external system into a commercetools platform project you have to convert your data into CTP compatible TaxCategoryDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // TaxCategoryDraftBuilder in v1 takes parameters 'name', 'taxRates' and 'description' final TaxCategoryDraft taxCategoryDraft = TaxCategoryDraftBuilder . of ( \"name\" , emptyList (), \"description\" ) . key ( \"key\" ) . build (); // TaxCategoryDraftBuilder in v2. final TaxCategoryDraft taxCategoryDraft = TaxCategoryDraftBuilder . of () . key ( \"key\" ) . name ( \"name\" ) . rates ( emptyList ()) . description ( \"description\" ) . build (); For more information, see the Guide to replace DraftBuilders . Query for TaxCategories (syncing from CTP project) \u00b6 If you sync types between different commercetools projects you have to transform TaxCategory into TaxCategoryDraft . However, if you need to query TaxCategory from a commercetools project instead of passing TaxCategoryQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: TaxCategoryQuery to fetch all taxCategories final TaxCategoryQuery query = TaxCategoryQuery . of (); final PagedQueryResult < TaxCategory > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all tax-categories in one line final TaxCategoryPagedQueryResponse result = apiRoot . taxCategories (). get (). executeBlocking (). getBody (); Read more about querying resources. JVM-SDK-V2 migration guide \u00b6 On any other needs to migrate your project using jvm-sdk-v2 please refer to it's Migration Guide .","title":"TaxCategory Sync"},{"location":"usage/TAX_CATEGORY_SYNC/#tax-category-sync","text":"Allows importing/syncing TaxCategory into a commercetools project. It also provides utilities for generating update actions based on the comparison of a TaxCategory against a TaxCategoryDraft . Usage Prerequisites ProjectApiRoot Required Fields SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync More examples of how to use the sync Build all update actions Build particular update action(s) Migration Guide Client configuration and creation Signature of TaxCategorySyncOptions Build TaxCategoryDraft (syncing from external project) Query for TaxCategories (syncing from CTP project) JVM-SDK-V2 migration guide","title":"Tax Category Sync"},{"location":"usage/TAX_CATEGORY_SYNC/#usage","text":"","title":"Usage"},{"location":"usage/TAX_CATEGORY_SYNC/#prerequisites","text":"","title":"Prerequisites"},{"location":"usage/TAX_CATEGORY_SYNC/#projectapiroot","text":"Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" );","title":"ProjectApiRoot"},{"location":"usage/TAX_CATEGORY_SYNC/#required-fields","text":"The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note TaxCategoryDraft key Also, the tax categories in the target project are expected to have the key fields set.","title":"Required Fields"},{"location":"usage/TAX_CATEGORY_SYNC/#syncoptions","text":"After the projectApiRoot is set up, a TaxCategorySyncOptions should be built as follows: // instantiating a TaxCategorySyncOptions final TaxCategorySyncOptions taxCategorySyncOptions = TaxCategorySyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations:","title":"SyncOptions"},{"location":"usage/TAX_CATEGORY_SYNC/#errorcallback","text":"A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception tax category draft from the source tax category of the target project (only provided if an existing tax category could be found) the update-actions, which failed (only provided if an existing tax category could be found) final Logger logger = LoggerFactory . getLogger ( TaxCategorySync . class ); final TaxCategorySyncOptions taxCategorySyncOptions = TaxCategorySyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , taxCategory , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"errorCallback"},{"location":"usage/TAX_CATEGORY_SYNC/#warningcallback","text":"A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception tax category draft from the source tax category of the target project (only provided if an existing tax category could be found) final Logger logger = LoggerFactory . getLogger ( TaxCategorySync . class ); final TaxCategorySyncOptions taxCategorySyncOptions = TaxCategorySyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , taxCategory ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"warningCallback"},{"location":"usage/TAX_CATEGORY_SYNC/#beforeupdatecallback","text":"During the sync process, if a target tax category and a tax category draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : tax category draft from the source tax category from the target project update actions that were calculated after comparing both final TriFunction < List < TaxCategoryUpdateAction > , TaxCategoryDraft , TaxCategory , List < TaxCategoryUpdateAction >> beforeUpdateTaxCategoryCallback = ( updateActions , newTaxCategoryDraft , oldTaxCategory ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof TaxCategoryRemoveTaxRateAction )) . collect ( Collectors . toList ()); final TaxCategorySyncOptions taxCategorySyncOptions = TaxCategorySyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateTaxCategoryCallback ). build ();","title":"beforeUpdateCallback"},{"location":"usage/TAX_CATEGORY_SYNC/#beforecreatecallback","text":"During the sync process, if a tax category draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : tax category draft that should be created Please refer to example in product sync document .","title":"beforeCreateCallback"},{"location":"usage/TAX_CATEGORY_SYNC/#batchsize","text":"A number that could be used to set the batch size with which tax categories are fetched and processed, as tax categories are obtained from the target project on the commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding tax categories from the target project on commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for tax category sync. final TaxCategorySyncOptions taxCategorySyncOptions = TaxCategorySyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build ();","title":"batchSize"},{"location":"usage/TAX_CATEGORY_SYNC/#cachesize","text":"In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for tax category sync. final TaxCategorySyncOptions taxCategorySyncOptions = TaxCategorySyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build ();","title":"cacheSize"},{"location":"usage/TAX_CATEGORY_SYNC/#running-the-sync","text":"After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a TaxCategorySync final TaxCategorySync taxCategorySync = new TaxCategorySync ( taxCategorySyncOptions ); // execute the sync on your list of tax categories CompletionStage < TaxCategorySyncStatistics > syncStatisticsStage = taxCategorySync . sync ( taxCategoryDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a TaxCategorySyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed tax categories and the processing time of the last sync batch in different time units and in a human-readable format. final TaxCategorySyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 2000 tax categories were processed in total (1000 created, 995 updated, 5 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied.","title":"Running the sync"},{"location":"usage/TAX_CATEGORY_SYNC/#more-examples-of-how-to-use-the-sync","text":"Sync from an external source . Make sure to read the Important Usage Tips for optimal performance.","title":"More examples of how to use the sync"},{"location":"usage/TAX_CATEGORY_SYNC/#build-all-update-actions","text":"A utility method provided by the library to compare a TaxCategory with a new TaxCategoryDraft and results in a list of tax category update actions. List < TaxCategoryUpdateAction > updateActions = TaxCategorySyncUtils . buildActions ( taxCategory , taxCategoryDraft , taxCategorySyncOptions );","title":"Build all update actions"},{"location":"usage/TAX_CATEGORY_SYNC/#build-particular-update-actions","text":"Utility methods provided by the library to compare the specific fields of a TaxCategory and a new TaxCategoryDraft , and in turn builds the update action. One example is the buildChangeNameUpdateAction which compares names: Optional < TaxCategoryUpdateAction > updateAction = TaxCategoryUpdateActionUtils . buildChangeNameAction ( oldTaxCategory , taxCategoryDraft ); More examples of those utils for different tax categories can be found here .","title":"Build particular update action(s)"},{"location":"usage/TAX_CATEGORY_SYNC/#migration-guide","text":"The tax-category-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies>","title":"Migration Guide"},{"location":"usage/TAX_CATEGORY_SYNC/#client-configuration-and-creation","text":"For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document .","title":"Client configuration and creation"},{"location":"usage/TAX_CATEGORY_SYNC/#signature-of-taxcategorysyncoptions","text":"As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with TaxCategoryDraft , TaxCategory and TaxCategoryUpdateAction from package com.commercetools.api.models.tax_category.* Note: Type UpdateAction<TaxCategory> has changed to TaxCategoryUpdateAction . Make sure you create and supply a specific TaxCategoryUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a tax-category update action to change name taking the 'newName' of the taxCategoryDraft final Function < String , TaxCategoryUpdateAction > changeNameBeforeUpdateAction = ( newName ) -> TaxCategoryChangeNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < TaxCategoryUpdateAction > , TaxCategoryDraft , TaxCategory , List < TaxCategoryUpdateAction >> beforeUpdateTypeCallback = ( updateActions , newTaxCategoryDraft , oldTaxCategory ) -> { final TaxCategoryUpdateAction beforeUpdateAction = changeNameBeforeUpdateAction . apply ( newTaxCategoryDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; };","title":"Signature of TaxCategorySyncOptions"},{"location":"usage/TAX_CATEGORY_SYNC/#build-taxcategorydraft-syncing-from-external-project","text":"The tax-category-sync expects a list of TaxCategoryDraft s to process. If you use java-sync-library to sync your types from any external system into a commercetools platform project you have to convert your data into CTP compatible TaxCategoryDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // TaxCategoryDraftBuilder in v1 takes parameters 'name', 'taxRates' and 'description' final TaxCategoryDraft taxCategoryDraft = TaxCategoryDraftBuilder . of ( \"name\" , emptyList (), \"description\" ) . key ( \"key\" ) . build (); // TaxCategoryDraftBuilder in v2. final TaxCategoryDraft taxCategoryDraft = TaxCategoryDraftBuilder . of () . key ( \"key\" ) . name ( \"name\" ) . rates ( emptyList ()) . description ( \"description\" ) . build (); For more information, see the Guide to replace DraftBuilders .","title":"Build TaxCategoryDraft (syncing from external project)"},{"location":"usage/TAX_CATEGORY_SYNC/#query-for-taxcategories-syncing-from-ctp-project","text":"If you sync types between different commercetools projects you have to transform TaxCategory into TaxCategoryDraft . However, if you need to query TaxCategory from a commercetools project instead of passing TaxCategoryQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: TaxCategoryQuery to fetch all taxCategories final TaxCategoryQuery query = TaxCategoryQuery . of (); final PagedQueryResult < TaxCategory > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all tax-categories in one line final TaxCategoryPagedQueryResponse result = apiRoot . taxCategories (). get (). executeBlocking (). getBody (); Read more about querying resources.","title":"Query for TaxCategories (syncing from CTP project)"},{"location":"usage/TAX_CATEGORY_SYNC/#jvm-sdk-v2-migration-guide","text":"On any other needs to migrate your project using jvm-sdk-v2 please refer to it's Migration Guide .","title":"JVM-SDK-V2 migration guide"},{"location":"usage/TYPE_SYNC/","text":"Type Sync \u00b6 The module used for importing/syncing Types into a commercetools project. It also provides utilities for generating update actions based on the comparison of a Type against a TypeDraft . Usage Prerequisites SphereClient Required Fields SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync Important to Note More examples of how to use the sync Build all update actions Build particular update action(s) Caveats Usage \u00b6 Prerequisites \u00b6 ProjectApiRoot \u00b6 Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" ); Required Fields \u00b6 The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note TypeDraft key Also, the types in the target project are expected to have the key fields set. SyncOptions \u00b6 After the projectApiRoot is set up, a TypeSyncOptions should be built as follows: // instantiating a TypeSyncOptions final TypeSyncOptions typeSyncOptions = TypeSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations: errorCallback \u00b6 A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception type draft from the source type of the target project (only provided if an existing type could be found) the update-actions, which failed (only provided if an existing type could be found) final Logger logger = LoggerFactory . getLogger ( TypeSync . class ); final TypeSyncOptions typeSyncOptions = TypeSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , type , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build (); warningCallback \u00b6 A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception type draft from the source type of the target project (only provided if an existing type could be found) final Logger logger = LoggerFactory . getLogger ( TypeSync . class ); final TypeSyncOptions typeSyncOptions = TypeSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , type ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build (); beforeUpdateCallback \u00b6 During the sync process, if a target type and a type draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : type draft from the source type from the target project update actions that were calculated after comparing both // Example: Ignore update actions that remove field definition final TriFunction < List < TypeUpdateAction > , TypeDraft , Type , List < TypeUpdateAction >> beforeUpdateTypeCallback = ( updateActions , newTypeDraft , oldType ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof TypeRemoveFieldDefinitionAction )) . collect ( Collectors . toList ()); final TypeSyncOptions typeSyncOptions = TypeSyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateTypeCallback ). build (); beforeCreateCallback \u00b6 During the sync process, if a type draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : type draft that should be created Please refer to example in product sync document . batchSize \u00b6 A number that could be used to set the batch size with which types are fetched and processed, as types are obtained from the target project on commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding types from the target project on the commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for type sync. final TypeSyncOptions typeSyncOptions = TypeSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build (); cacheSize \u00b6 In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for type sync. final TypeSyncOptions typeSyncOptions = TypeSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build (); Running the sync \u00b6 After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a type sync final TypeSync typeSync = new TypeSync ( typeSyncOptions ); // execute the sync on your list of types CompletionStage < TypeSyncStatistics > syncStatisticsStage = typeSync . sync ( typeDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a TypeSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed types and the processing time of the last sync batch in different time units and in a human-readable format. final TypeSyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 2000 types were processed in total (1000 created, 995 updated, 5 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied. Important to Note \u00b6 If two matching fieldDefinition s (old and new) on the matching type s (old and new) have a different FieldType , the sync will remove the existing fieldDefinition and then add a new fieldDefinition with the new FieldType . The fieldDefinition with missing fieldType (is null ) will not be synced. More examples of how to use the sync \u00b6 Sync from another CTP project as a source . Sync from an external source . Make sure to read the Important Usage Tips for optimal performance. Build all update actions \u00b6 A utility method provided by the library to compare a Type with a new TypeDraft and results in a list of type update actions. List < TypeUpdateAction > updateActions = TypeSyncUtils . buildActions ( type , typeDraft , typeSyncOptions ); Build particular update action(s) \u00b6 Utility methods provided by the library to compare the specific fields of a Type and a new TypeDraft , and in turn builds the update action. One example is the buildChangeNameUpdateAction which compares names: Optional < TypeUpdateAction > updateAction = TypeUpdateActionUtils . buildChangeNameUpdateAction ( oldType , typeDraft ); More examples of those utils for different types can be found here . Migration Guide \u00b6 The type-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies> Client configuration and creation \u00b6 For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document . Signature of TypeSyncOptions \u00b6 As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with TypeDraft , Type and TypeUpdateAction from package com.commercetools.api.models.type.* Note: Type UpdateAction<Type> has changed to TypeUpdateAction . Make sure you create and supply a specific TypeUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a type update action to change name taking the 'newName' of the typeDraft final Function < LocalizedString , TypeUpdateAction > changeNameBeforeUpdateAction = ( newName ) -> TypeChangeNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < TypeUpdateAction > , TypeDraft , Type , List < TypeUpdateAction >> beforeUpdateTypeCallback = ( updateActions , newTypeDraft , oldType ) -> { final TypeUpdateAction beforeUpdateAction = changeNameBeforeUpdateAction . apply ( newTypeDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; }; Build TypeDraft (syncing from external project) \u00b6 The type-sync expects a list of TypeDraft s to process. If you use java-sync-library to sync your types from any external system into a commercetools platform project you have to convert your data into CTP compatible TypeDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // TypeDraftBuilder in v1 takes parameters 'key', 'name' and a set of 'resourceTypeIds' final TypeDraft typeDraft = TypeDraftBuilder . of ( \"type-key\" , ofEnglish ( \"name\" ), ResourceTypeIdsSetBuilder . of (). addCategories (). build ()) . build (); // TypeDraftBuilder in v2. 'resourceTypeIds' is a list TypeDraftBuilder . of () . key ( \"type-key\" ) . name ( LocalizedString . ofEnglish ( \"name\" )) . resourceTypeIds ( ResourceTypeId . CATEGORY ) . build (); For more information, see the Guide to replace DraftBuilders . Query for Types (syncing from CTP project) \u00b6 If you sync types between different commercetools projects you have to transform Type into TypeDraft . However, if you need to query Types from a commercetools project instead of passing TypeQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: TypeQuery to fetch all types final TypeQuery query = TypeQuery . of (); final PagedQueryResult < Type > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all types in one line final TypePagedQueryResponse result = apiRoot . types (). get (). executeBlocking (). getBody (); Read more about querying resources. JVM-SDK-V2 migration guide \u00b6 On any other needs to migrate your project using jvm-sdk-v2 please refer to it's Migration Guide .","title":"Type Sync"},{"location":"usage/TYPE_SYNC/#type-sync","text":"The module used for importing/syncing Types into a commercetools project. It also provides utilities for generating update actions based on the comparison of a Type against a TypeDraft . Usage Prerequisites SphereClient Required Fields SyncOptions errorCallback warningCallback beforeUpdateCallback beforeCreateCallback batchSize cacheSize Running the sync Important to Note More examples of how to use the sync Build all update actions Build particular update action(s) Caveats","title":"Type Sync"},{"location":"usage/TYPE_SYNC/#usage","text":"","title":"Usage"},{"location":"usage/TYPE_SYNC/#prerequisites","text":"","title":"Prerequisites"},{"location":"usage/TYPE_SYNC/#projectapiroot","text":"Use the ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. To create ClientCredentials which are required for creating a client please use the ClientCredentialsBuilder provided in java-sdk-v2 Client OAUTH2 package If you have custom requirements for the client creation, have a look into the Important Usage Tips . final ClientCredentials clientCredentials = new ClientCredentialsBuilder () . withClientId ( \"client-id\" ) . withClientSecret ( \"client-secret\" ) . withScopes ( \"scopes\" ) . build (); final ProjectApiRoot apiRoot = ClientConfigurationUtils . createClient ( \"project-key\" , clientCredentials , \"auth-url\" , \"api-url\" );","title":"ProjectApiRoot"},{"location":"usage/TYPE_SYNC/#required-fields","text":"The following fields are required to be set in, otherwise, they won't be matched by sync: Draft Required Fields Note TypeDraft key Also, the types in the target project are expected to have the key fields set.","title":"Required Fields"},{"location":"usage/TYPE_SYNC/#syncoptions","text":"After the projectApiRoot is set up, a TypeSyncOptions should be built as follows: // instantiating a TypeSyncOptions final TypeSyncOptions typeSyncOptions = TypeSyncOptionsBuilder . of ( projectApiRoot ). build (); SyncOptions is an object which provides a place for users to add certain configurations to customize the sync process. Available configurations:","title":"SyncOptions"},{"location":"usage/TYPE_SYNC/#errorcallback","text":"A callback that is called whenever an error event occurs during the sync process. Each resource executes its own error-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the error-event: sync exception type draft from the source type of the target project (only provided if an existing type could be found) the update-actions, which failed (only provided if an existing type could be found) final Logger logger = LoggerFactory . getLogger ( TypeSync . class ); final TypeSyncOptions typeSyncOptions = TypeSyncOptionsBuilder . of ( projectApiRoot ) . errorCallback (( syncException , draft , type , updateActions ) -> logger . error ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"errorCallback"},{"location":"usage/TYPE_SYNC/#warningcallback","text":"A callback is called whenever a warning event occurs during the sync process. Each resource executes its own warning-callback. When the sync process of a particular resource runs successfully, it is not triggered. It contains the following context about the warning message: sync exception type draft from the source type of the target project (only provided if an existing type could be found) final Logger logger = LoggerFactory . getLogger ( TypeSync . class ); final TypeSyncOptions typeSyncOptions = TypeSyncOptionsBuilder . of ( projectApiRoot ) . warningCallback (( syncException , draft , type ) -> logger . warn ( new SyncException ( \"My customized message\" ), syncException )). build ();","title":"warningCallback"},{"location":"usage/TYPE_SYNC/#beforeupdatecallback","text":"During the sync process, if a target type and a type draft are matched, this callback can be used to intercept the update request just before it is sent to the commercetools platform. This allows the user to modify update actions array with custom actions or discard unwanted actions. The callback provides the following information : type draft from the source type from the target project update actions that were calculated after comparing both // Example: Ignore update actions that remove field definition final TriFunction < List < TypeUpdateAction > , TypeDraft , Type , List < TypeUpdateAction >> beforeUpdateTypeCallback = ( updateActions , newTypeDraft , oldType ) -> updateActions . stream () . filter ( updateAction -> ! ( updateAction instanceof TypeRemoveFieldDefinitionAction )) . collect ( Collectors . toList ()); final TypeSyncOptions typeSyncOptions = TypeSyncOptionsBuilder . of ( projectApiRoot ). beforeUpdateCallback ( beforeUpdateTypeCallback ). build ();","title":"beforeUpdateCallback"},{"location":"usage/TYPE_SYNC/#beforecreatecallback","text":"During the sync process, if a type draft should be created, this callback can be used to intercept the create request just before it is sent to the commercetools platform. It contains the following information : type draft that should be created Please refer to example in product sync document .","title":"beforeCreateCallback"},{"location":"usage/TYPE_SYNC/#batchsize","text":"A number that could be used to set the batch size with which types are fetched and processed, as types are obtained from the target project on commercetools platform in batches for better performance. The algorithm accumulates up to batchSize resources from the input list, then fetches the corresponding types from the target project on the commecetools platform in a single request. Playing with this option can slightly improve or reduce processing speed. If it is not set, the default batch size is 50 for type sync. final TypeSyncOptions typeSyncOptions = TypeSyncOptionsBuilder . of ( projectApiRoot ). batchSize ( 30 ). build ();","title":"batchSize"},{"location":"usage/TYPE_SYNC/#cachesize","text":"In the service classes of the commercetools-sync-java library, we have implemented an in-memory LRU cache to store a map used for the reference resolution of the library. The cache reduces the reference resolution based calls to the commercetools API as the required fields of a resource will be fetched only one time. These cached fields then might be used by another resource referencing the already resolved resource instead of fetching from commercetools API. It turns out, having the in-memory LRU cache will improve the overall performance of the sync library and commercetools API. which will improve the overall performance of the sync and commercetools API. Playing with this option can change the memory usage of the library. If it is not set, the default cache size is 10.000 for type sync. final TypeSyncOptions typeSyncOptions = TypeSyncOptionsBuilder . of ( projectApiRoot ). cacheSize ( 5000 ). build ();","title":"cacheSize"},{"location":"usage/TYPE_SYNC/#running-the-sync","text":"After all the aforementioned points in the previous section have been fulfilled, to run the sync: // instantiating a type sync final TypeSync typeSync = new TypeSync ( typeSyncOptions ); // execute the sync on your list of types CompletionStage < TypeSyncStatistics > syncStatisticsStage = typeSync . sync ( typeDrafts ); The result of completing the syncStatisticsStage in the previous code snippet contains a TypeSyncStatistics which contains all the stats of the sync process; which includes a report message, the total number of updated, created, failed, processed types and the processing time of the last sync batch in different time units and in a human-readable format. final TypeSyncStatistics stats = syncStatisticsStage . toCompletebleFuture (). join (); stats . getReportMessage (); /*\"Summary: 2000 types were processed in total (1000 created, 995 updated, 5 failed to sync).\"*/ Note The statistics object contains the processing time of the last batch only. This is due to two reasons: The sync processing time should not take into account the time between supplying batches to the sync. It is not known by the sync which batch is going to be the last one supplied.","title":"Running the sync"},{"location":"usage/TYPE_SYNC/#important-to-note","text":"If two matching fieldDefinition s (old and new) on the matching type s (old and new) have a different FieldType , the sync will remove the existing fieldDefinition and then add a new fieldDefinition with the new FieldType . The fieldDefinition with missing fieldType (is null ) will not be synced.","title":"Important to Note"},{"location":"usage/TYPE_SYNC/#more-examples-of-how-to-use-the-sync","text":"Sync from another CTP project as a source . Sync from an external source . Make sure to read the Important Usage Tips for optimal performance.","title":"More examples of how to use the sync"},{"location":"usage/TYPE_SYNC/#build-all-update-actions","text":"A utility method provided by the library to compare a Type with a new TypeDraft and results in a list of type update actions. List < TypeUpdateAction > updateActions = TypeSyncUtils . buildActions ( type , typeDraft , typeSyncOptions );","title":"Build all update actions"},{"location":"usage/TYPE_SYNC/#build-particular-update-actions","text":"Utility methods provided by the library to compare the specific fields of a Type and a new TypeDraft , and in turn builds the update action. One example is the buildChangeNameUpdateAction which compares names: Optional < TypeUpdateAction > updateAction = TypeUpdateActionUtils . buildChangeNameUpdateAction ( oldType , typeDraft ); More examples of those utils for different types can be found here .","title":"Build particular update action(s)"},{"location":"usage/TYPE_SYNC/#migration-guide","text":"The type-sync uses the JVM-SDK-V2 , therefore ensure you Install JVM SDK module commercetools-sdk-java-api with any HTTP client module. The default one is commercetools-http-client . <!-- Sample maven pom.xml --> <properties> <commercetools.version> LATEST </commercetools.version> </properties> <dependencies> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-http-client </artifactId> <version> ${commercetools.version} </version> </dependency> <dependency> <groupId> com.commercetools.sdk </groupId> <artifactId> commercetools-sdk-java-api </artifactId> <version> ${commercetools.version} </version> </dependency> </dependencies>","title":"Migration Guide"},{"location":"usage/TYPE_SYNC/#client-configuration-and-creation","text":"For client creation use ClientConfigurationUtils which apply the best practices for ProjectApiRoot creation. If you have custom requirements for the client creation make sure to replace SphereClientFactory with ApiRootBuilder as described in this Migration Document .","title":"Client configuration and creation"},{"location":"usage/TYPE_SYNC/#signature-of-typesyncoptions","text":"As models and update actions have changed in the JVM-SDK-V2 the signature of SyncOptions is different. It's constructor now takes a ProjectApiRoot as first argument. The callback functions are signed with TypeDraft , Type and TypeUpdateAction from package com.commercetools.api.models.type.* Note: Type UpdateAction<Type> has changed to TypeUpdateAction . Make sure you create and supply a specific TypeUpdateAction in beforeUpdateCallback . For that you can use the library-utilities or use a JVM-SDK builder ( see also ): // Example: Create a type update action to change name taking the 'newName' of the typeDraft final Function < LocalizedString , TypeUpdateAction > changeNameBeforeUpdateAction = ( newName ) -> TypeChangeNameAction . builder (). name ( newName ). build (); // Add the change name action to the list of update actions before update is executed final TriFunction < List < TypeUpdateAction > , TypeDraft , Type , List < TypeUpdateAction >> beforeUpdateTypeCallback = ( updateActions , newTypeDraft , oldType ) -> { final TypeUpdateAction beforeUpdateAction = changeNameBeforeUpdateAction . apply ( newTypeDraft . getName ()); updateActions . add ( beforeUpdateAction ); return updateActions ; };","title":"Signature of TypeSyncOptions"},{"location":"usage/TYPE_SYNC/#build-typedraft-syncing-from-external-project","text":"The type-sync expects a list of TypeDraft s to process. If you use java-sync-library to sync your types from any external system into a commercetools platform project you have to convert your data into CTP compatible TypeDraft type. This was done in previous version using DraftBuilder s. The V2 SDK do not have inheritance for DraftBuilder classes but the differences are minor and you can replace it easily. Here's an example: // TypeDraftBuilder in v1 takes parameters 'key', 'name' and a set of 'resourceTypeIds' final TypeDraft typeDraft = TypeDraftBuilder . of ( \"type-key\" , ofEnglish ( \"name\" ), ResourceTypeIdsSetBuilder . of (). addCategories (). build ()) . build (); // TypeDraftBuilder in v2. 'resourceTypeIds' is a list TypeDraftBuilder . of () . key ( \"type-key\" ) . name ( LocalizedString . ofEnglish ( \"name\" )) . resourceTypeIds ( ResourceTypeId . CATEGORY ) . build (); For more information, see the Guide to replace DraftBuilders .","title":"Build TypeDraft (syncing from external project)"},{"location":"usage/TYPE_SYNC/#query-for-types-syncing-from-ctp-project","text":"If you sync types between different commercetools projects you have to transform Type into TypeDraft . However, if you need to query Types from a commercetools project instead of passing TypeQuery s to a sphereClient , create (and execute) requests directly from the apiRoot . Here's an example: // SDK v1: TypeQuery to fetch all types final TypeQuery query = TypeQuery . of (); final PagedQueryResult < Type > pagedQueryResult = sphereClient . executeBlocking ( query ); // SDK v2: Create and execute query to fetch all types in one line final TypePagedQueryResponse result = apiRoot . types (). get (). executeBlocking (). getBody (); Read more about querying resources.","title":"Query for Types (syncing from CTP project)"},{"location":"usage/TYPE_SYNC/#jvm-sdk-v2-migration-guide","text":"On any other needs to migrate your project using jvm-sdk-v2 please refer to it's Migration Guide .","title":"JVM-SDK-V2 migration guide"}]}